# 📝 Navigator - 설계 결정 기록

> Architecture Decision Records (ADR)

**왜 이렇게 설계했는가? 다른 방법은 없었는가?**

---

## Decision 1: 자동 우선순위 vs 수동 우선순위

**날짜**: 2026-01-27

### 상황
사용자가 작업의 우선순위를 판단하기 어려워함. 감정/피로도에 따라 중요도가 임의로 바뀜.

### 고려한 옵션

#### 옵션 A: 수동 우선순위
```
장점:
- 사용자가 직접 제어
- 유연함
- 구현 간단

단점:
- 매번 판단 필요 (판단 피로)
- ADHD에 불리
- 시간 소비
```

#### 옵션 B: 자동 우선순위
```
장점:
- 판단 제거
- 즉시 실행 가능
- ADHD 친화적

단점:
- 알고리즘 복잡
- 완벽하지 않을 수 있음
- 투명성 부족
```

### 결정
**옵션 B: 자동 우선순위**

### 이유
1. ADHD 사용자는 실행 기능 장애가 있음
2. 판단 = 에너지 소비 = 실행 안 함
3. "생각 안 하고 실행하게"가 핵심 철학
4. 불완벽해도 판단 안 하는 게 더 나음

### 트레이드오프
- 사용자가 의도와 다를 수 있음
- 하지만: 수동 조정 (수정 기능) 제공
- 알고리즘은 계속 개선 가능

### 결과
✅ 성공. 사용자가 고민 없이 바로 실행.

---

## Decision 2: Next-Action 단일 표시 vs 전체 리스트

**날짜**: 2026-01-27

### 상황
작업이 10개 이상일 때, 어떻게 보여줄 것인가?

### 고려한 옵션

#### 옵션 A: 전체 리스트
```
장점:
- 전체 파악 가능
- 일반적인 Todo 앱 방식

단점:
- 선택 장벽 ("뭐부터?")
- 압도감 (10개 보면 포기)
- 우선순위 혼란
```

#### 옵션 B: Next-Action 하나만
```
장점:
- 선택 불가능 (생각 제거)
- 압도감 제거
- 즉시 실행

단점:
- 전체 파악 어려움
- 불안감 (나머지는?)
```

#### 옵션 C: 하이브리드
```
장점:
- Next-Action 크게 + 리스트 접기
- 필요시 펼쳐보기

단점:
- 복잡도 증가
```

### 결정
**옵션 C: 하이브리드**

Next-Action 크게 표시 + "전체 목록 보기" 접기/펼치기

### 이유
1. 기본은 단순하게 (Next-Action)
2. 불안한 사람은 펼쳐보기 가능
3. 선택의 자유 유지
4. 점진적 공개 (Progressive Disclosure)

### 트레이드오프
- UI 복잡도 약간 증가
- 하지만: 사용자 제어권 증가

### 결과
✅ 성공. 대부분 Next-Action만 보고, 가끔 리스트 확인.

---

## Decision 3: 카테고리별 입력 필드 차이

**날짜**: 2026-01-28

### 상황
본업/부업/일상 모두 같은 입력 필드를 요구하면, 불필요한 정보도 입력해야 함.

### 고려한 옵션

#### 옵션 A: 동일한 입력 필드
```
장점:
- 구현 간단
- 일관성

단점:
- 불필요한 필드 (본업에 예상수익?)
- 입력 장벽 증가
```

#### 옵션 B: 카테고리별 맞춤
```
장점:
- 맥락에 맞음
- 입력 부담 감소

단점:
- 구현 복잡
- 일관성 감소
```

### 결정
**옵션 B: 카테고리별 맞춤**

- 본업: 마감/시간/링크
- 부업: 마감/시간/수익(선택)/링크
- 일상: 시간만

### 이유
1. 본업은 예상수익 무의미 (월급)
2. 부업은 수익 모를 수 있음 (선택사항)
3. 일상은 수익 무관
4. 맥락에 맞게 = 사용성 증가

### 트레이드오프
- 코드 복잡도 증가
- 하지만: 사용자 경험 크게 개선

### 결과
✅ 성공. 불필요한 입력 제거 → 빠른 추가.

---

## Decision 4: 스와이프 제스처 vs 버튼만

**날짜**: 2026-01-28

### 상황
모바일에서 작업을 완료/삭제하는 방법.

### 고려한 옵션

#### 옵션 A: 버튼만
```
장점:
- 명확함
- 실수 방지

단점:
- 클릭 정확도 필요
- 느림 (찾기 → 클릭)
```

#### 옵션 B: 스와이프만
```
장점:
- 빠름
- 직관적

단점:
- 실수 가능
- 발견성 낮음 (처음 모름)
```

#### 옵션 C: 스와이프 + 버튼
```
장점:
- 파워 유저: 스와이프
- 초보: 버튼

단점:
- 복잡도 증가
```

### 결정
**옵션 C: 스와이프 + 버튼**

- ← 왼쪽 스와이프: 완료
- → 오른쪽 스와이프: 삭제
- 버튼: 항상 표시

### 이유
1. 모바일 UX 표준 (iOS/Android)
2. 빠른 액션 (파워 유저)
3. 명확한 대안 (초보자)
4. 점진적 학습

### 트레이드오프
- 구현 복잡도 증가
- 하지만: 사용성 크게 향상

### 결과
✅ 성공. 익숙해지면 스와이프만 사용.

---

## Decision 5: LocalStorage vs 서버

**날짜**: 2026-01-27

### 상황
Phase 1에서 데이터를 어디에 저장할 것인가?

### 고려한 옵션

#### 옵션 A: 서버 (Supabase)
```
장점:
- 크로스 플랫폼 동기화
- 백업 자동
- 확장 가능

단점:
- 시간 오래 걸림
- 초기 설정 복잡
- 인증 필요
- 빠른 검증 불가
```

#### 옵션 B: LocalStorage
```
장점:
- 즉시 작동
- 간단함
- 인증 불필요
- 빠른 검증

단점:
- 단일 기기만
- 백업 수동
- 크기 제한 (5MB)
```

### 결정
**Phase 1: LocalStorage → Phase 3: Supabase**

### 이유
1. "작동하는 쓰레기 → 좋은 코드" 전략
2. 빠른 검증이 우선
3. 사용자 피드백 먼저 수집
4. 나중에 마이그레이션

### 트레이드오프
- 초기에는 동기화 안 됨
- 하지만: JSON 백업으로 수동 이관 가능
- Phase 3에서 자동화

### 결과
✅ 성공. 빠르게 검증 완료. Phase 3 준비 중.

---

## Decision 6: Vanilla JS vs React (Phase 1)

**날짜**: 2026-01-27

### 상황
Phase 1 프로토타입을 무엇으로 만들 것인가?

### 고려한 옵션

#### 옵션 A: React
```
장점:
- 컴포넌트 재사용
- 상태 관리 쉬움
- 성능 좋음

단점:
- 빌드 설정 필요
- 배포 복잡
- 학습 곡선 (비전공자)
```

#### 옵션 B: Vanilla JS
```
장점:
- 즉시 작동 (HTML 열면 끝)
- 배포 불필요
- 학습 부담 적음

단점:
- 상태 관리 어려움
- 성능 안 좋음
- 확장 어려움
```

### 결정
**Phase 1: Vanilla JS → Phase 2: React (Next.js)**

### 이유
1. 비전공자 4일차
2. 빠른 검증 우선
3. 빌드/배포 시간 절약
4. 바로 쓸 수 있어야 함

### 트레이드오프
- 기술부채 쌓임
- 하지만: Phase 2에서 정리
- 학습하며 전환

### 결과
✅ 성공. 빠르게 프로토타입 완성. Phase 2 전환 준비 중.

---

## Decision 7: 완료 후 숨김 vs 보여주기

**날짜**: 2026-01-28

### 상황
완료한 작업을 어떻게 표시할 것인가?

### 고려한 옵션

#### 옵션 A: 즉시 숨김
```
장점:
- 깔끔함
- 집중

단점:
- 성취감 적음
- 실수 시 되돌리기 어려움
```

#### 옵션 B: 항상 표시
```
장점:
- 성취감
- 투명성

단점:
- 목록 길어짐
- 산만함
```

#### 옵션 C: 토글 (접기/펼치기)
```
장점:
- 선택의 자유
- 필요시 확인

단점:
- 복잡도 증가
```

### 결정
**옵션 C: 토글**

기본은 숨김 + "완료한 작업 보기" 버튼

### 이유
1. 기본은 깔끔하게
2. 성취감 원하면 펼치기
3. 완료 취소 가능
4. 사용자 제어권

### 트레이드오프
- UI 복잡도 약간 증가
- 하지만: 유연성 증가

### 결과
✅ 성공. 원하는 사람만 펼쳐봄.

---

## Decision 8: 모드 자동 전환 vs 수동 선택

**날짜**: 2026-01-27

### 상황
회사/생존/여유 모드를 어떻게 전환할 것인가?

### 고려한 옵션

#### 옵션 A: 수동 선택
```
장점:
- 사용자 제어
- 명확함

단점:
- 매번 선택 필요
- 깜빡함
```

#### 옵션 B: 자동 전환
```
장점:
- 생각 불필요
- 정확함

단점:
- 투명성 부족
- 유연성 감소
```

### 결정
**옵션 B: 자동 전환**

시간대 + 셔틀 상태로 자동 판단

### 이유
1. "생각 안 하고 실행하게"
2. 시간은 변하지 않음 (신뢰 가능)
3. 셔틀만 수동 (하루 1번)
4. 깜빡임 방지

### 트레이드오프
- 예외 상황 대응 어려움
- 하지만: 대부분 케이스 커버
- 나중에 수동 오버라이드 추가 가능

### 결과
✅ 성공. 자동으로 딱 맞게 전환됨.

---

## Decision 9: JSON 백업 수동 vs 자동

**날짜**: 2026-01-28

### 상황
Phase 1에서 데이터 백업을 어떻게 할 것인가?

### 고려한 옵션

#### 옵션 A: 자동 백업
```
장점:
- 안전함
- 사용자 신경 안 씀

단점:
- 구현 복잡
- 어디에 저장? (서버 없음)
```

#### 옵션 B: 수동 백업
```
장점:
- 간단함
- 사용자 제어

단점:
- 깜빡임
- 귀찮음
```

### 결정
**Phase 1: 수동 (JSON) → Phase 3: 자동 (Supabase)**

### 이유
1. Phase 1은 LocalStorage만
2. 자동 백업 = 서버 필요
3. 수동이라도 있는 게 없는 것보다 나음
4. Phase 3에서 자동화

### 트레이드오프
- 초기에는 수동
- 하지만: 백업 기능 자체는 제공
- 점진적 개선

### 결과
✅ 수용. Phase 3 대기 중.

---

## Decision 10: TypeScript vs JavaScript (Phase 1)

**날짜**: 2026-01-27

### 상황
Phase 1 프로토타입 언어 선택.

### 고려한 옵션

#### 옵션 A: TypeScript
```
장점:
- 타입 안전성
- 에러 조기 발견
- 자동완성

단점:
- 빌드 필요
- 학습 곡선
- 시간 오래 걸림
```

#### 옵션 B: JavaScript
```
장점:
- 즉시 실행
- 간단함
- 빠른 검증

단점:
- 런타임 에러
- 자동완성 없음
- 리팩토링 어려움
```

### 결정
**Phase 1: JavaScript → Phase 2: TypeScript**

### 이유
1. 빠른 검증 우선
2. 비전공자 4일차
3. 타입은 나중에 추가 가능
4. 학습하며 전환

### 트레이드오프
- 런타임 에러 가능
- 하지만: 주석으로 타입 명시
- Phase 2에서 정식 전환

### 결과
✅ 성공. 빠르게 검증 완료. TypeScript 학습 중.

---

## 앞으로의 결정들

### Decision 11: 상태 관리 라이브러리 (Phase 2)
- Redux vs Zustand vs Context API
- → ROADMAP.md 참고

### Decision 12: 스타일링 (Phase 2)
- CSS Modules vs Styled-Components vs Tailwind
- → ROADMAP.md 참고

### Decision 13: 배포 플랫폼 (Phase 2)
- Vercel vs Netlify vs Cloudflare Pages
- → ROADMAP.md 참고

---

## 결정 템플릿

새로운 결정이 필요할 때 이 템플릿 사용:

```markdown
## Decision X: [제목]

**날짜**: YYYY-MM-DD

### 상황
[문제 설명]

### 고려한 옵션

#### 옵션 A: [이름]
장점:
- 
단점:
- 

#### 옵션 B: [이름]
장점:
- 
단점:
- 

### 결정
**[선택한 옵션]**

### 이유
1. 
2. 

### 트레이드오프
- 
- 

### 결과
✅/❌/⏳
```

---

**이 문서는 살아있습니다. 결정이 있을 때마다 추가됩니다.**

**마지막 업데이트: 2026-01-28**
