<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#667eea">
  <!-- 보안 헤더 -->
  <meta http-equiv="X-Content-Type-Options" content="nosniff">
  <meta http-equiv="X-Frame-Options" content="DENY">
  <meta name="referrer" content="strict-origin-when-cross-origin">
  <link rel="manifest" href="./manifest.json">
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect fill='%23667eea' width='100' height='100' rx='20'/%3E%3Ctext x='50' y='68' font-size='50' text-anchor='middle' fill='white'%3E⚡%3C/text%3E%3C/svg%3E">
  <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 180'%3E%3Crect fill='%23667eea' width='180' height='180' rx='36'/%3E%3Ctext x='90' y='122' font-size='90' text-anchor='middle' fill='white'%3E⚡%3C/text%3E%3C/svg%3E">
  <title>Navigator - 생존형 할일 관리</title>

  <!-- Pretendard 폰트 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/variable/pretendardvariable.min.css">

  <!-- Firebase SDK -->
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js';
    import { getAuth, signInWithPopup, signOut, GoogleAuthProvider, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js';
    import { initializeFirestore, persistentLocalCache, persistentSingleTabManager, doc, setDoc, getDoc, onSnapshot } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js';

    // Firebase 설정
    // ⚠️ 보안 참고: Firebase API 키는 클라이언트 측에서 사용되도록 설계되었습니다.
    // 실제 보안은 Firebase Console의 Firestore Security Rules에서 관리됩니다.
    // 권장 보안 규칙 (Firebase Console > Firestore > Rules):
    // rules_version = '2';
    // service cloud.firestore {
    //   match /databases/{database}/documents {
    //     match /users/{userId} {
    //       allow read, write: if request.auth != null && request.auth.uid == userId;
    //     }
    //   }
    // }
    const firebaseConfig = {
      apiKey: "AIzaSyDryb8MH0Mwkh1yP8yPCjdTbEvjr97mmmE",
      authDomain: "navigator-todo.firebaseapp.com",
      projectId: "navigator-todo",
      storageBucket: "navigator-todo.firebasestorage.app",
      messagingSenderId: "1020977741609",
      appId: "1:1020977741609:web:32ec5ad48329f80a3f0138"
    };

    // Firebase 초기화
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = initializeFirestore(app, {
      localCache: persistentLocalCache({
        tabManager: persistentSingleTabManager({ forceOwnership: true })
      })
    });
    const provider = new GoogleAuthProvider();

    // 전역 변수로 노출
    window.firebaseAuth = auth;
    window.firebaseDb = db;
    window.firebaseProvider = provider;
    window.firebaseSignIn = signInWithPopup;
    window.firebaseSignOut = signOut;
    window.firebaseDoc = doc;
    window.firebaseSetDoc = setDoc;
    window.firebaseGetDoc = getDoc;
    window.firebaseOnSnapshot = onSnapshot;
    window.firebaseOnAuthStateChanged = onAuthStateChanged;

    // Firebase 준비 완료 이벤트
    window.dispatchEvent(new Event('firebase-ready'));
  </script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    /* 다크 테마 (기본) - 부드러운 톤 */
    :root {
      /* 8pt 스페이싱 그리드 */
      --space-1: 8px;
      --space-2: 16px;
      --space-3: 24px;
      --space-4: 32px;
      --space-5: 40px;
      --space-6: 48px;

      /* 부드러운 다크 (#0a0a0a → #121218, 눈 피로 감소) */
      --bg-primary: #121218;
      --bg-secondary: #1a1a22;
      --bg-tertiary: #22222a;
      --bg-card: #1a1a22;
      --text-primary: #f5f5f5;
      --text-secondary: #a0a0a8;
      --text-muted: #8a8a92;
      --border-color: #2a2a32;
      --border-light: #22222a;

      /* 카테고리 색상 */
      --cat-본업: #667eea;
      --cat-부업: #f093fb;
      --cat-일상: #48bb78;
      --cat-가족: #f6ad55;

      /* 액센트 색상 */
      --accent-primary: #667eea;
      --accent-success: #48bb78;
      --accent-warning: #f6ad55;
      --accent-danger: #f5576c;

      /* 그림자 */
      --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.15);
      --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.2);
      --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.25);
      --shadow-color: rgba(0, 0, 0, 0.5);

      /* Radius */
      --radius-sm: 8px;
      --radius-md: 12px;
      --radius-lg: 16px;

      /* 트랜지션 */
      --transition-fast: 0.15s ease;
      --transition-normal: 0.25s ease;
    }

    /* 라이트 테마 */
    body[data-theme="light"] {
      --bg-primary: #f8f9fa;
      --bg-secondary: #ffffff;
      --bg-tertiary: #f1f3f4;
      --bg-card: #ffffff;
      --text-primary: #1a1a1a;
      --text-secondary: #5f6368;
      --text-muted: #72787e;
      --border-color: #e0e0e0;
      --border-light: #f1f3f4;
      --shadow-color: rgba(0, 0, 0, 0.08);
    }

    body {
      font-family: 'Pretendard Variable', 'Pretendard', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      overflow-x: hidden;
      transition: background 0.3s, color 0.3s;
      line-height: 1.6;
      letter-spacing: -0.02em;
      font-weight: 400;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    
    .app {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
      padding-bottom: 100px;
    }

    /* PC 레이아웃 (1024px 이상) */
    @media (min-width: 1024px) {
      .app {
        padding: 30px 40px;
      }

      .header h1 {
        font-size: 42px;
      }

      .pc-layout {
        display: grid;
        grid-template-columns: 1fr 1fr 380px;
        gap: 24px;
        align-items: start;
      }

      .pc-column-left {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      .pc-column-center {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      .pc-column-right {
        display: flex;
        flex-direction: column;
        gap: 20px;
        position: sticky;
        top: 80px;
      }

      /* 4번째 컬럼: 기본 숨김, 4K에서만 표시 */
      .pc-column-tasklist {
        display: none;
      }

      .shuttle-status {
        padding: 24px;
      }

      .next-action {
        padding: 35px;
      }

      .task-title {
        font-size: 32px;
      }

      .quick-add-input {
        padding: 18px;
        font-size: 17px;
      }

      .task-item {
        padding: 18px;
      }

      .task-item:hover {
        border-color: #667eea;
        transform: translateX(4px);
      }

      .stat-card {
        padding: 20px;
      }

      .stat-value {
        font-size: 32px;
      }

      .tab-nav {
        justify-content: center;
        gap: 15px;
      }

      .tab-btn {
        padding: 14px 28px;
        font-size: 15px;
      }
    }

    /* 대형 모니터 (1920px 이상) */
    @media (min-width: 1920px) {
      .app {
        max-width: 1800px;
        padding: 36px 60px;
      }

      body {
        font-size: 17px;
      }

      .header h1 {
        font-size: 48px;
      }

      .pc-layout {
        grid-template-columns: 1fr 1fr 420px;
        gap: 30px;
      }

      .next-action {
        padding: 40px;
      }

      .task-title {
        font-size: 36px;
      }

      .quick-add-input {
        padding: 20px;
        font-size: 18px;
      }

      .task-item {
        padding: 20px;
      }

      .stat-card {
        padding: 24px;
      }

      .stat-value {
        font-size: 36px;
      }

      .tab-btn {
        padding: 16px 32px;
        font-size: 16px;
      }

      .modal-content {
        max-width: 600px;
      }

      .form-input, .form-select {
        padding: 16px 18px;
        font-size: 16px;
      }

      .quick-template-btn,
      .quick-filter-btn {
        padding: 10px 18px;
        font-size: 14px;
      }

      .work-project-name {
        font-size: 18px;
      }

      .work-subcategory-title {
        font-size: 14px;
      }

      .event-card {
        font-size: 15px;
      }

      .revenue-card {
        padding: 20px;
      }

      .toast {
        font-size: 15px;
      }
    }

    /* 초대형 모니터 / 4K (2560px 이상) */
    @media (min-width: 2560px) {
      .app {
        max-width: 2400px;
        padding: 48px 80px;
      }

      body {
        font-size: 20px;
        line-height: 1.7;
      }

      .header h1 {
        font-size: 58px;
      }

      .pc-layout {
        grid-template-columns: 1fr 1fr 1fr;
        gap: 40px;
      }

      /* 4K 3열: 오늘의 나 | 할 일 | 집중 도구 */
      .pc-column-tasklist {
        display: none;
      }

      .next-action {
        padding: 48px;
        border-radius: 20px;
      }

      .task-title {
        font-size: 42px;
      }

      .quick-add-input {
        padding: 24px;
        font-size: 20px;
        border-radius: 14px;
      }

      .quick-add-simple .quick-add-btn {
        padding: 12px 20px;
        font-size: 22px;
      }

      .task-item {
        padding: 24px;
        border-radius: 14px;
        margin-bottom: 14px;
      }

      .stat-card {
        padding: 28px;
        border-radius: 16px;
      }

      .stat-value {
        font-size: 42px;
      }

      .stat-label {
        font-size: 15px;
      }

      .tab-nav {
        gap: 20px;
      }

      .tab-btn {
        padding: 18px 40px;
        font-size: 18px;
        border-radius: 14px;
      }

      .modal-content {
        max-width: 720px;
        border-radius: 24px;
        padding: 32px;
      }

      .form-label {
        font-size: 16px;
        margin-bottom: 10px;
      }

      .form-input, .form-select {
        padding: 18px 20px;
        font-size: 18px;
        border-radius: 12px;
      }

      .quick-template-btn,
      .quick-filter-btn {
        padding: 12px 22px;
        font-size: 16px;
        border-radius: 24px;
      }

      .section-header,
      .quick-filter-title {
        font-size: 16px;
      }

      .shuttle-status {
        padding: 28px;
        border-radius: 16px;
      }

      .task-item-mini {
        padding: 12px 16px;
        font-size: 16px;
      }

      .other-tasks-header {
        padding: 14px 16px;
        font-size: 16px;
      }

      .search-input {
        padding: 14px 18px;
        font-size: 16px;
      }

      /* 본업 프로젝트 카드 */
      .work-project-card {
        border-radius: 16px;
      }

      .work-project-card-header {
        padding: 20px 24px;
      }

      .work-project-name {
        font-size: 20px;
      }

      .work-subcategory {
        padding: 16px;
        border-radius: 12px;
      }

      .work-subcategory-title {
        font-size: 15px;
      }

      .work-task-item {
        padding: 12px 16px;
        font-size: 15px;
      }

      /* 이벤트 카드 */
      .event-card {
        padding: 14px 18px;
        border-radius: 12px;
        font-size: 16px;
      }

      /* 수익 카드 */
      .revenue-card {
        padding: 24px;
        border-radius: 16px;
      }

      /* 캘린더 */
      .calendar-day {
        border-radius: 12px;
        font-size: 16px;
      }

      /* 라이프 리듬 */
      .rhythm-btn {
        padding: 12px 20px;
        font-size: 15px;
        border-radius: 12px;
      }

      /* 토스트 알림 */
      .toast {
        padding: 16px 24px;
        font-size: 16px;
        border-radius: 14px;
      }
    }

    /* 4K 네이티브 (3200px 이상, 스케일링 100~125%) */
    @media (min-width: 3200px) {
      html {
        zoom: 1.4;
      }
    }

    /* 태블릿 레이아웃 (768px - 1023px) */
    @media (min-width: 768px) and (max-width: 1023px) {
      .app {
        max-width: 720px;
        padding: 25px;
      }

      .stats {
        grid-template-columns: repeat(3, 1fr);
      }

      .tablet-two-col {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
      }
    }

    /* 모바일 (767px 이하) - 기존 유지 */
    @media (max-width: 767px) {
      .app {
        max-width: 600px;
        padding: 15px;
      }

      .pc-layout {
        display: block;
      }

      .pc-column-left,
      .pc-column-center,
      .pc-column-right {
        display: contents;
      }
    }

    /* 탭 네비게이션 */
    .tab-nav {
      display: flex;
      gap: 6px;
      margin-bottom: 20px;
      background: var(--bg-secondary);
      padding: 8px;
      border-radius: var(--radius-md);
      overflow: visible; /* 드롭다운 메뉴가 잘리지 않도록 */
      position: sticky;
      top: 0;
      z-index: 100;
      box-shadow: 0 2px 12px var(--shadow-color);
      border: 1px solid var(--border-color);
    }

    .tab-nav::-webkit-scrollbar {
      display: none;
    }

    .tab-btn {
      padding: 10px 16px;
      background: transparent;
      border: none;
      color: var(--text-secondary);
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      border-radius: var(--radius-sm);
      transition: all var(--transition-fast);
      white-space: nowrap;
      letter-spacing: -0.01em;
    }

    .tab-btn:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    .tab-btn.active {
      background: #667eea;
      color: white;
      box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
    }

    /* 더보기 드롭다운 메뉴 */
    .tab-more-dropdown {
      position: relative;
      /* 드롭다운이 부모의 overflow에 의해 잘리지 않도록 */
      z-index: 150;
    }

    .more-menu {
      display: none;
      position: absolute;
      top: calc(100% + 4px);
      right: 0;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      min-width: 140px;
      overflow: visible;
    }

    .more-menu.show {
      display: block;
    }

    .more-menu-item {
      display: block;
      width: 100%;
      padding: 10px 16px;
      background: transparent;
      border: none;
      color: var(--text-secondary);
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      text-align: left;
      transition: all var(--transition-fast);
    }

    .more-menu-item:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    .more-menu-item.active {
      background: rgba(102, 126, 234, 0.1);
      color: #667eea;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }
    
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 25px;
    }

    .header-left {
      text-align: left;
    }

    .header h1 {
      font-size: 28px;
      margin-bottom: 6px;
      font-weight: 700;
      letter-spacing: -0.03em;
    }

    .header p {
      color: var(--text-secondary);
      font-size: 13px;
      font-weight: 500;
    }

    .theme-toggle {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      border: 1px solid var(--border-color);
      background: var(--bg-secondary);
      font-size: 20px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .theme-toggle:hover {
      background: var(--bg-tertiary);
      transform: scale(1.05);
    }
    
    .shuttle-status {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 20px;
      border-radius: 16px;
      margin-bottom: 20px;
      cursor: pointer;
      transition: transform 0.2s;
      user-select: none;
    }
    
    .shuttle-status:active {
      transform: scale(0.98);
    }
    
    .shuttle-status.failed {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    }
    
    .shuttle-icon {
      font-size: 48px;
      margin-bottom: 10px;
    }
    
    .shuttle-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 5px;
      letter-spacing: -0.01em;
    }

    .shuttle-desc {
      font-size: 13px;
      opacity: 0.9;
      font-weight: 400;
    }

    /* 현재 시간 & 남은 시간 표시 */
    .current-time-section {
      background: var(--bg-secondary);
      border-radius: 16px;
      padding: 16px 20px;
      margin-bottom: 20px;
      border: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .current-time-left {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .current-time-clock {
      font-size: 28px;
      font-weight: 700;
      font-family: 'Pretendard Variable', monospace;
      font-variant-numeric: tabular-nums;
      color: #fff;
      letter-spacing: -0.02em;
    }

    .current-time-mode {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .current-time-mode-label {
      font-size: 12px;
      color: var(--text-muted);
    }

    .current-time-mode-value {
      font-size: 14px;
      color: #667eea;
      font-weight: bold;
    }

    .current-time-mode-value.회사 { color: #667eea; }
    .current-time-mode-value.생존 { color: #f5576c; }
    .current-time-mode-value.여유 { color: #48bb78; }
    .current-time-mode-value.출근 { color: #f6ad55; }
    .current-time-mode-value.주말 { color: #f093fb; }
    .current-time-mode-value.휴식 { color: var(--text-secondary); }

    .current-time-right {
      text-align: right;
    }

    .time-remaining-label {
      font-size: 12px;
      color: var(--text-muted);
    }

    .time-remaining-value {
      font-size: 18px;
      font-weight: bold;
      color: #f093fb;
    }

    .time-remaining-value.urgent {
      color: #f5576c;
      animation: pulse 1s infinite;
    }
    
    .mode-indicator {
      background: var(--bg-secondary);
      padding: 12px;
      border-radius: 12px;
      text-align: center;
      margin-bottom: 20px;
      font-size: 14px;
      border: 1px solid var(--border-color);
    }
    
    .time-remaining {
      background: var(--bg-secondary);
      padding: 20px;
      border-radius: 12px;
      margin-bottom: 20px;
      text-align: center;
      border: 2px solid #333;
    }
    
    .time-remaining.panic {
      border-color: #f5576c;
      animation: pulse 1s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    .time-label {
      font-size: 14px;
      color: var(--text-secondary);
      margin-bottom: 10px;
    }
    
    .time-value {
      font-size: 36px;
      font-weight: bold;
      margin-bottom: 10px;
    }
    
    .time-warning {
      font-size: 14px;
      color: #f5576c;
      margin-top: 10px;
    }
    
    .stats {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
      margin-bottom: 20px;
    }

    @media (max-width: 500px) {
      .stats {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    
    .stat-card {
      background: var(--bg-secondary);
      padding: 12px 8px;
      border-radius: var(--radius-md);
      text-align: center;
      border: 1px solid var(--border-color);
      cursor: pointer;
      transition: all var(--transition-normal);
      box-shadow: 0 2px 8px var(--shadow-color);
    }

    .stat-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 16px var(--shadow-color);
      border-color: #667eea;
    }
    
    .stat-value {
      font-size: 22px;
      font-weight: 700;
      margin-bottom: 4px;
      letter-spacing: -0.02em;
    }

    .stat-label {
      font-size: 10px;
      color: var(--text-secondary);
      font-weight: 500;
      letter-spacing: 0;
      white-space: nowrap;
    }

    /* 데이터 인사이트 섹션 */
    .insights-section {
      background: var(--bg-secondary);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 20px;
      border: 1px solid var(--border-color);
    }

    .insights-title {
      font-size: 15px;
      font-weight: 600;
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .insight-card {
      background: var(--bg-primary);
      border-radius: 10px;
      padding: 14px;
      margin-bottom: 12px;
      border: 1px solid var(--border-color);
    }

    .insight-card:last-child {
      margin-bottom: 0;
    }

    .insight-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .insight-label {
      font-size: 13px;
      color: var(--text-secondary);
    }

    .insight-value {
      font-size: 15px;
      font-weight: 600;
      color: var(--accent-color);
    }

    .insight-bar-container {
      display: flex;
      align-items: flex-end;
      gap: 4px;
      height: 60px;
      margin-top: 8px;
    }

    .insight-bar {
      flex: 1;
      background: var(--accent-color);
      border-radius: 4px 4px 0 0;
      min-height: 4px;
      opacity: 0.7;
      transition: opacity 0.2s;
    }

    .insight-bar.peak {
      opacity: 1;
      background: linear-gradient(180deg, #667eea, #764ba2);
    }

    .insight-bar-labels {
      display: flex;
      gap: 4px;
      margin-top: 4px;
    }

    .insight-bar-label {
      flex: 1;
      text-align: center;
      font-size: 10px;
      color: var(--text-secondary);
    }

    /* 파이 차트 (CSS로 구현) */
    .pie-chart-container {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-top: 12px;
    }

    .pie-chart {
      width: 100px;
      height: 100px;
      border-radius: 50%;
      position: relative;
      flex-shrink: 0;
    }

    .pie-legend {
      flex: 1;
    }

    .pie-legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
      font-size: 13px;
    }

    .pie-legend-color {
      width: 12px;
      height: 12px;
      border-radius: 3px;
    }

    .pie-legend-color.본업 { background: var(--cat-본업); }
    .pie-legend-color.부업 { background: var(--cat-부업); }
    .pie-legend-color.일상 { background: var(--cat-일상); }
    .pie-legend-color.가족 { background: var(--cat-가족); }
    .pie-legend-color.기타 { background: var(--text-muted); }

    .pie-legend-value {
      margin-left: auto;
      color: var(--text-secondary);
      font-size: 12px;
    }

    /* ADHD 특화 기능 */
    .quick-timer-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 14px;
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      border: none;
      border-radius: 20px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    .quick-timer-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
    }

    .quick-timer-btn.running {
      background: linear-gradient(135deg, #f5576c, #f093fb);
      animation: pulse 1.5s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .quick-timer-display {
      font-family: 'SF Mono', 'Monaco', monospace;
      font-weight: bold;
    }

    /* 축하 효과 */
    .celebration-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 9999;
    }

    .confetti {
      position: absolute;
      width: 10px;
      height: 10px;
      animation: confetti-fall 3s ease-out forwards;
    }

    @keyframes confetti-fall {
      0% {
        opacity: 1;
        transform: translateY(0) rotate(0deg);
      }
      100% {
        opacity: 0;
        transform: translateY(100vh) rotate(720deg);
      }
    }

    .celebration-text {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      font-weight: bold;
      color: #ffd93d;
      text-shadow: 0 0 20px rgba(255, 217, 61, 0.5);
      animation: celebration-pop 0.5s ease-out;
      pointer-events: none;
      z-index: 10000;
    }

    @keyframes celebration-pop {
      0% {
        transform: translate(-50%, -50%) scale(0);
        opacity: 0;
      }
      50% {
        transform: translate(-50%, -50%) scale(1.2);
      }
      100% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
      }
    }

    /* 동기부여 메시지 */
    .motivation-toast {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      padding: 12px 24px;
      border-radius: 25px;
      font-size: 14px;
      font-weight: 500;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      animation: toast-in 0.3s ease-out;
      z-index: 1000;
    }

    @keyframes toast-in {
      from {
        opacity: 0;
        transform: translateX(-50%) translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
    }

    /* 작업 시작 버튼 강조 */
    .start-now-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      background: linear-gradient(135deg, #48bb78, #38a169);
      color: white;
      border: none;
      border-radius: 15px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .start-now-btn:hover {
      transform: scale(1.05);
    }

    /* 스트릭 불꽃 효과 */
    .streak-fire {
      display: inline-block;
      animation: fire-flicker 0.5s ease-in-out infinite alternate;
    }

    @keyframes fire-flicker {
      from { transform: scale(1); }
      to { transform: scale(1.1); }
    }

    /* 오프라인 표시기 */
    .offline-indicator {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(90deg, #f5576c, #f093fb);
      color: white;
      text-align: center;
      padding: 6px;
      font-size: 12px;
      font-weight: 500;
      z-index: 9999;
      animation: slideDown 0.3s ease-out;
    }

    @keyframes slideDown {
      from {
        transform: translateY(-100%);
      }
      to {
        transform: translateY(0);
      }
    }

    .offline-indicator.hidden {
      transform: translateY(-100%);
      transition: transform 0.3s ease-in;
    }

    /* 사용자 프로필 & 동기화 */
    .user-section {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      background: var(--bg-secondary);
      border-radius: 12px;
      margin-bottom: 16px;
      border: 1px solid var(--border-color);
    }

    .user-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      object-fit: cover;
      border: 2px solid #667eea;
    }

    .user-info {
      flex: 1;
      min-width: 0;
    }

    .user-name {
      font-weight: 600;
      font-size: 14px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      letter-spacing: -0.01em;
    }

    .user-email {
      font-size: 11px;
      color: var(--text-secondary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-weight: 400;
    }

    .sync-indicator {
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .login-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      width: 100%;
      padding: 14px;
      background: white;
      color: #333;
      border: 1px solid var(--border-color);
      border-radius: 12px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    .login-btn:hover {
      background: #f5f5f5;
      transform: translateY(-1px);
    }

    .login-btn img {
      width: 20px;
      height: 20px;
    }

    .logout-btn {
      padding: 6px 12px;
      background: transparent;
      color: var(--text-secondary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .logout-btn:hover {
      background: var(--bg-tertiary);
      color: #f5576c;
      border-color: #f5576c;
    }

    .sync-status {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      color: var(--text-secondary);
      margin-top: 4px;
    }

    .sync-status.syncing {
      color: #667eea;
    }

    .sync-status.synced {
      color: #48bb78;
    }

    .sync-status.error {
      color: #f5576c;
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .sync-status.syncing .sync-icon {
      animation: spin 1s linear infinite;
    }

    /* 백업 섹션 */
    .backup-section {
      background: var(--bg-secondary);
      padding: 15px;
      border-radius: 12px;
      margin-bottom: 20px;
      border: 1px solid var(--border-color);
    }

    .backup-title {
      font-size: 14px;
      color: var(--text-secondary);
      margin-bottom: 10px;
      text-transform: uppercase;
    }

    .backup-buttons {
      display: flex;
      gap: 10px;
    }

    .backup-btn {
      flex: 1;
      padding: 12px;
      background: var(--bg-tertiary);
      border: none;
      border-radius: 8px;
      color: white;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .backup-btn:hover {
      background: #3a3a3a;
    }

    .backup-btn.export {
      background: #667eea;
    }

    .backup-btn.import {
      background: #48bb78;
    }

    /* 대시보드 */
    .dashboard-section {
      background: var(--bg-secondary);
      padding: 20px;
      border-radius: 12px;
      margin-bottom: 20px;
      border: 1px solid var(--border-color);
    }

    .dashboard-title {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 10px;
      letter-spacing: -0.01em;
    }

    .category-stats {
      display: grid;
      gap: 15px;
      margin-bottom: 20px;
    }

    .category-stat {
      background: var(--bg-tertiary);
      padding: 15px;
      border-radius: 12px;
    }

    .category-stat-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .category-name {
      font-weight: bold;
      font-size: 16px;
    }

    .category-progress {
      font-size: 14px;
      color: var(--text-secondary);
    }

    .progress-bar {
      height: 8px;
      background: var(--bg-secondary);
      border-radius: 4px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      transition: width 0.3s;
    }

    .progress-fill.본업 { background: var(--cat-본업); }
    .progress-fill.부업 { background: var(--cat-부업); }
    .progress-fill.일상 { background: var(--cat-일상); }
    .progress-fill.가족 { background: var(--cat-가족); }

    /* 수익 대시보드 */
    .revenue-dashboard {
      background: linear-gradient(135deg, var(--bg-secondary) 0%, rgba(102, 126, 234, 0.1) 100%);
    }

    .dashboard-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .dashboard-header .dashboard-title {
      margin-bottom: 0;
    }

    .btn-export-asset {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 6px 12px;
      background: linear-gradient(135deg, var(--accent-primary) 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.15s, opacity 0.15s;
    }

    .btn-export-asset:hover {
      transform: translateY(-1px);
      opacity: 0.9;
    }

    .btn-export-asset:active {
      transform: translateY(0);
    }

    .revenue-summary {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-bottom: 20px;
    }

    .revenue-card {
      background: var(--bg-tertiary);
      padding: 16px;
      border-radius: 12px;
      text-align: center;
    }

    .revenue-card.total {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .revenue-card.month {
      border: 1px solid var(--border-color);
    }

    .revenue-card-label {
      font-size: 12px;
      color: var(--text-secondary);
      margin-bottom: 4px;
    }

    .revenue-card.total .revenue-card-label {
      color: rgba(255, 255, 255, 0.8);
    }

    .revenue-card-value {
      font-size: 20px;
      font-weight: 700;
      margin-bottom: 4px;
    }

    .revenue-card-sub {
      font-size: 11px;
      opacity: 0.8;
    }

    .revenue-chart-section {
      margin-bottom: 20px;
    }

    .revenue-chart-title {
      font-size: 13px;
      color: var(--text-secondary);
      margin-bottom: 12px;
    }

    .revenue-bar-chart {
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      height: 120px;
      gap: 8px;
      padding: 10px;
      background: var(--bg-tertiary);
      border-radius: 8px;
    }

    .revenue-bar-item {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      height: 100%;
    }

    .revenue-bar-wrapper {
      flex: 1;
      width: 100%;
      display: flex;
      align-items: flex-end;
      justify-content: center;
    }

    .revenue-bar {
      width: 100%;
      max-width: 40px;
      background: linear-gradient(180deg, #667eea 0%, #764ba2 100%);
      border-radius: 4px 4px 0 0;
      min-height: 5px;
      position: relative;
      transition: height 0.3s;
    }

    .revenue-bar-value {
      position: absolute;
      top: -18px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      color: var(--text-secondary);
      white-space: nowrap;
    }

    .revenue-bar-label {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 6px;
    }

    .revenue-category-section {
      margin-top: 16px;
    }

    .revenue-category-list {
      display: grid;
      gap: 12px;
    }

    .revenue-category-item {
      background: var(--bg-tertiary);
      padding: 12px;
      border-radius: 8px;
    }

    .revenue-category-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .revenue-category-amount {
      font-weight: 600;
      font-size: 14px;
    }

    .revenue-category-bar {
      height: 6px;
      background: var(--bg-secondary);
      border-radius: 3px;
      overflow: hidden;
      margin-bottom: 4px;
    }

    .revenue-category-bar-fill {
      height: 100%;
      transition: width 0.3s;
    }

    .revenue-category-bar-fill.본업 { background: var(--cat-본업); }
    .revenue-category-bar-fill.부업 { background: var(--cat-부업); }
    .revenue-category-bar-fill.일상 { background: var(--cat-일상); }
    .revenue-category-bar-fill.가족 { background: var(--cat-가족); }

    .revenue-category-percent {
      font-size: 11px;
      color: var(--text-muted);
      text-align: right;
    }

    /* 라이프 리듬 통계 */
    .life-rhythm-stats {
      background: linear-gradient(135deg, var(--bg-secondary) 0%, rgba(102, 126, 234, 0.05) 100%);
    }

    .rhythm-chart-section {
      margin-bottom: 20px;
    }

    .rhythm-chart-title {
      font-size: 13px;
      color: var(--text-secondary);
      margin-bottom: 12px;
    }

    .rhythm-bar-chart {
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      height: 120px;
      padding: 0 8px;
      gap: 8px;
    }

    .rhythm-bar-item {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      height: 100%;
    }

    .rhythm-bar-wrapper {
      flex: 1;
      width: 100%;
      display: flex;
      align-items: flex-end;
      justify-content: center;
    }

    .rhythm-bar {
      width: 100%;
      max-width: 32px;
      min-height: 4px;
      border-radius: 4px 4px 0 0;
      display: flex;
      align-items: flex-start;
      justify-content: center;
      transition: height 0.3s ease;
    }

    .rhythm-bar.good {
      background: linear-gradient(180deg, #48bb78, #38a169);
    }

    .rhythm-bar.ok {
      background: linear-gradient(180deg, #ecc94b, #d69e2e);
    }

    .rhythm-bar.bad {
      background: linear-gradient(180deg, #f56565, #e53e3e);
    }

    .rhythm-bar-value {
      font-size: 10px;
      color: white;
      font-weight: 600;
      margin-top: 4px;
      text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }

    .rhythm-bar-label {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 6px;
    }

    .rhythm-bar-label.today {
      color: var(--primary);
      font-weight: 600;
    }

    .rhythm-summary-row {
      display: flex;
      justify-content: space-between;
      font-size: 13px;
      color: var(--text-secondary);
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--border-color);
    }

    .rhythm-summary-row .good {
      color: var(--success);
    }

    .rhythm-summary-row .bad {
      color: var(--danger);
    }

    .rhythm-work-section {
      margin-bottom: 20px;
    }

    .rhythm-work-stats {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
    }

    .rhythm-work-stat {
      background: var(--bg-tertiary);
      padding: 12px 8px;
      border-radius: 8px;
      text-align: center;
    }

    .rhythm-work-label {
      display: block;
      font-size: 11px;
      color: var(--text-muted);
      margin-bottom: 4px;
    }

    .rhythm-work-value {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
      font-family: 'SF Mono', Monaco, monospace;
    }

    .rhythm-work-value.good {
      color: var(--success);
    }

    .rhythm-insights {
      background: var(--bg-tertiary);
      border-radius: 10px;
      padding: 12px;
    }

    .rhythm-insights .rhythm-chart-title {
      margin-bottom: 8px;
    }

    .rhythm-insight-item {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      padding: 8px 0;
      font-size: 13px;
      color: var(--text-secondary);
      border-bottom: 1px solid var(--border-light);
    }

    .rhythm-insight-item:last-child {
      border-bottom: none;
    }

    .rhythm-insight-item.positive {
      color: var(--text-primary);
    }

    .rhythm-insight-item.warning {
      color: var(--warning);
    }

    .rhythm-insight-icon {
      font-size: 14px;
    }

    @media (max-width: 480px) {
      .rhythm-work-stats {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    .urgent-list {
      display: grid;
      gap: 10px;
    }

    .urgent-item {
      background: var(--bg-tertiary);
      padding: 12px;
      border-radius: 8px;
      border-left: 4px solid #f5576c;
    }

    .urgent-item-title {
      font-weight: bold;
      margin-bottom: 5px;
    }

    .urgent-item-time {
      font-size: 12px;
      color: #f5576c;
    }
    
    /* 빠른 추가 (간소화 버전) */
    .quick-add-simple {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }

    .quick-add-simple .quick-add-input {
      flex: 1;
      border-radius: var(--radius-md);
    }

    .quick-add-simple .quick-add-btn {
      padding: 12px 18px;
      border-radius: var(--radius-md);
    }

    /* 빠른 템플릿 */
    .quick-templates {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }

    .quick-template-btn {
      padding: 8px 14px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 20px;
      color: var(--text-secondary);
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .quick-template-btn:hover {
      background: var(--bg-secondary);
      border-color: #667eea;
      color: #667eea;
    }

    .quick-template-btn.secondary {
      background: transparent;
      border-style: dashed;
      color: var(--text-tertiary);
    }

    .quick-template-btn.secondary:hover {
      background: var(--bg-tertiary);
      border-color: var(--text-secondary);
      color: var(--text-secondary);
    }

    /* 다른 작업 섹션 */
    .other-tasks-section {
      background: var(--bg-secondary);
      border-radius: var(--radius-md);
      border: 1px solid var(--border-color);
      overflow: hidden;
    }

    .other-tasks-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 14px 16px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      color: var(--text-secondary);
      transition: background var(--transition-fast);
    }

    .other-tasks-header:hover {
      background: var(--bg-tertiary);
    }

    .other-tasks-toggle {
      font-size: 12px;
    }

    .search-simple {
      padding: 12px 16px;
      border-top: 1px solid var(--border-color);
      position: relative;
    }

    .search-simple .search-input {
      width: 100%;
      padding: 10px 14px;
      border-radius: var(--radius-sm);
      font-size: 14px;
    }

    .search-simple .search-clear {
      position: absolute;
      right: 24px;
      top: 50%;
      transform: translateY(-50%);
    }

    /* 작업 목록 (내부) */
    .task-list-inner {
      padding: 8px 0;
    }

    .task-item-mini {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 16px;
      cursor: pointer;
      transition: background var(--transition-fast);
      border-bottom: 1px solid var(--border-light);
      border-left: 3px solid var(--task-cat-color, transparent);
    }

    .task-item-mini:last-child {
      border-bottom: none;
    }

    .task-item-mini:hover {
      background: var(--bg-tertiary);
    }

    .task-item-mini-left {
      display: flex;
      align-items: center;
      gap: 10px;
      flex: 1;
      min-width: 0;
    }

    .task-check-btn {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 2px solid var(--border-color);
      background: transparent;
      color: var(--text-muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      flex-shrink: 0;
      transition: all var(--transition-fast);
    }

    .task-check-btn:hover {
      border-color: #48bb78;
      color: #48bb78;
    }

    .task-item-mini-title {
      font-size: 14px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .task-item-mini-category {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 10px;
      flex-shrink: 0;
      font-weight: 500;
    }

    .task-item-mini-category.본업 { background: rgba(102, 126, 234, 0.2); color: #667eea; }
    .task-item-mini-category.부업 { background: rgba(240, 147, 251, 0.2); color: #f093fb; }
    .task-item-mini-category.일상 { background: rgba(72, 187, 120, 0.2); color: #48bb78; }
    .task-item-mini-category.가족 { background: rgba(246, 173, 85, 0.2); color: #f6ad55; }

    .task-list-more {
      text-align: center;
      padding: 10px;
      font-size: 13px;
      color: var(--text-muted);
    }

    /* 빠른 추가 (기존 버전 - 상세 옵션용) */
    .quick-add {
      background: var(--bg-secondary);
      padding: 16px;
      border-radius: var(--radius-lg);
      margin-bottom: 20px;
      border: 1px solid var(--border-color);
      box-shadow: 0 2px 12px var(--shadow-color);
    }

    .quick-add:focus-within {
      border-color: #667eea;
      box-shadow: 0 4px 20px rgba(102, 126, 234, 0.15);
    }
    
    .quick-add-header {
      font-size: 14px;
      color: var(--text-secondary);
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .quick-add-input-group {
      display: flex;
      gap: 10px;
    }
    
    .quick-add-input {
      flex: 1;
      padding: 14px 16px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 10px;
      color: var(--text-primary);
      font-size: 15px;
      font-family: inherit;
      font-weight: 400;
      line-height: 1.5;
    }

    .quick-add-input::placeholder {
      color: var(--text-muted);
      font-weight: 400;
    }
    
    .quick-add-input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.15);
    }
    
    .quick-add-btn {
      padding: 14px 22px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border: none;
      border-radius: 10px;
      color: white;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s;
      white-space: nowrap;
      letter-spacing: -0.01em;
    }
    
    .quick-add-btn:active {
      transform: scale(0.95);
    }
    
    .quick-add-toggle {
      margin-top: 10px;
      text-align: center;
      color: #667eea;
      font-size: 14px;
      cursor: pointer;
      user-select: none;
    }
    
    /* Next Action */
    .next-action {
      background: var(--bg-secondary);
      padding: 24px;
      border-radius: var(--radius-lg);
      margin-bottom: 20px;
      border: 1px solid var(--border-color);
      box-shadow: 0 4px 20px var(--shadow-color);
    }
    
    .next-action.panic {
      border-color: #f5576c;
      background: linear-gradient(135deg, #2a1a1a 0%, #1a1a1a 100%);
      animation: pulse-border 1s infinite;
    }
    
    @keyframes pulse-border {
      0%, 100% { border-color: #f5576c; }
      50% { border-color: #ff7a8a; }
    }
    
    .next-action.warning {
      border-color: #ff9500;
    }
    
    .next-action-label {
      font-size: 14px;
      color: var(--text-secondary);
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .next-action.panic .next-action-label {
      color: #f5576c;
    }
    
    .next-action.warning .next-action-label {
      color: #ff9500;
    }
    
    .task-title {
      font-size: 24px;
      margin-bottom: 18px;
      line-height: 1.4;
      font-weight: 600;
      letter-spacing: -0.02em;
      word-break: keep-all;
    }
    
    .task-meta {
      display: flex;
      gap: 10px;
      margin-bottom: 25px;
      flex-wrap: wrap;
    }
    
    .category {
      padding: 6px 14px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0;
    }
    
    .category.본업 { background: var(--cat-본업); }
    .category.부업 { background: var(--cat-부업); }
    .category.일상 { background: var(--cat-일상); }
    .category.가족 { background: var(--cat-가족); }
    
    .meta-item {
      background: var(--bg-tertiary);
      padding: 6px 12px;
      border-radius: 8px;
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 5px;
      font-weight: 500;
    }
    
    /* 버튼 시스템 - 통일된 스타일 */
    .btn {
      padding: var(--space-2) var(--space-3);
      border: none;
      border-radius: var(--radius-md);
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      width: 100%;
      margin-bottom: var(--space-2);
      transition: transform var(--transition-fast), opacity var(--transition-fast), box-shadow var(--transition-fast);
      user-select: none;
      letter-spacing: -0.01em;
    }

    .btn:active {
      transform: scale(0.98);
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--accent-primary) 0%, #764ba2 100%);
      color: white;
      box-shadow: var(--shadow-md);
    }

    .btn-primary:hover {
      box-shadow: var(--shadow-lg);
      transform: translateY(-1px);
    }

    .btn-success {
      background: var(--accent-success);
      color: white;
      box-shadow: var(--shadow-sm);
    }

    .btn-success:hover {
      filter: brightness(0.9);
    }

    .btn-warning {
      background: var(--accent-warning);
      color: white;
      box-shadow: var(--shadow-sm);
    }

    .btn-warning:hover {
      filter: brightness(0.9);
    }

    .btn-danger {
      background: var(--accent-danger);
      color: white;
      box-shadow: var(--shadow-sm);
    }

    .btn-danger:hover {
      filter: brightness(0.9);
    }

    .btn-secondary {
      background: var(--bg-tertiary);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
    }

    .btn-secondary:hover {
      background: var(--border-color);
    }
    
    /* 리스트 섹션 */
    .task-list-section {
      margin-bottom: 20px;
    }
    
    .task-list-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px;
      background: var(--bg-secondary);
      border-radius: 12px;
      margin-bottom: 10px;
      cursor: pointer;
      user-select: none;
      border: 1px solid var(--border-color);
    }
    
    .task-list-title {
      font-size: 15px;
      font-weight: 600;
      letter-spacing: -0.01em;
    }

    .task-list-count {
      font-size: 13px;
      color: var(--text-secondary);
      font-weight: 500;
    }
    
    .task-list {
      display: none;
    }
    
    .task-list.show {
      display: block;
    }
    
    .task-item {
      background: var(--bg-secondary);
      padding: 14px 16px;
      border-radius: var(--radius-md);
      margin-bottom: 10px;
      border: 1px solid var(--border-color);
      border-left: 4px solid var(--task-cat-color, var(--border-color));
      position: relative;
      overflow: hidden;
      transition: all var(--transition-normal);
      box-shadow: 0 1px 4px var(--shadow-color);
    }

    .task-item:hover {
      border-color: rgba(102, 126, 234, 0.5);
      box-shadow: 0 4px 16px var(--shadow-color);
      transform: translateY(-2px);
    }

    .task-item:active {
      transform: translateY(0);
    }

    .task-item.swiping-left {
      transform: translateX(-100px);
    }

    .task-item.swiping-right {
      transform: translateX(100px);
    }

    .task-item.completed {
      opacity: 0.6;
      background: linear-gradient(135deg, rgba(72, 187, 120, 0.05), rgba(56, 161, 105, 0.02));
      border-color: rgba(72, 187, 120, 0.3);
    }

    .task-item.completed:hover {
      opacity: 0.8;
    }

    /* 긴급도 레벨별 그라데이션 */
    .task-item.urgent {
      background: linear-gradient(135deg, rgba(245, 87, 108, 0.15), rgba(245, 87, 108, 0.05));
      border-color: #f5576c;
      border-width: 2px;
      box-shadow: 0 2px 12px rgba(245, 87, 108, 0.2);
    }

    .task-item.urgent::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 4px;
      background: linear-gradient(180deg, #f5576c, #ff8a9b);
    }

    .task-item.urgent:hover {
      box-shadow: 0 4px 20px rgba(245, 87, 108, 0.3);
      border-color: #ff6b7d;
    }

    .task-item.warning {
      background: linear-gradient(135deg, rgba(255, 149, 0, 0.12), rgba(255, 149, 0, 0.04));
      border-color: #ff9500;
      border-width: 2px;
      box-shadow: 0 2px 12px rgba(255, 149, 0, 0.15);
    }

    .task-item.warning::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 4px;
      background: linear-gradient(180deg, #ff9500, #ffb347);
    }

    .task-item.warning:hover {
      box-shadow: 0 4px 20px rgba(255, 149, 0, 0.25);
      border-color: #ffa726;
    }

    /* 일반 우선순위 표시 */
    .task-item.normal {
      background: var(--bg-secondary);
    }

    .task-item.normal::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 3px;
      background: linear-gradient(180deg, #667eea, #764ba2);
      opacity: 0.5;
    }

    .task-item.normal:hover::before {
      opacity: 1;
    }

    /* 드래그 앤 드롭 스타일 */
    .task-item[draggable="true"] {
      cursor: grab;
    }

    .task-item[draggable="true"]:active {
      cursor: grabbing;
    }

    /* 호버 시 빠른 액션 표시 */
    .task-item .task-quick-actions {
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      gap: 6px;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .task-item:hover .task-quick-actions {
      opacity: 1;
    }

    /* 호버 시 예상 시간 하이라이트 */
    .task-item:hover .meta-item {
      background: rgba(102, 126, 234, 0.1);
      border-radius: 4px;
      padding: 2px 6px;
      margin: -2px -6px;
    }

    .swipe-actions {
      position: absolute;
      top: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 20px;
      font-size: 14px;
      font-weight: bold;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .task-item.swiping-left .swipe-actions.left,
    .task-item.swiping-right .swipe-actions.right {
      opacity: 1;
    }
    
    .swipe-actions.left {
      left: 0;
      background: #48bb78;
    }
    
    .swipe-actions.right {
      right: 0;
      background: #f5576c;
    }
    
    .task-item-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 10px;
    }
    
    .task-item-title {
      font-weight: 600;
      font-size: 15px;
      flex: 1;
      margin-right: 10px;
      line-height: 1.4;
      word-break: keep-all;
      letter-spacing: -0.01em;
    }

    .task-item-title.completed {
      text-decoration: line-through;
      opacity: 0.6;
    }
    
    .task-item-meta {
      font-size: 12px;
      color: var(--text-secondary);
      margin-bottom: 10px;
    }
    
    .task-item-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    /* Task 카드 액션 간소화 - 기본적으로 숨김 */
    .task-item-actions .btn-small.edit,
    .task-item-actions .btn-small.delete,
    .task-item-actions .btn-small[title="내일로 미루기"],
    .task-item-actions .btn-small[title="이 작업에 포모도로 집중"],
    .task-item-actions .btn-small.copy {
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
    }

    /* 호버 시 모든 버튼 표시 */
    .task-item:hover .task-item-actions .btn-small.edit,
    .task-item:hover .task-item-actions .btn-small.delete,
    .task-item:hover .task-item-actions .btn-small[title="내일로 미루기"],
    .task-item:hover .task-item-actions .btn-small[title="이 작업에 포모도로 집중"],
    .task-item:hover .task-item-actions .btn-small.copy {
      opacity: 1;
      pointer-events: auto;
    }

    /* 모바일에서는 항상 표시 */
    @media (max-width: 768px) {
      .task-item-actions .btn-small.edit,
      .task-item-actions .btn-small.delete,
      .task-item-actions .btn-small[title="내일로 미루기"],
      .task-item-actions .btn-small[title="이 작업에 포모도로 집중"],
      .task-item-actions .btn-small.copy {
        opacity: 1;
        pointer-events: auto;
      }
    }

    /* 오늘 탭 전체 목록 - 컴팩트 한 줄 모드 */
    .task-list .task-item {
      padding: 8px 16px;
      margin-bottom: 2px;
    }
    .task-list .task-item .task-item-header {
      margin-bottom: 0;
    }
    .task-list .task-item .task-item-meta,
    .task-list .task-item .task-tags,
    .task-list .task-item .subtask-progress-bar,
    .task-list .task-item .subtask-preview,
    .task-list .task-item .subtask-list-expanded,
    .task-list .task-item .swipe-actions {
      display: none;
    }
    .task-list .task-item .task-item-actions {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s;
      flex-wrap: nowrap;
      gap: 4px;
      background: var(--bg-secondary);
      padding: 4px 8px;
      border-radius: 8px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.3);
      margin-bottom: 0;
    }
    .task-list .task-item:hover .task-item-actions {
      opacity: 1;
      pointer-events: auto;
    }
    .task-list .task-item .task-item-actions .btn-small {
      opacity: 1 !important;
      pointer-events: auto !important;
    }

    /* 인라인 카테고리 뱃지 (컴팩트 목록용) */
    .task-item-inline-cat {
      font-size: 11px;
      padding: 1px 6px;
      border-radius: 4px;
      margin-left: 6px;
      font-weight: 500;
      vertical-align: middle;
    }
    .task-item-inline-cat.본업 { background: rgba(102, 126, 234, 0.2); color: #667eea; }
    .task-item-inline-cat.부업 { background: rgba(240, 147, 251, 0.2); color: #f093fb; }
    .task-item-inline-cat.일상 { background: rgba(72, 187, 120, 0.2); color: #48bb78; }
    .task-item-inline-cat.가족 { background: rgba(246, 173, 85, 0.2); color: #f6ad55; }

    @media (max-width: 768px) {
      .task-list .task-item .task-item-actions {
        opacity: 1;
        pointer-events: auto;
        position: static;
        transform: none;
        background: none;
        box-shadow: none;
        padding: 0;
        margin-top: 6px;
      }
    }
    
    .btn-small {
      padding: var(--space-1) 14px;
      border: none;
      border-radius: var(--radius-sm);
      font-size: 13px;
      cursor: pointer;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      transition: transform var(--transition-fast), filter var(--transition-fast);
      font-weight: 500;
      letter-spacing: -0.01em;
      min-height: 44px;
      min-width: 44px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .btn-small:hover {
      filter: brightness(1.1);
    }

    .btn-small:active {
      transform: scale(0.95);
    }

    .btn-small.delete {
      background: var(--accent-danger);
      color: white;
    }

    .btn-small.go {
      background: var(--accent-primary);
      color: white;
    }

    .btn-small.complete {
      background: var(--accent-success);
      color: white;
    }

    .btn-small.uncomplete {
      background: var(--accent-warning);
      color: white;
    }

    .btn-small.edit {
      background: var(--accent-primary);
      color: white;
    }

    .btn-small.copy {
      background: var(--cat-부업);
      color: white;
    }

    .hidden-tasks {
      background: var(--bg-secondary);
      padding: 15px;
      border-radius: 12px;
      margin-bottom: 20px;
      text-align: center;
      color: var(--text-secondary);
      font-size: 14px;
      border: 1px solid var(--border-color);
    }
    
    .add-task-section {
      background: var(--bg-secondary);
      padding: 20px;
      border-radius: 12px;
      margin-bottom: 20px;
      border: 1px solid #667eea;
      border-width: 2px;
    }
    
    .add-task-section h3 {
      margin-bottom: 15px;
      font-size: 18px;
    }
    
    .form-group {
      margin-bottom: 15px;
    }
    
    .form-label {
      display: block;
      margin-bottom: 8px;
      font-size: 13px;
      color: var(--text-secondary);
      font-weight: 500;
    }
    
    .form-input, .form-select {
      width: 100%;
      padding: 14px 16px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 10px;
      color: var(--text-primary);
      font-size: 15px;
      font-family: inherit;
      font-weight: 400;
      line-height: 1.5;
    }
    
    .form-input:focus, .form-select:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.15);
    }

    /* textarea 스타일 */
    .form-textarea {
      resize: vertical;
      min-height: 60px;
      font-family: inherit;
    }

    /* 가로 배치 폼 행 */
    .form-row {
      display: flex;
      gap: 12px;
    }

    .form-group.half {
      flex: 1;
      min-width: 0;
    }

    /* datetime-local, time, date 입력 스타일 */
    .form-input[type="datetime-local"],
    .form-input[type="time"],
    .form-input[type="date"],
    .work-modal-input[type="datetime-local"],
    .work-modal-input[type="time"],
    .work-modal-input[type="date"] {
      color-scheme: dark;
      padding-right: 12px;
    }

    /* 달력 아이콘 가시성 개선 */
    .form-input::-webkit-calendar-picker-indicator,
    .work-modal-input::-webkit-calendar-picker-indicator {
      filter: invert(1) brightness(1.5);
      cursor: pointer;
      padding: 6px;
      opacity: 1;
      width: 24px;
      height: 24px;
      background-color: var(--primary);
      border-radius: 6px;
      transition: all 0.2s;
    }

    .form-input::-webkit-calendar-picker-indicator:hover,
    .work-modal-input::-webkit-calendar-picker-indicator:hover {
      opacity: 0.8;
      transform: scale(1.1);
    }

    [data-theme="light"] .form-input[type="datetime-local"],
    [data-theme="light"] .form-input[type="time"],
    [data-theme="light"] .form-input[type="date"],
    [data-theme="light"] .work-modal-input[type="datetime-local"],
    [data-theme="light"] .work-modal-input[type="time"],
    [data-theme="light"] .work-modal-input[type="date"] {
      color-scheme: light;
    }

    [data-theme="light"] .form-input::-webkit-calendar-picker-indicator,
    [data-theme="light"] .work-modal-input::-webkit-calendar-picker-indicator {
      filter: none;
      opacity: 0.9;
      background-color: rgba(102, 126, 234, 0.15);
    }

    .form-note {
      font-size: 12px;
      color: var(--text-secondary);
      margin-top: 5px;
    }

    /* 태그 스타일 */
    .tags-input-container {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .selected-tags, .available-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .tag {
      display: inline-flex;
      align-items: center;
      padding: 5px 11px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 20px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    .tag:hover {
      border-color: #667eea;
      background: rgba(102, 126, 234, 0.1);
    }

    .tag.selected {
      background: #667eea;
      border-color: #667eea;
      color: white;
    }

    .tag.selected:hover {
      background: #5a6fd6;
    }

    .new-tag-input {
      margin-top: 5px;
    }

    .tag-input {
      padding: 10px 14px !important;
      font-size: 14px !important;
    }

    /* 작업 아이템 내 태그 */
    .task-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-top: 6px;
    }

    .task-tag {
      display: inline-block;
      padding: 3px 8px;
      background: rgba(102, 126, 234, 0.15);
      border-radius: 10px;
      font-size: 10px;
      font-weight: 500;
      color: #8b9cf7;
    }

    /* 태그 필터 */
    .tag-filter-section {
      margin-top: 12px;
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .tag-filter-label {
      font-size: 12px;
      color: var(--text-muted);
    }

    .tag-filter-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .tag-filter-chip {
      padding: 4px 10px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      color: var(--text-secondary);
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .tag-filter-chip:hover {
      border-color: #667eea;
      color: #667eea;
    }

    .tag-filter-chip.active {
      background: #667eea;
      border-color: #667eea;
      color: white;
    }

    .clear-tag-filter {
      margin-left: 10px;
      padding: 2px 8px;
      background: transparent;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      color: var(--text-muted);
      font-size: 11px;
      cursor: pointer;
    }

    .clear-tag-filter:hover {
      border-color: #ff6b6b;
      color: #ff6b6b;
    }

    /* 반복 요일 선택 */
    .repeat-days {
      display: flex;
      gap: 8px;
      margin-top: 10px;
      flex-wrap: wrap;
    }

    .repeat-day-option {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 8px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }

    .repeat-day-option:hover {
      border-color: #667eea;
    }

    .repeat-day-option input[type="checkbox"] {
      display: none;
    }

    .repeat-day-option:has(input:checked) {
      background: #667eea;
      border-color: #667eea;
      color: white;
    }

    .repeat-monthly {
      margin-top: 10px;
    }

    .repeat-monthly .form-input {
      max-width: 120px;
    }

    /* 헤더 액션 버튼 */
    .header-actions {
      display: flex;
      gap: 8px;
    }

    .header-btn {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      border: 1px solid var(--border-color);
      background: var(--bg-secondary);
      font-size: 20px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .header-btn:hover {
      background: var(--bg-tertiary);
      transform: scale(1.05);
    }

    .header-btn.active {
      background: #667eea;
      border-color: #667eea;
    }

    /* 셔틀 토글 버튼 */
    .header-btn.shuttle-toggle {
      width: auto;
      padding: 0 12px;
      border-radius: 20px;
      font-size: 13px;
      font-weight: 600;
      gap: 4px;
    }

    .header-btn.shuttle-toggle.on {
      background: rgba(72, 187, 120, 0.2);
      border-color: #48bb78;
      color: #48bb78;
    }

    .header-btn.shuttle-toggle.off {
      background: rgba(245, 87, 108, 0.15);
      border-color: #f5576c;
      color: #f5576c;
    }

    /* 헤더 날짜 */
    .header-date {
      font-size: 12px;
      color: var(--text-secondary);
    }

    .header-streak {
      display: inline-block;
      background: linear-gradient(135deg, #f093fb, #f5576c);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      font-weight: bold;
      margin-left: 5px;
    }

    /* 스트릭 stat card */
    .stat-card.streak {
      background: linear-gradient(135deg, rgba(240, 147, 251, 0.1), rgba(245, 87, 108, 0.1));
      border-color: rgba(240, 147, 251, 0.3);
    }

    .stat-best {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 4px;
    }

    /* 모달 */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      padding: 20px;
    }

    .modal {
      background: var(--bg-secondary);
      border-radius: var(--radius-lg);
      max-width: 450px;
      width: 100%;
      border: 1px solid var(--border-color);
      animation: modalIn 0.3s ease;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    @keyframes modalIn {
      from {
        opacity: 0;
        transform: scale(0.9) translateY(20px);
      }
      to {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
    }

    .modal-header {
      padding: 24px 24px 0;
      text-align: center;
    }

    .modal-header h2 {
      font-size: 20px;
      margin: 0;
    }

    .modal-body {
      padding: 24px;
    }

    .modal-footer {
      padding: 0 24px 24px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    /* 브레인 덤프 */
    .brain-dump-textarea {
      width: 100%;
      min-height: 200px;
      padding: 14px;
      border: 1px solid var(--border-color);
      border-radius: var(--radius-sm);
      background: var(--bg-tertiary);
      color: var(--text-primary);
      font-family: inherit;
      font-size: 15px;
      line-height: 1.8;
      resize: vertical;
    }
    .brain-dump-textarea:focus {
      outline: none;
      border-color: var(--accent-primary);
    }
    .brain-dump-hint {
      font-size: 13px;
      color: var(--text-muted);
      margin-top: 8px;
      line-height: 1.5;
    }
    .brain-dump-count {
      font-size: 13px;
      color: var(--text-secondary);
      text-align: right;
      margin-top: 4px;
    }

    /* 온보딩 */
    .onboarding-feature {
      display: flex;
      gap: 15px;
      padding: 12px 0;
      border-bottom: 1px solid var(--border-light);
    }

    .onboarding-feature:last-child {
      border-bottom: none;
    }

    .onboarding-icon {
      font-size: 28px;
      flex-shrink: 0;
    }

    .onboarding-feature strong {
      display: block;
      margin-bottom: 4px;
    }

    .onboarding-feature p {
      font-size: 13px;
      color: var(--text-secondary);
      margin: 0;
    }

    /* 포커스 모드 */
    .focus-mode-container {
      background: linear-gradient(135deg, var(--bg-secondary), var(--bg-tertiary));
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 20px;
      border: 2px solid #667eea;
    }

    .focus-mode-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      font-weight: 600;
    }

    .focus-mode-hint {
      font-size: 12px;
      color: var(--text-muted);
      font-weight: normal;
    }

    .focus-task {
      background: var(--bg-secondary);
      border-radius: 12px;
      padding: 20px;
      border: 1px solid var(--border-color);
    }

    .focus-task-title {
      font-size: 24px;
      font-weight: 600;
      margin-bottom: 12px;
      line-height: 1.3;
    }

    .focus-task-meta {
      font-size: 14px;
      color: var(--text-secondary);
      margin-bottom: 16px;
    }

    .focus-subtasks {
      margin-bottom: 20px;
      padding: 12px;
      background: var(--bg-tertiary);
      border-radius: 8px;
    }

    .focus-subtask {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 0;
      cursor: pointer;
      border-bottom: 1px solid var(--border-light);
    }

    .focus-subtask:last-child {
      border-bottom: none;
    }

    .focus-subtask.completed {
      text-decoration: line-through;
      color: var(--text-muted);
    }

    .focus-subtask-check {
      font-size: 16px;
      color: #667eea;
    }

    .focus-actions {
      display: flex;
      gap: 12px;
    }

    .btn-large {
      padding: 16px 32px;
      font-size: 18px;
    }

    .focus-remaining {
      text-align: center;
      margin-top: 16px;
      font-size: 13px;
      color: var(--text-muted);
    }

    /* 서브태스크 스타일 */
    .subtasks-container {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .subtask-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      background: var(--bg-tertiary);
      border-radius: 8px;
      border: 1px solid var(--border-color);
    }

    .subtask-number {
      width: 22px;
      height: 22px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #667eea;
      color: white;
      border-radius: 50%;
      font-size: 12px;
      font-weight: bold;
      flex-shrink: 0;
    }

    .subtask-text {
      flex: 1;
      font-size: 14px;
    }

    .subtask-remove {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      color: var(--text-muted);
      font-size: 16px;
      cursor: pointer;
      border-radius: 4px;
    }

    .subtask-remove:hover {
      background: rgba(255, 107, 107, 0.2);
      color: #ff6b6b;
    }

    .subtask-input {
      padding: 10px 14px !important;
      font-size: 14px !important;
    }

    /* 작업 아이템 내 서브태스크 */
    .task-subtasks {
      margin-top: 8px;
      padding: 8px 10px;
      background: var(--bg-tertiary);
      border-radius: 6px;
    }

    .task-subtask {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 0;
      font-size: 13px;
    }

    .task-subtask-checkbox {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }

    .task-subtask.completed .task-subtask-text {
      text-decoration: line-through;
      color: var(--text-muted);
    }

    .task-subtask-text {
      flex: 1;
    }

    .subtask-progress {
      font-size: 11px;
      color: var(--text-secondary);
      margin-top: 4px;
    }

    /* 서브태스크 진행률 바 */
    .subtask-badge {
      display: inline-flex;
      align-items: center;
      gap: 2px;
      margin-left: 8px;
      padding: 2px 8px;
      font-size: 11px;
      font-weight: 500;
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.15), rgba(118, 75, 162, 0.15));
      color: var(--primary);
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .subtask-badge:hover {
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.25), rgba(118, 75, 162, 0.25));
      transform: scale(1.05);
    }

    .subtask-preview {
      margin-top: 4px;
      padding: 6px 10px;
      font-size: 12px;
      color: var(--text-secondary);
      background: rgba(102, 126, 234, 0.08);
      border-left: 3px solid var(--primary);
      border-radius: 0 6px 6px 0;
      cursor: pointer;
      transition: all 0.2s;
    }

    .subtask-preview:hover {
      background: rgba(102, 126, 234, 0.15);
      color: var(--text-primary);
    }

    .subtask-progress-bar {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 8px;
      padding: 8px 10px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .subtask-progress-bar:hover {
      background: var(--bg-secondary);
    }

    .subtask-progress-bar-fill-container {
      flex: 1;
      height: 6px;
      background: var(--border-color);
      border-radius: 3px;
      overflow: hidden;
    }

    .subtask-progress-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #48bb78, #38a169);
      border-radius: 3px;
      transition: width 0.3s ease;
    }

    .subtask-progress-bar-fill.complete {
      background: linear-gradient(90deg, #667eea, #764ba2);
    }

    .subtask-progress-bar-text {
      font-size: 12px;
      color: var(--text-secondary);
      white-space: nowrap;
    }

    .subtask-progress-toggle {
      font-size: 10px;
      color: var(--text-muted);
      transition: transform 0.2s;
    }

    .subtask-progress-toggle.expanded {
      transform: rotate(180deg);
    }

    /* 펼쳐진 서브태스크 목록 */
    .subtask-list-expanded {
      margin-top: 6px;
      padding: 8px 10px;
      background: var(--bg-tertiary);
      border-radius: 8px;
      border: 1px solid var(--border-color);
    }

    .subtask-list-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 0;
      border-bottom: 1px solid var(--border-light);
    }

    .subtask-list-item:last-child {
      border-bottom: none;
    }

    .subtask-list-item.completed .subtask-list-text {
      text-decoration: line-through;
      color: var(--text-muted);
    }

    .subtask-list-check {
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg-secondary);
      border: 2px solid var(--border-color);
      border-radius: 4px;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .subtask-list-check:hover {
      border-color: #667eea;
    }

    .subtask-list-item.completed .subtask-list-check {
      background: #48bb78;
      border-color: #48bb78;
      color: white;
    }

    .subtask-list-text {
      flex: 1;
      font-size: 13px;
    }

    /* 전체 완료 버튼 */
    .complete-all-subtasks-btn {
      margin-top: 8px;
      width: 100%;
      padding: 8px;
      background: linear-gradient(135deg, #48bb78, #38a169);
      border: none;
      border-radius: 6px;
      color: white;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: opacity 0.2s, transform 0.2s;
    }

    .complete-all-subtasks-btn:hover {
      opacity: 0.9;
      transform: translateY(-1px);
    }

    .complete-all-subtasks-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    /* 습관 트래커 (잔디 그리드) */
    .habit-tracker {
      padding: 16px;
      background: var(--bg-secondary);
      border-radius: 12px;
      border: 1px solid var(--border-color);
    }

    .habit-tracker-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .habit-grid {
      display: grid;
      grid-template-columns: 24px repeat(12, 1fr);
      gap: 3px;
      font-size: 11px;
      width: 100%;
      max-width: 100%;
      box-sizing: border-box;
    }

    .habit-day-label {
      color: var(--text-muted);
      font-size: 11px;
      text-align: right;
      padding-right: 6px;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      white-space: nowrap;
    }

    .habit-cell {
      aspect-ratio: 1;
      min-width: 14px;
      max-width: 28px;
      background: var(--bg-tertiary);
      border-radius: 3px;
      cursor: pointer;
      transition: transform 0.1s;
    }

    .habit-cell:hover {
      transform: scale(1.2);
    }

    .habit-cell.level-1 {
      background: rgba(72, 187, 120, 0.3);
    }

    .habit-cell.level-2 {
      background: rgba(72, 187, 120, 0.5);
    }

    .habit-cell.level-3 {
      background: rgba(72, 187, 120, 0.7);
    }

    .habit-cell.level-4 {
      background: #48bb78;
    }

    .habit-cell.today {
      outline: 2px solid #667eea;
      outline-offset: 1px;
    }

    .habit-legend {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 10px;
      font-size: 11px;
      color: var(--text-muted);
    }

    .habit-legend-item {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .habit-legend-cell {
      width: 10px;
      height: 10px;
      border-radius: 2px;
    }

    /* ========================================
       본업 프로젝트 관리
       ======================================== */
    .work-projects-container {
      padding: 16px;
    }

    /* 프로젝트 탭 네비게이션 */
    .work-project-selector {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
      padding: 12px;
      background: var(--bg-tertiary);
      border-radius: 8px;
    }

    .work-project-selector-label {
      font-size: 14px;
      font-weight: 500;
      color: var(--text-secondary);
      white-space: nowrap;
    }

    .work-project-select {
      flex: 1;
      padding: 10px 14px;
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      color: var(--text-primary);
      font-size: 14px;
      cursor: pointer;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23667eea' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 12px center;
      padding-right: 36px;
    }

    .work-project-select:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
    }

    .work-project-select optgroup {
      font-weight: 600;
      color: var(--text-secondary);
    }

    .work-project-select option {
      padding: 8px;
    }

    .work-project-tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      overflow-x: auto;
      padding-bottom: 8px;
    }

    .work-project-tab {
      padding: 10px 16px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      color: var(--text-secondary);
      font-size: 14px;
      cursor: pointer;
      white-space: nowrap;
      transition: all 0.2s;
    }

    .work-project-tab:hover {
      background: var(--bg-secondary);
      color: var(--text-primary);
    }

    .work-project-tab.active {
      background: linear-gradient(135deg, #667eea, #764ba2);
      border-color: transparent;
      color: white;
    }

    .work-project-tab-add {
      padding: 10px 16px;
      background: transparent;
      border: 1px dashed var(--border-color);
      border-radius: 8px;
      color: var(--text-muted);
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .work-project-tab-add:hover {
      border-color: #667eea;
      color: #667eea;
    }

    .work-projects-header {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 16px;
    }

    /* 프로젝트명 + 일정을 한 줄로 배치 */
    .work-project-info-row {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 0;
    }

    .work-projects-title {
      font-size: 18px;
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      min-width: 0;
      flex-shrink: 1;
    }

    .work-section-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .work-section-title.clickable {
      cursor: pointer;
      padding: 8px 12px;
      margin: -8px -12px 12px -12px;
      border-radius: 8px;
      transition: background 0.2s;
    }

    .work-section-title.clickable:hover {
      background: var(--bg-tertiary);
    }

    .work-section-toggle {
      font-size: 10px;
      color: var(--text-muted);
      width: 12px;
    }

    .work-project-add-btn {
      padding: 8px 16px;
      background: linear-gradient(135deg, #667eea, #764ba2);
      border: none;
      border-radius: 8px;
      color: white;
      font-size: 14px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .work-project-add-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }

    /* 본업 빠른 추가 */
    .work-quick-add {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      padding: 12px;
      background: var(--bg-secondary);
      border-radius: var(--radius-md);
      border: 1px solid var(--border-color);
    }

    .work-quick-input {
      flex: 1;
      padding: 10px 14px;
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-sm);
      color: var(--text-primary);
      font-size: 14px;
    }

    .work-quick-input::placeholder {
      color: var(--text-tertiary);
    }

    .work-quick-btn {
      width: 40px;
      height: 40px;
      background: #667eea;
      border: none;
      border-radius: var(--radius-sm);
      color: white;
      font-size: 20px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
    }

    .work-quick-btn:hover {
      transform: scale(1.05);
    }

    /* 본업 일반 작업 */
    .work-general-tasks {
      margin-bottom: 16px;
      padding: 12px;
      background: var(--bg-secondary);
      border-radius: var(--radius-md);
      border: 1px solid var(--border-color);
    }

    .work-general-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 10px;
    }

    .work-general-item-wrapper {
      border-bottom: 1px solid var(--border-light);
    }

    .work-general-item-wrapper:last-child {
      border-bottom: none;
    }

    .work-general-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 0;
    }

    .work-general-subtasks {
      padding: 8px 0 8px 32px;
      background: var(--bg-tertiary);
      border-radius: 6px;
      margin-bottom: 8px;
    }

    .work-general-subtask {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      font-size: 13px;
      cursor: pointer;
      border-radius: 4px;
      transition: background 0.2s;
    }

    .work-general-subtask:hover {
      background: var(--bg-secondary);
    }

    .work-general-subtask.completed {
      color: var(--text-muted);
      text-decoration: line-through;
    }

    .work-general-subtask .subtask-check {
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      font-size: 12px;
    }

    .work-general-subtask.completed .subtask-check {
      background: var(--success);
      border-color: var(--success);
      color: white;
    }

    .work-general-delete-btn {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      border-radius: 4px;
      color: var(--text-muted);
      font-size: 16px;
      cursor: pointer;
      opacity: 0;
      transition: all 0.2s;
    }

    .work-general-item:hover .work-general-delete-btn {
      opacity: 1;
    }

    .work-general-delete-btn:hover {
      background: rgba(245, 87, 108, 0.15);
      color: var(--danger);
    }

    .work-general-item-title {
      flex: 1;
      font-size: 14px;
      cursor: pointer;
    }

    .work-general-item-title:hover {
      color: #667eea;
    }

    .work-general-more {
      font-size: 12px;
      color: var(--text-tertiary);
      text-align: center;
      padding-top: 8px;
    }

    /* 일상/가족 탭 스타일 */
    .life-header {
      margin-bottom: 16px;
    }

    .life-title {
      font-size: 18px;
      font-weight: 600;
    }

    .life-quick-add {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      padding: 12px;
      background: var(--bg-secondary);
      border-radius: var(--radius-md);
      border: 1px solid var(--border-color);
    }

    .life-quick-input {
      flex: 1;
      padding: 10px 14px;
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-sm);
      color: var(--text-primary);
      font-size: 14px;
    }

    .life-quick-input::placeholder {
      color: var(--text-tertiary);
    }

    .life-quick-btn {
      width: 40px;
      height: 40px;
      background: #48bb78;
      border: none;
      border-radius: var(--radius-sm);
      color: white;
      font-size: 20px;
      font-weight: bold;
      cursor: pointer;
    }

    .life-summary {
      display: flex;
      gap: 12px;
      margin-bottom: 20px;
    }

    .life-summary-item {
      flex: 1;
      text-align: center;
      padding: 12px;
      background: var(--bg-secondary);
      border-radius: var(--radius-md);
      border: 1px solid var(--border-color);
    }

    .life-summary-value {
      font-size: 24px;
      font-weight: bold;
      color: var(--text-primary);
    }

    .life-summary-label {
      font-size: 12px;
      color: var(--text-secondary);
      margin-top: 4px;
    }

    .life-section {
      margin-bottom: 20px;
    }

    .life-section-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 10px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border-light);
    }

    .life-section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border-light);
    }

    .life-section-header .life-section-title {
      margin-bottom: 0;
      padding-bottom: 0;
      border-bottom: none;
    }

    .life-reset-btn {
      font-size: 12px;
      padding: 4px 10px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.2s;
    }

    .life-reset-btn:hover {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    .life-all-done {
      padding: 16px;
      text-align: center;
      color: var(--success);
      font-size: 13px;
      background: rgba(72, 187, 120, 0.1);
      border-radius: 8px;
    }

    .life-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .life-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: var(--bg-secondary);
      border-radius: var(--radius-md);
      border: 1px solid var(--border-color);
      border-left: 4px solid var(--task-cat-color, var(--border-color));
    }

    .life-item-content {
      flex: 1;
      cursor: pointer;
    }

    .life-item-title {
      font-size: 14px;
      color: var(--text-primary);
    }

    .life-item-meta {
      font-size: 12px;
      color: var(--text-tertiary);
      margin-top: 4px;
    }

    .life-item-actions {
      display: flex;
      gap: 4px;
      opacity: 0.5;
      transition: opacity 0.2s;
    }

    .life-item:hover .life-item-actions {
      opacity: 1;
    }

    .life-action-btn {
      width: 32px;
      height: 32px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-sm);
      cursor: pointer;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .life-action-btn:hover {
      background: var(--bg-secondary);
      transform: scale(1.05);
    }

    .life-action-btn.delete:hover {
      background: rgba(239, 68, 68, 0.2);
      border-color: #ef4444;
    }

    .life-empty {
      text-align: center;
      padding: 40px;
      color: var(--text-muted);
    }

    .life-empty-icon {
      font-size: 48px;
      margin-bottom: 12px;
    }

    .life-empty-text {
      font-size: 14px;
    }

    .work-project-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    /* 상태 뱃지 */
    .work-status-badge {
      padding: 3px 8px;
      border-radius: 10px;
      font-size: 11px;
      font-weight: 500;
    }

    .work-status-badge.not-started {
      background: rgba(160, 160, 160, 0.2);
      color: #a0a0a0;
    }

    .work-status-badge.in-progress {
      background: rgba(102, 126, 234, 0.2);
      color: #667eea;
    }

    .work-status-badge.completed {
      background: rgba(72, 187, 120, 0.2);
      color: #48bb78;
    }

    .work-status-badge.blocked {
      background: rgba(245, 87, 108, 0.2);
      color: #f5576c;
    }

    /* 중분류 스타일 */
    .work-subcategory {
      margin-top: 12px;
      padding: 12px;
      background: var(--bg-primary);
      border-radius: 8px;
      border: 1px solid var(--border-color);
    }

    .work-subcategory-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      cursor: pointer;
    }

    .work-subcategory-title {
      font-size: 13px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    /* 중분류 체크박스 */
    .work-subcategory-checkbox {
      width: 20px;
      height: 20px;
      border: 2px solid var(--border-color);
      border-radius: 5px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      transition: all 0.2s;
      flex-shrink: 0;
    }

    .work-subcategory-checkbox:hover {
      border-color: #667eea;
    }

    .work-subcategory-checkbox.checked {
      background: #48bb78;
      border-color: #48bb78;
      color: white;
    }

    .work-subcategory-name {
      cursor: pointer;
      padding: 2px 6px;
      border-radius: 4px;
      transition: background 0.2s;
    }

    .work-subcategory-name:hover {
      background: var(--bg-tertiary);
    }

    .work-subcategory-toggle {
      font-size: 10px;
      color: var(--text-muted);
    }

    .work-subcategory-actions {
      display: flex;
      gap: 6px;
    }

    /* 단계 체크박스 */
    .work-stage-checkbox {
      width: 22px;
      height: 22px;
      border: 2px solid var(--border-color);
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      transition: all 0.2s;
      flex-shrink: 0;
    }

    .work-stage-checkbox:hover {
      border-color: #667eea;
    }

    .work-stage-checkbox.checked {
      background: #48bb78;
      border-color: #48bb78;
      color: white;
    }

    /* 마감일 표시 */
    .work-deadline {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 10px;
      background: rgba(102, 126, 234, 0.15);
      color: #667eea;
      cursor: pointer;
    }

    .work-deadline.overdue {
      background: rgba(245, 87, 108, 0.15);
      color: #f5576c;
    }

    .work-deadline.soon {
      background: rgba(255, 149, 0, 0.15);
      color: #ff9500;
    }

    .work-deadline.none {
      background: var(--bg-tertiary);
      color: var(--text-muted);
      border: 1px dashed var(--border-color);
      flex-shrink: 0;
    }

    /* 프로젝트 대시보드 */
    .work-dashboard {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 16px;
      margin-bottom: 20px;
    }

    .work-dashboard-card {
      background: var(--bg-secondary);
      border-radius: 12px;
      padding: 16px;
      border: 1px solid var(--border-color);
    }

    .work-dashboard-card.active {
      border-color: #667eea;
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.05), rgba(118, 75, 162, 0.05));
    }

    .work-dashboard-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 12px;
    }

    .work-dashboard-name {
      font-size: 15px;
      font-weight: 600;
    }

    .work-dashboard-status {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 10px;
    }

    .work-dashboard-stages {
      display: flex;
      gap: 4px;
      margin-bottom: 12px;
    }

    .work-dashboard-stage-dot {
      width: 24px;
      height: 6px;
      border-radius: 3px;
      background: var(--bg-tertiary);
    }

    .work-dashboard-stage-dot.completed {
      background: #48bb78;
    }

    .work-dashboard-stage-dot.current {
      background: #667eea;
    }

    .work-dashboard-meta {
      display: flex;
      gap: 12px;
      font-size: 12px;
      color: var(--text-muted);
    }

    .work-dashboard-schedule {
      font-size: 12px;
      color: var(--text-secondary);
      margin-bottom: 8px;
    }

    .work-date-range {
      font-size: 13px;
      color: var(--text-secondary);
    }

    .work-schedule {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
    }

    /* 참여자 트래커 */
    .work-participant-tracker {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: var(--bg-tertiary);
      border-radius: 8px;
      margin-top: 12px;
    }

    .work-participant-label {
      font-size: 12px;
      color: var(--text-muted);
    }

    .work-participant-count {
      font-size: 14px;
      font-weight: 600;
      color: #667eea;
    }

    .work-participant-goal {
      font-size: 12px;
      color: var(--text-muted);
    }

    .work-participant-bar {
      flex: 1;
      height: 6px;
      background: var(--bg-secondary);
      border-radius: 3px;
      overflow: hidden;
    }

    .work-participant-fill {
      height: 100%;
      background: linear-gradient(90deg, #667eea, #48bb78);
      border-radius: 3px;
    }

    /* 아카이브 뱃지 */
    .work-archived-badge {
      font-size: 10px;
      padding: 2px 6px;
      background: rgba(160, 160, 160, 0.2);
      color: #a0a0a0;
      border-radius: 8px;
      margin-left: 8px;
    }

    /* 보류 뱃지 */
    .work-onhold-badge {
      font-size: 10px;
      padding: 2px 6px;
      background: rgba(245, 87, 108, 0.2);
      color: #f5576c;
      border-radius: 8px;
      margin-left: 8px;
    }

    /* 뷰 전환 탭 */
    .work-view-tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }

    .work-view-tab {
      padding: 8px 16px;
      background: var(--bg-tertiary);
      border: none;
      border-radius: 8px;
      color: var(--text-secondary);
      font-size: 13px;
      cursor: pointer;
    }

    .work-view-tab.active {
      background: #667eea;
      color: white;
    }

    .work-project-card {
      background: var(--bg-secondary);
      border-radius: 12px;
      border: 1px solid var(--border-color);
      overflow: hidden;
      transition: box-shadow 0.2s;
    }

    .work-project-card:hover {
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }

    .work-project-card.active {
      border-color: #667eea;
      box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.2);
    }

    .work-project-header {
      padding: 16px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .work-project-info {
      flex: 1;
    }

    .work-project-name {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .work-project-stage {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .work-project-stage-label {
      font-size: 12px;
      color: var(--text-muted);
    }

    .work-project-stage-name {
      font-size: 13px;
      font-weight: 500;
      color: #667eea;
      background: rgba(102, 126, 234, 0.15);
      padding: 4px 10px;
      border-radius: 12px;
    }

    .work-project-progress {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 8px;
    }

    .work-project-progress-bar {
      flex: 1;
      height: 6px;
      background: var(--bg-tertiary);
      border-radius: 3px;
      overflow: hidden;
    }

    .work-project-progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #667eea, #764ba2);
      border-radius: 3px;
      transition: width 0.3s;
    }

    .work-project-progress-text {
      font-size: 12px;
      color: var(--text-muted);
      white-space: nowrap;
    }

    .work-project-actions {
      display: flex;
      gap: 8px;
    }

    .work-project-action-btn {
      padding: 8px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      color: var(--text-primary);
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 4px;
      white-space: nowrap;
    }

    .work-project-action-btn:hover {
      background: var(--border-color);
    }

    .work-project-action-btn.delete:hover {
      background: rgba(245, 87, 108, 0.2);
      color: #f5576c;
    }

    /* 프로젝트 상세 (단계별 체크리스트) */
    .work-project-detail {
      border-top: 1px solid var(--border-color);
      padding: 16px;
      background: var(--bg-tertiary);
    }

    .work-stages {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .work-stage {
      background: var(--bg-secondary);
      border-radius: 10px;
      padding: 12px;
      border: 1px solid var(--border-color);
    }

    .work-stage.current {
      border-color: #667eea;
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.05), rgba(118, 75, 162, 0.05));
    }

    .work-stage.completed {
      opacity: 0.7;
    }

    .work-stage-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .work-stage-title {
      font-size: 14px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .work-stage-number {
      width: 24px;
      height: 24px;
      background: var(--bg-tertiary);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 600;
    }

    .work-stage.current .work-stage-number {
      background: #667eea;
      color: white;
    }

    .work-stage.completed .work-stage-number {
      background: #48bb78;
      color: white;
    }

    .work-stage-add-task {
      padding: 4px 10px;
      background: transparent;
      border: 1px dashed var(--border-color);
      border-radius: 6px;
      color: var(--text-muted);
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .work-stage-add-task:hover {
      border-color: #667eea;
      color: #667eea;
    }

    .work-task-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .work-task-item {
      background: var(--bg-primary);
      border-radius: 8px;
      padding: 10px 12px;
      border: 1px solid var(--border-color);
    }

    .work-task-header {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .work-task-checkbox {
      width: 18px;
      height: 18px;
      border-radius: 4px;
      border: 2px solid var(--border-color);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .work-task-checkbox:hover {
      border-color: #667eea;
    }

    .work-task-checkbox.checked {
      background: #48bb78;
      border-color: #48bb78;
      color: white;
    }

    .work-task-title {
      flex: 1;
      font-size: 14px;
      cursor: pointer;
      padding: 2px 6px;
      border-radius: 4px;
      transition: background 0.2s;
    }

    .work-task-title:hover {
      background: var(--bg-tertiary);
    }

    .work-task-title.completed {
      text-decoration: line-through;
      color: var(--text-muted);
    }

    .work-task-deadline {
      font-size: 11px;
      color: var(--text-muted);
      background: var(--bg-tertiary);
      padding: 2px 6px;
      border-radius: 4px;
      cursor: pointer;
      white-space: nowrap;
      flex-shrink: 0;
    }

    .work-task-deadline.soon {
      color: #e67e22;
      background: rgba(230, 126, 34, 0.1);
    }

    .work-task-deadline.overdue {
      color: var(--danger);
      background: rgba(245, 87, 108, 0.1);
    }

    .work-task-actions {
      display: flex;
      gap: 6px;
    }

    .work-task-action {
      padding: 6px 10px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      color: var(--text-secondary);
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
      min-height: 44px;
      min-width: 44px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .work-task-action:hover {
      background: var(--border-color);
      color: var(--text-primary);
    }

    /* 진행 로그 */
    .work-task-logs {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid var(--border-color);
    }

    .work-task-log {
      display: flex;
      gap: 10px;
      padding: 8px 0;
      font-size: 13px;
      border-bottom: 1px solid var(--border-color);
    }

    .work-task-log:last-child {
      border-bottom: none;
    }

    .work-task-log-date {
      color: #667eea;
      font-weight: 500;
      white-space: nowrap;
      min-width: 70px;
    }

    .work-task-log-content {
      flex: 1;
      color: var(--text-primary);
    }

    .work-task-log-actions {
      display: flex;
      gap: 4px;
    }

    .work-task-log-action {
      padding: 2px 6px;
      background: transparent;
      border: none;
      border-radius: 4px;
      color: var(--text-muted);
      min-height: 36px;
      min-width: 36px;
      font-size: 10px;
      cursor: pointer;
    }

    .work-task-log-action:hover {
      background: var(--bg-tertiary);
    }

    .work-log-add {
      display: flex;
      gap: 8px;
      margin-top: 8px;
    }

    .work-log-add input {
      flex: 1;
      padding: 8px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      color: var(--text-primary);
      font-size: 13px;
    }

    .work-log-add input:focus {
      outline: none;
      border-color: #667eea;
    }

    .work-log-add button {
      padding: 8px 14px;
      background: #667eea;
      border: none;
      border-radius: 6px;
      color: white;
      font-size: 13px;
      cursor: pointer;
    }

    /* 복사 버튼 */
    .work-copy-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 10px 16px;
      background: linear-gradient(135deg, #667eea, #764ba2);
      border: none;
      border-radius: 8px;
      color: white;
      font-size: 14px;
      cursor: pointer;
      margin-top: 16px;
      transition: transform 0.2s;
    }

    .work-copy-btn:hover {
      transform: translateY(-2px);
    }

    .work-copy-btn.copied {
      background: #48bb78;
    }

    /* 빈 상태 */
    .work-empty {
      text-align: center;
      padding: 40px 20px;
      color: var(--text-muted);
    }

    .work-empty-icon {
      font-size: 48px;
      margin-bottom: 16px;
    }

    .work-empty-title {
      font-size: 16px;
      font-weight: 500;
      margin-bottom: 8px;
      color: var(--text-primary);
    }

    .work-empty-desc {
      font-size: 14px;
      margin-bottom: 20px;
    }

    /* 프로젝트 추가 모달 */
    .work-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s;
    }

    .work-modal.show {
      opacity: 1;
      visibility: visible;
    }

    .work-modal-content {
      background: var(--bg-secondary);
      border-radius: 16px;
      padding: 24px;
      width: 90%;
      max-width: 400px;
      transform: scale(0.9);
      transition: transform 0.3s;
    }

    .work-modal.show .work-modal-content {
      transform: scale(1);
    }

    .work-modal-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 20px;
    }

    .work-modal-actions {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }

    .work-modal-actions button {
      flex: 1;
      padding: 12px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      cursor: pointer;
    }

    .work-modal-actions .cancel {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    .work-modal-actions .confirm {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
    }

    .work-modal-field {
      margin-bottom: 16px;
    }

    .work-modal-field-row {
      display: flex;
      gap: 12px;
      margin-bottom: 16px;
    }

    .work-modal-field.half {
      flex: 1;
      min-width: 0;
      margin-bottom: 0;
    }

    .work-modal-label {
      display: block;
      font-size: 13px;
      color: var(--text-secondary);
      margin-bottom: 8px;
    }

    .work-modal-input {
      width: 100%;
      padding: 12px 14px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      color: var(--text-primary);
      font-size: 14px;
    }

    .work-modal-input:focus {
      outline: none;
      border-color: #667eea;
    }

    .work-modal-textarea {
      width: 100%;
      padding: 12px 14px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      color: var(--text-primary);
      font-size: 14px;
      min-height: 80px;
      resize: vertical;
    }

    .work-modal-textarea:focus {
      outline: none;
      border-color: #667eea;
    }

    /* 상태 선택 버튼 그룹 */
    .work-status-group {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .work-status-option {
      padding: 8px 14px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 20px;
      color: var(--text-secondary);
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .work-status-option:hover {
      border-color: #667eea;
    }

    .work-status-option.selected {
      background: linear-gradient(135deg, #667eea, #764ba2);
      border-color: transparent;
      color: white;
    }

    .work-status-option.selected.in-progress {
      background: #667eea;
    }

    .work-status-option.selected.completed {
      background: #48bb78;
    }

    .work-status-option.selected.blocked {
      background: #f5576c;
    }

    /* 주간 리포트 */
    .weekly-report {
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
      border-radius: 12px;
      padding: 16px;
      border: 1px solid rgba(102, 126, 234, 0.2);
    }

    .weekly-report-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .weekly-report-title {
      font-size: 14px;
      font-weight: 600;
    }

    .weekly-report-period {
      font-size: 11px;
      color: var(--text-muted);
    }

    .weekly-report-stats {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
    }

    .weekly-stat {
      background: var(--bg-secondary);
      padding: 12px;
      border-radius: 8px;
      text-align: center;
    }

    .weekly-stat-value {
      font-size: 24px;
      font-weight: 700;
      color: #667eea;
    }

    .weekly-stat-value.positive {
      color: #48bb78;
    }

    .weekly-stat-value.negative {
      color: #f5576c;
    }

    .weekly-stat-label {
      font-size: 11px;
      color: var(--text-secondary);
      margin-top: 2px;
    }

    .weekly-stat-change {
      font-size: 10px;
      margin-top: 4px;
    }

    .weekly-stat-change.positive {
      color: #48bb78;
    }

    .weekly-stat-change.negative {
      color: #f5576c;
    }

    /* 주간 리뷰 모달 */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      padding: 20px;
    }

    .modal-content {
      background: var(--bg-secondary);
      border-radius: 20px;
      max-width: 500px;
      width: 100%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 24px;
      border-bottom: 1px solid var(--border-color);
    }

    .modal-header h2 {
      font-size: 20px;
      font-weight: 700;
    }

    .modal-close {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: none;
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      font-size: 18px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .modal-close:hover {
      background: var(--border-color);
      color: var(--text-primary);
    }

    .modal-body {
      padding: 24px;
    }

    .modal-footer {
      display: flex;
      gap: 12px;
      padding: 16px 24px;
      border-top: 1px solid var(--border-color);
      justify-content: flex-end;
    }

    /* 주간 리뷰 요약 */
    .review-summary {
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
      text-align: center;
    }

    .review-summary-value {
      font-size: 48px;
      font-weight: 700;
      color: #667eea;
    }

    .review-summary-label {
      font-size: 14px;
      color: var(--text-secondary);
      margin-top: 4px;
    }

    .review-summary-compare {
      font-size: 13px;
      margin-top: 8px;
    }

    .review-summary-compare.up {
      color: #48bb78;
    }

    .review-summary-compare.down {
      color: #f5576c;
    }

    /* 다음 주 계획 */
    .weekly-plan-section {
      margin-top: 20px;
    }

    .weekly-plan-title {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 12px;
    }

    .weekly-plan-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .weekly-plan-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: var(--bg-tertiary);
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s;
      border: 2px solid transparent;
    }

    .weekly-plan-item:hover {
      background: var(--bg-primary);
    }

    .weekly-plan-item.selected {
      border-color: #667eea;
      background: rgba(102, 126, 234, 0.1);
    }

    .weekly-plan-check {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: 2px solid var(--border-color);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      flex-shrink: 0;
    }

    .weekly-plan-item.selected .weekly-plan-check {
      background: #667eea;
      border-color: #667eea;
      color: white;
    }

    .weekly-plan-item-title {
      flex: 1;
      font-size: 14px;
    }

    .weekly-plan-item-category {
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 10px;
      background: rgba(102, 126, 234, 0.2);
      color: #667eea;
    }

    /* 월요일 리마인더 배너 */
    .monday-reminder {
      background: linear-gradient(135deg, #667eea, #764ba2);
      border-radius: 12px;
      padding: 16px 20px;
      margin-bottom: 16px;
      color: white;
    }

    .monday-reminder-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .monday-reminder-title {
      font-size: 14px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .monday-reminder-close {
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 14px;
    }

    .monday-reminder-tasks {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .monday-reminder-task {
      background: rgba(255, 255, 255, 0.15);
      padding: 10px 12px;
      border-radius: 8px;
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .monday-reminder-task-num {
      width: 20px;
      height: 20px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: bold;
    }

    /* 퀵 필터 섹션 */
    .quick-filter-section {
      margin: 16px 0;
      padding: 12px;
      background: var(--bg-secondary);
      border-radius: var(--radius-md);
      border: 1px solid var(--border-color);
    }

    .quick-filter-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
    }

    .quick-filter-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-secondary);
    }

    .quick-filter-help {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--bg-tertiary);
      color: var(--text-tertiary);
      font-size: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: help;
    }

    /* 퀵 필터 버튼들 */
    .quick-filters {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .quick-filter-btn {
      padding: 8px 14px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 20px;
      color: var(--text-secondary);
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .quick-filter-btn:hover {
      background: var(--bg-secondary);
      border-color: #667eea;
      color: var(--text-primary);
    }

    .quick-filter-btn.active {
      background: linear-gradient(135deg, #667eea, #764ba2);
      border-color: transparent;
      color: white;
    }

    .quick-filter-btn .filter-count {
      background: rgba(255, 255, 255, 0.2);
      padding: 2px 6px;
      border-radius: 10px;
      font-size: 11px;
      font-weight: 600;
    }

    .quick-filter-btn.active .filter-count {
      background: rgba(255, 255, 255, 0.3);
    }

    /* 미루기 횟수 뱃지 */
    .postpone-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 8px;
      background: rgba(255, 149, 0, 0.15);
      color: #ff9500;
      border-radius: 10px;
      font-size: 11px;
      font-weight: 600;
    }

    .postpone-badge.warning {
      background: rgba(245, 87, 108, 0.15);
      color: #f5576c;
    }

    /* 실제 소요시간 입력 모달 */
    .time-input-modal {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--bg-secondary);
      border-radius: 20px 20px 0 0;
      padding: 24px;
      box-shadow: 0 -10px 40px rgba(0, 0, 0, 0.3);
      z-index: 10001;
      transform: translateY(100%);
      transition: transform 0.3s ease;
    }

    .time-input-modal.show {
      transform: translateY(0);
    }

    .time-input-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .time-input-title {
      font-size: 18px;
      font-weight: 600;
    }

    .time-input-options {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      margin-bottom: 16px;
    }

    .time-option-btn {
      padding: 14px 10px;
      background: var(--bg-tertiary);
      border: 2px solid var(--border-color);
      border-radius: 12px;
      color: var(--text-primary);
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
    }

    .time-option-btn:hover {
      border-color: #667eea;
    }

    .time-option-btn.selected {
      background: linear-gradient(135deg, #667eea, #764ba2);
      border-color: transparent;
      color: white;
    }

    .time-input-custom {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .time-input-custom input {
      flex: 1;
      padding: 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 10px;
      color: var(--text-primary);
      font-size: 16px;
    }

    /* 라이프 리듬 트래커 */
    .life-rhythm-tracker {
      background: var(--bg-secondary);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
      border: 1px solid var(--border-color);
    }

    .life-rhythm-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .life-rhythm-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .life-rhythm-sleep {
      font-size: 12px;
      color: var(--text-secondary);
      background: rgba(102, 126, 234, 0.1);
      padding: 4px 10px;
      border-radius: 12px;
    }

    .life-rhythm-buttons {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
    }

    .life-rhythm-buttons.six-items {
      grid-template-columns: repeat(3, 1fr);
    }

    @media (min-width: 480px) {
      .life-rhythm-buttons.six-items {
        grid-template-columns: repeat(6, 1fr);
      }
    }

    .life-rhythm-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
      padding: 10px 4px;
      background: var(--bg-tertiary);
      border: 2px solid var(--border-color);
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s;
      color: var(--text-primary);
    }

    .life-rhythm-btn:hover {
      background: var(--bg-primary);
      border-color: var(--primary);
      color: var(--text-primary);
    }

    .life-rhythm-btn:active {
      transform: scale(0.95);
    }

    .life-rhythm-btn.recorded {
      background: linear-gradient(135deg, rgba(72, 187, 120, 0.1), rgba(56, 161, 105, 0.1));
      border-color: var(--success);
    }

    .life-rhythm-btn.recorded .life-rhythm-time {
      color: var(--success);
      font-weight: 600;
    }

    /* 리듬 기록 액션 메뉴 (수정/삭제) */
    .rhythm-action-menu {
      position: fixed;
      z-index: 1000;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
      overflow: hidden;
      min-width: 120px;
    }

    .rhythm-action-menu button {
      display: flex;
      align-items: center;
      gap: 8px;
      width: 100%;
      padding: 12px 16px;
      border: none;
      background: transparent;
      color: var(--text-primary);
      font-size: 14px;
      cursor: pointer;
      text-align: left;
    }

    .rhythm-action-menu button:hover {
      background: var(--bg-tertiary);
    }

    .rhythm-action-menu button:active {
      background: var(--bg-primary);
    }

    .rhythm-action-menu button.danger {
      color: var(--danger);
    }

    .rhythm-action-menu-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      z-index: 999;
    }

    .life-rhythm-icon {
      font-size: 18px;
    }

    .life-rhythm-label {
      font-size: 10px;
      color: var(--text-muted);
      white-space: nowrap;
    }

    .life-rhythm-time {
      font-size: 12px;
      font-weight: 500;
      color: var(--text-secondary);
      font-family: 'SF Mono', Monaco, monospace;
    }

    .life-rhythm-stats {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--border-color);
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .rhythm-stat {
      font-size: 12px;
      color: var(--text-secondary);
      background: var(--bg-tertiary);
      padding: 4px 10px;
      border-radius: 8px;
    }

    .rhythm-stat.total {
      background: rgba(102, 126, 234, 0.15);
      color: var(--primary);
      font-weight: 500;
    }

    .life-rhythm-summary {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--border-color);
      font-size: 13px;
      color: var(--text-secondary);
      text-align: center;
    }

    @media (max-width: 480px) {
      .life-rhythm-buttons {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    /* 복약/영양제 트래커 */
    .medication-tracker {
      background: var(--bg-secondary);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
      border: 1px solid var(--border-color);
    }

    .medication-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .medication-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .medication-progress {
      font-size: 12px;
      color: var(--text-secondary);
      background: rgba(102, 126, 234, 0.1);
      padding: 4px 10px;
      border-radius: 12px;
    }

    .medication-slots {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    .medication-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 10px 14px;
      background: var(--bg-tertiary);
      border: 2px solid var(--border-color);
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s;
      color: var(--text-primary);
    }

    .medication-btn:hover {
      background: var(--bg-primary);
      border-color: var(--primary);
    }

    .medication-btn:active {
      transform: scale(0.95);
    }

    .medication-btn.taken {
      background: linear-gradient(135deg, rgba(72, 187, 120, 0.1), rgba(56, 161, 105, 0.1));
      border-color: var(--success);
    }

    .medication-btn.taken .med-time {
      color: var(--success);
      font-weight: 600;
    }

    .medication-btn .med-icon {
      font-size: 18px;
    }

    .medication-btn .med-label {
      font-size: 12px;
      color: var(--text-secondary);
      flex: 1;
      min-width: 0;
    }

    .medication-btn .med-time {
      font-size: 12px;
      font-weight: 500;
      color: var(--text-muted);
      font-family: 'SF Mono', Monaco, monospace;
      margin-left: auto;
      flex-shrink: 0;
    }

    .medication-streak {
      margin-top: 10px;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .medication-streak .streak-good {
      color: var(--success);
      font-weight: 600;
    }

    .medication-btn.required {
      border-left: 3px solid var(--primary);
    }

    .medication-btn.required.taken {
      border-left-color: var(--success);
    }

    /* 히스토리 복약 행 */
    .rhythm-history-meds {
      display: flex;
      gap: 6px;
      padding: 4px 0;
      flex-wrap: wrap;
    }

    .rhythm-history-med {
      font-size: 12px;
      cursor: pointer;
      padding: 2px 6px;
      border-radius: 6px;
      transition: background 0.2s;
    }

    .rhythm-history-med:hover {
      background: var(--bg-tertiary);
    }

    .rhythm-history-med.taken {
      color: var(--success);
    }

    .rhythm-history-med.missed {
      color: var(--text-muted);
      opacity: 0.6;
    }

    /* 오늘의 명언 */
    .daily-quote {
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.08), rgba(118, 75, 162, 0.08));
      border-radius: 12px;
      padding: 16px 20px;
      margin-bottom: 16px;
      border-left: 4px solid #667eea;
    }

    .daily-quote-text {
      font-size: 14px;
      color: var(--text-primary);
      font-style: italic;
      line-height: 1.5;
      margin-bottom: 8px;
    }

    .daily-quote-author {
      font-size: 12px;
      color: var(--text-muted);
      text-align: right;
    }

    /* 기능 투어 */
    .tour-overlay {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.7); z-index: 10000;
    }
    .tour-tooltip {
      position: fixed; z-index: 10001;
      background: var(--bg-card); color: var(--text-primary);
      border-radius: 12px; padding: 20px; max-width: 320px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      animation: fadeIn 0.3s ease;
    }
    .tour-tooltip h4 { margin: 0 0 8px; font-size: 16px; }
    .tour-tooltip p { margin: 0 0 16px; font-size: 14px; color: var(--text-secondary); line-height: 1.5; }
    .tour-tooltip .tour-actions { display: flex; gap: 8px; justify-content: space-between; }
    .tour-tooltip .tour-step { font-size: 12px; color: var(--text-muted); }
    .tour-highlight {
      position: relative; z-index: 10001;
      box-shadow: 0 0 0 4px var(--primary), 0 0 0 8px rgba(102, 126, 234, 0.3);
      border-radius: 8px;
    }

    /* 빈 상태 개선 */
    .empty-state-enhanced {
      text-align: center;
      padding: 50px 30px;
      background: linear-gradient(135deg, rgba(72, 187, 120, 0.1), rgba(56, 161, 105, 0.05));
      border-radius: 20px;
      border: 2px dashed rgba(72, 187, 120, 0.3);
    }

    .empty-state-icon-large {
      font-size: 80px;
      margin-bottom: 20px;
      animation: float 3s ease-in-out infinite;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    .empty-state-title {
      font-size: 24px;
      font-weight: 700;
      color: #48bb78;
      margin-bottom: 10px;
    }

    .empty-state-subtitle {
      font-size: 14px;
      color: var(--text-secondary);
      margin-bottom: 20px;
      line-height: 1.6;
    }

    .empty-state-actions {
      display: flex;
      gap: 12px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .empty-state-btn {
      padding: 12px 20px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 10px;
      color: var(--text-primary);
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .empty-state-btn:hover {
      border-color: #667eea;
      transform: translateY(-2px);
    }

    .empty-state-btn.primary {
      background: linear-gradient(135deg, #48bb78, #38a169);
      border: none;
      color: white;
    }

    .empty-state {
      text-align: center;
      padding: 40px 20px;
      color: var(--text-secondary);
    }
    
    .empty-state-icon {
      font-size: 48px;
      margin-bottom: 15px;
    }

    /* 완료 애니메이션 오버레이 */
    .completion-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.85);
      z-index: 2000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
    }

    .completion-overlay.show {
      opacity: 1;
      pointer-events: auto;
    }

    .completion-content {
      text-align: center;
      transform: scale(0.5);
      transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    .completion-overlay.show .completion-content {
      transform: scale(1);
    }

    .completion-check {
      width: 100px;
      height: 100px;
      border-radius: 50%;
      background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 20px;
      font-size: 50px;
      box-shadow: 0 0 60px rgba(72, 187, 120, 0.6);
      animation: checkPop 0.5s ease-out;
    }

    @keyframes checkPop {
      0% { transform: scale(0) rotate(-180deg); }
      50% { transform: scale(1.2) rotate(10deg); }
      100% { transform: scale(1) rotate(0deg); }
    }

    .completion-text {
      font-size: 28px;
      font-weight: bold;
      margin-bottom: 8px;
    }

    .completion-streak {
      font-size: 20px;
      color: #f6ad55;
      margin-bottom: 10px;
    }

    .completion-task-title {
      font-size: 15px;
      color: #888;
      max-width: 280px;
      margin: 0 auto;
    }

    /* Confetti 효과 */
    .confetti-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10000;
      overflow: hidden;
    }

    .confetti {
      position: absolute;
      width: 10px;
      height: 10px;
      opacity: 0;
      animation: confetti-fall 3s ease-out forwards;
    }

    .confetti.circle { border-radius: 50%; }
    .confetti.square { border-radius: 2px; }
    .confetti.triangle {
      width: 0;
      height: 0;
      border-left: 5px solid transparent;
      border-right: 5px solid transparent;
      border-bottom: 10px solid currentColor;
      background: transparent !important;
    }

    @keyframes confetti-fall {
      0% {
        opacity: 1;
        transform: translateY(-10vh) rotate(0deg);
      }
      100% {
        opacity: 0;
        transform: translateY(100vh) rotate(720deg);
      }
    }

    /* 체크 애니메이션 */
    @keyframes check-pop {
      0% { transform: scale(0); }
      50% { transform: scale(1.3); }
      70% { transform: scale(0.9); }
      100% { transform: scale(1); }
    }

    @keyframes check-ripple {
      0% {
        box-shadow: 0 0 0 0 rgba(72, 187, 120, 0.4);
      }
      100% {
        box-shadow: 0 0 0 15px rgba(72, 187, 120, 0);
      }
    }

    .subtask-list-check.just-checked {
      animation: check-pop 0.4s ease-out, check-ripple 0.6s ease-out;
    }

    .task-check-btn.just-checked {
      animation: check-pop 0.3s ease-out;
    }

    /* 스트릭 불꽃 애니메이션 */
    @keyframes fire-glow {
      0%, 100% {
        text-shadow: 0 0 10px #f6ad55, 0 0 20px #f6ad55, 0 0 30px #ed8936;
        transform: scale(1);
      }
      50% {
        text-shadow: 0 0 20px #f6ad55, 0 0 40px #f6ad55, 0 0 60px #ed8936;
        transform: scale(1.1);
      }
    }

    .streak-fire-animate {
      animation: fire-glow 0.8s ease-in-out;
    }

    /* 드래그 효과 개선 */
    .task-item.dragging {
      opacity: 0.9;
      transform: scale(1.02) rotate(1deg);
      box-shadow: 0 10px 40px rgba(102, 126, 234, 0.3);
      z-index: 1000;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .task-item.drag-over {
      border-color: #667eea;
      background: rgba(102, 126, 234, 0.1);
    }

    /* 완료 시 슬라이드 아웃 */
    @keyframes slide-out-complete {
      0% {
        opacity: 1;
        transform: translateX(0);
      }
      100% {
        opacity: 0;
        transform: translateX(100%);
      }
    }

    .task-item.completing {
      animation: slide-out-complete 0.4s ease-out forwards;
    }

    /* 성취 뱃지 팝업 */
    .achievement-popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0);
      background: linear-gradient(135deg, #667eea, #764ba2);
      padding: 30px 40px;
      border-radius: 20px;
      text-align: center;
      z-index: 10001;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      animation: achievement-pop 0.5s ease-out forwards;
    }

    @keyframes achievement-pop {
      0% { transform: translate(-50%, -50%) scale(0); }
      60% { transform: translate(-50%, -50%) scale(1.1); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }

    .achievement-popup .achievement-icon {
      font-size: 60px;
      margin-bottom: 15px;
    }

    .achievement-popup .achievement-title {
      font-size: 24px;
      font-weight: bold;
      color: white;
      margin-bottom: 8px;
    }

    .achievement-popup .achievement-desc {
      font-size: 14px;
      color: rgba(255, 255, 255, 0.8);
    }

    /* 오늘의 진행률 */
    .today-progress {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 20px;
      border: 1px solid var(--border-color);
    }

    .today-progress-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .today-progress-title {
      font-size: 15px;
      color: var(--text-secondary);
    }

    .today-progress-score {
      font-size: 28px;
      font-weight: bold;
      background: linear-gradient(135deg, #667eea, #48bb78);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .progress-bar-large {
      height: 10px;
      background: #2a2a3a;
      border-radius: 5px;
      overflow: hidden;
      margin-bottom: 15px;
    }

    .progress-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #667eea 0%, #48bb78 100%);
      border-radius: 5px;
      transition: width 0.5s ease-out;
    }

    .today-stats-row {
      display: flex;
      justify-content: space-around;
      text-align: center;
      padding-top: 12px;
      border-top: 1px solid #2a2a3a;
    }

    .today-stat {
      flex: 1;
    }

    .today-stat-value {
      font-size: 20px;
      font-weight: bold;
    }

    .today-stat-value.completed { color: #48bb78; }
    .today-stat-value.remaining { color: #f093fb; }
    .today-stat-value.streak { color: #f6ad55; }

    .today-stat-label {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 2px;
    }

    /* 토스트 알림 */
    .toast {
      position: fixed;
      bottom: 90px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--bg-tertiary);
      color: white;
      padding: 14px 24px;
      border-radius: var(--radius-md);
      box-shadow: 0 4px 20px rgba(0,0,0,0.4);
      z-index: 1000;
      animation: slideUp 0.3s ease-out;
      font-size: 14px;
      font-weight: 500;
      max-width: 90%;
    }

    @keyframes slideUp {
      from {
        transform: translateX(-50%) translateY(100px);
        opacity: 0;
      }
      to {
        transform: translateX(-50%) translateY(0);
        opacity: 1;
      }
    }

    /* 실행취소 토스트 */
    .toast-undo {
      position: fixed;
      bottom: 90px;
      left: 50%;
      transform: translateX(-50%);
      background: #1a1a2e;
      border: 1px solid var(--accent-green);
      color: white;
      padding: 12px 16px;
      border-radius: var(--radius-md);
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
      z-index: 1001;
      animation: slideUp 0.3s ease-out;
      display: flex;
      align-items: center;
      gap: 12px;
      max-width: 90%;
    }

    .toast-undo-text {
      font-size: 14px;
      color: var(--accent-green);
      font-weight: 500;
    }

    .toast-undo-btn {
      background: var(--accent-blue);
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: var(--radius-sm);
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .toast-undo-btn:hover {
      background: #5a6fd6;
      transform: scale(1.05);
    }

    .toast-undo-timer {
      font-size: 12px;
      color: var(--text-tertiary);
      min-width: 16px;
      text-align: center;
    }

    .toast.success {
      background: #48bb78;
    }

    .toast.error {
      background: #f5576c;
    }

    /* 히든 파일 인풋 */
    .hidden-input {
      display: none;
    }

    /* 알림 설정 섹션 */
    .notification-section {
      background: var(--bg-secondary);
      padding: 15px;
      border-radius: 12px;
      margin-bottom: 20px;
      border: 1px solid var(--border-color);
    }

    .notification-title {
      font-size: 14px;
      color: var(--text-secondary);
      margin-bottom: 10px;
      text-transform: uppercase;
    }

    .notification-status {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .notification-text {
      font-size: 14px;
      color: #ccc;
    }

    .notification-text.granted {
      color: #48bb78;
    }

    .notification-text.denied {
      color: #f5576c;
    }

    .notification-btn {
      padding: 10px 16px;
      background: #667eea;
      border: none;
      border-radius: 8px;
      color: white;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .notification-btn:hover {
      background: #5a6fd6;
    }

    .notification-btn:disabled {
      background: #444;
      cursor: not-allowed;
    }

    .notification-btn.granted {
      background: #48bb78;
    }

    .notification-btn.denied {
      background: #f5576c;
      cursor: pointer;
    }

    .notification-btn.denied:hover {
      background: #e04460;
    }

    .notification-help {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.5);
      margin-top: 8px;
      padding: 8px 12px;
      background: rgba(245, 87, 108, 0.1);
      border-radius: 6px;
    }

    /* 마감 알림 드롭다운 (헤더) */
    .notification-dropdown-wrapper {
      position: relative;
      display: inline-flex;
    }
    .notification-dropdown {
      display: none;
      position: absolute;
      top: 100%;
      right: 0;
      margin-top: 8px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      padding: 16px;
      min-width: 240px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.3);
      z-index: 1000;
    }
    .notification-dropdown.show {
      display: block;
    }
    .notification-dropdown .notification-title {
      margin-bottom: 10px;
    }
    .header-btn .notif-dot {
      position: absolute;
      bottom: 2px;
      right: 2px;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      border: 1px solid var(--bg-primary);
    }

    /* 검색 & 필터 스타일 */
    .search-filter-section {
      background: var(--bg-secondary);
      padding: 15px;
      border-radius: 12px;
      margin-bottom: 20px;
      border: 1px solid var(--border-color);
    }

    .search-input-wrapper {
      position: relative;
      margin-bottom: 12px;
    }

    .search-input {
      width: 100%;
      padding: 12px 40px 12px 16px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      color: white;
      font-size: 15px;
    }

    .search-input:focus {
      outline: none;
      border-color: #667eea;
    }

    .search-icon {
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--text-muted);
    }

    .search-clear {
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      background: #666;
      border: none;
      color: white;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* 키보드 단축키 도움말 */
    .shortcuts-help {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      padding: 15px;
      z-index: 100;
      display: none;
      max-width: 280px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    }

    .shortcuts-help.show {
      display: block;
    }

    .shortcuts-help-title {
      font-weight: bold;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .shortcuts-help-close {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 18px;
    }

    .shortcut-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 0;
      border-bottom: 1px solid var(--border-light);
    }

    .shortcut-item:last-child {
      border-bottom: none;
    }

    .shortcut-key {
      background: var(--bg-tertiary);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-family: monospace;
      color: #667eea;
    }

    .shortcut-desc {
      font-size: 13px;
      color: var(--text-secondary);
    }

    .shortcuts-toggle {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 50%;
      width: 44px;
      height: 44px;
      display: none;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 18px;
      z-index: 99;
    }

    @media (min-width: 1024px) {
      .shortcuts-toggle {
        display: flex;
      }
    }

    /* 포모도로 타이머 */
    .pomodoro-section {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 20px;
      border: 2px solid #333;
      text-align: center;
    }

    .pomodoro-section.active {
      border-color: #667eea;
      animation: pomodoro-pulse 2s infinite;
    }

    .pomodoro-section.break {
      border-color: #48bb78;
      background: linear-gradient(135deg, #1a2e1a 0%, #162e16 100%);
    }

    @keyframes pomodoro-pulse {
      0%, 100% { box-shadow: 0 0 0 0 rgba(102, 126, 234, 0.4); }
      50% { box-shadow: 0 0 0 10px rgba(102, 126, 234, 0); }
    }

    .pomodoro-title {
      font-size: 14px;
      color: var(--text-secondary);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .pomodoro-time {
      font-size: 56px;
      font-weight: bold;
      font-family: monospace;
      margin-bottom: 8px;
    }

    .pomodoro-status {
      font-size: 14px;
      color: #667eea;
      margin-bottom: 15px;
    }

    .pomodoro-section.break .pomodoro-status {
      color: #48bb78;
    }

    .pomodoro-task {
      font-size: 16px;
      color: #ccc;
      margin-bottom: 15px;
      padding: 10px;
      background: rgba(255,255,255,0.05);
      border-radius: 8px;
    }

    .pomodoro-controls {
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .pomodoro-btn {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 15px;
      font-weight: bold;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .pomodoro-btn:active {
      transform: scale(0.95);
    }

    .pomodoro-btn.start {
      background: #667eea;
      color: white;
    }

    .pomodoro-btn.pause {
      background: #ff9500;
      color: white;
    }

    .pomodoro-btn.stop {
      background: #f5576c;
      color: white;
    }

    .pomodoro-btn.skip {
      background: var(--bg-tertiary);
      color: white;
    }

    .pomodoro-stats {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--border-color);
    }

    .pomodoro-stat {
      text-align: center;
    }

    .pomodoro-stat-value {
      font-size: 24px;
      font-weight: bold;
      color: #667eea;
    }

    .pomodoro-stat-label {
      font-size: 12px;
      color: var(--text-muted);
    }

    .filter-chips {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .filter-chip {
      padding: 8px 14px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 20px;
      color: var(--text-secondary);
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .filter-chip:hover {
      border-color: #667eea;
    }

    .filter-chip.active {
      background: #667eea;
      border-color: #667eea;
      color: white;
    }

    .filter-chip.본업.active { background: #667eea; border-color: #667eea; }
    .filter-chip.부업.active { background: #f093fb; border-color: #f093fb; }
    .filter-chip.일상.active { background: #48bb78; border-color: #48bb78; }
    .filter-chip.가족.active { background: #f6ad55; border-color: #f6ad55; }

    /* 전체 목록 탭 스타일 */
    .all-tasks-header {
      margin-bottom: 20px;
    }

    .all-tasks-header h2 {
      margin: 0 0 8px 0;
      font-size: 20px;
      font-weight: 600;
    }

    .all-tasks-summary {
      font-size: 14px;
      color: #888;
    }

    .all-category-section {
      background: var(--bg-secondary);
      border-radius: 12px;
      margin-bottom: 15px;
      overflow: hidden;
      border: 1px solid var(--border-color);
    }

    .all-category-header {
      padding: 15px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-left: 4px solid #667eea;
    }

    .all-category-header.본업 { border-left-color: #667eea; }
    .all-category-header.부업 { border-left-color: #f093fb; }
    .all-category-header.일상 { border-left-color: #48bb78; }
    .all-category-header.가족 { border-left-color: #f6ad55; }

    .all-category-title {
      font-size: 16px;
      font-weight: 600;
    }

    .all-category-count {
      font-size: 13px;
      color: #888;
    }

    .all-task-list {
      border-top: 1px solid var(--border-color);
    }

    .all-task-list.completed-list {
      display: none;
      background: #151515;
    }

    .all-task-list.completed-list.show {
      display: block;
    }

    .all-task-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 15px;
      border-bottom: 1px solid var(--border-light);
      border-left: 4px solid var(--task-cat-color, transparent);
      gap: 10px;
    }

    .all-task-item:last-child {
      border-bottom: none;
    }

    .all-task-item.urgent {
      background: rgba(255, 107, 107, 0.1);
    }

    .all-task-item.warning {
      background: rgba(255, 193, 7, 0.05);
    }

    .all-task-item.completed {
      opacity: 0.6;
    }

    .all-task-content {
      flex: 1;
      min-width: 0;
    }

    .all-task-title {
      font-size: 14px;
      margin-bottom: 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .all-task-title.completed {
      text-decoration: line-through;
      color: var(--text-muted);
    }

    .all-task-meta {
      font-size: 12px;
      color: #888;
    }

    .all-task-actions {
      display: flex;
      gap: 6px;
      flex-shrink: 0;
    }

    .all-completed-section {
      border-top: 1px solid var(--border-color);
    }

    .all-completed-toggle {
      padding: 10px 15px;
      font-size: 13px;
      color: #888;
      cursor: pointer;
      background: #1f1f1f;
    }

    .all-completed-toggle:hover {
      background: #252525;
    }

    .all-task-more {
      padding: 8px 15px;
      font-size: 12px;
      color: var(--text-muted);
      text-align: center;
    }

    .search-results-count {
      font-size: 12px;
      color: var(--text-muted);
      margin-top: 10px;
    }

    /* 일정 뷰 스타일 */
    .schedule-filter {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .schedule-filter-btn {
      padding: 10px 20px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      color: var(--text-secondary);
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .schedule-filter-btn.active {
      background: #667eea;
      border-color: #667eea;
      color: white;
    }

    .schedule-day {
      background: var(--bg-secondary);
      border-radius: 12px;
      margin-bottom: 15px;
      border: 1px solid var(--border-color);
      overflow: hidden;
    }

    .schedule-day-header {
      background: var(--bg-tertiary);
      padding: 12px 15px;
      font-weight: bold;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .schedule-day-header.today {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }

    .schedule-day-header.weekend {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    }

    .schedule-day-count {
      font-size: 12px;
      opacity: 0.8;
    }

    .schedule-day-tasks {
      padding: 10px;
    }

    .schedule-task {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px;
      background: var(--bg-tertiary);
      border-radius: 8px;
      margin-bottom: 8px;
    }

    .schedule-task:last-child {
      margin-bottom: 0;
    }

    .schedule-task-time {
      font-size: 12px;
      color: #667eea;
      min-width: 50px;
    }

    .schedule-task-title {
      flex: 1;
      font-size: 14px;
    }

    .schedule-task-category {
      font-size: 11px;
      padding: 4px 8px;
      border-radius: 4px;
    }

    .schedule-empty {
      padding: 15px;
      text-align: center;
      color: var(--text-muted);
      font-size: 14px;
    }

    .schedule-timeline {
      position: relative;
      padding-left: 60px;
    }

    .timeline-hour {
      position: relative;
      min-height: 60px;
      border-bottom: 1px solid var(--border-light);
    }

    .timeline-hour-label {
      position: absolute;
      left: -50px;
      top: -8px;
      font-size: 12px;
      color: var(--text-muted);
      width: 40px;
      text-align: right;
    }

    .timeline-task {
      background: #667eea;
      border-radius: 6px;
      padding: 8px 10px;
      margin: 2px 0;
      font-size: 13px;
    }

    .timeline-task.부업 {
      background: #f093fb;
    }

    .timeline-task.일상 {
      background: #48bb78;
    }

    /* PC에서 일정 뷰 그리드 */
    @media (min-width: 1024px) {
      .schedule-week-grid {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
        gap: 15px;
      }

      .schedule-day {
        margin-bottom: 0;
      }
    }

    /* 부업 이벤트 탭 스타일 */
    .events-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      margin-bottom: 24px;
      padding-bottom: 16px;
      border-bottom: 1px solid var(--border-light);
      flex-wrap: wrap;
    }

    .events-header .btn {
      width: auto !important;
      margin-bottom: 0 !important;
      padding: 12px 20px !important;
      font-size: 14px !important;
    }

    .events-title {
      font-size: 18px;
      font-weight: 600;
      letter-spacing: -0.02em;
      white-space: nowrap;
    }

    /* 텔레그램 연동 상태 */
    .telegram-status {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 20px;
      font-size: 12px;
      font-family: inherit;
      color: var(--text-tertiary);
      cursor: pointer;
      transition: background 0.2s, border-color 0.2s;
      min-height: 44px;
    }

    .telegram-status:hover {
      background: var(--bg-secondary);
      border-color: var(--text-tertiary);
    }

    .telegram-status:active {
      transform: scale(0.97);
    }

    .telegram-status.connected {
      background: rgba(72, 187, 120, 0.15);
      border-color: #48bb78;
      color: #48bb78;
    }

    .telegram-status.connected:hover {
      background: rgba(72, 187, 120, 0.25);
    }

    .telegram-icon {
      font-size: 14px;
    }

    /* 텔레그램 이벤트 목록 모달 */
    .tg-events-list {
      max-height: 400px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .tg-event-item {
      padding: 12px;
      background: var(--bg-secondary);
      border-radius: 10px;
      border: 1px solid var(--border-color);
      transition: border-color 0.2s;
    }

    .tg-event-item:has(input:checked) {
      border-color: var(--accent-blue);
      background: rgba(74, 158, 255, 0.08);
    }

    .tg-event-row {
      display: flex;
      align-items: flex-start;
      gap: 10px;
    }

    .tg-event-check {
      flex-shrink: 0;
      padding: 2px;
      cursor: pointer;
    }

    .tg-event-info {
      flex: 1;
      min-width: 0;
    }

    .tg-event-title {
      font-weight: 600;
      margin-bottom: 4px;
      word-break: break-word;
      font-size: 14px;
    }

    .tg-event-meta {
      font-size: 12px;
      color: var(--text-secondary);
      display: flex;
      flex-wrap: wrap;
      gap: 6px 10px;
    }

    .tg-event-expand {
      flex-shrink: 0;
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 12px;
      cursor: pointer;
      padding: 4px 6px;
      border-radius: 4px;
      font-family: inherit;
    }

    .tg-event-expand:hover {
      background: var(--bg-tertiary);
    }

    .tg-event-detail {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid var(--border-color);
    }

    .tg-event-empty {
      text-align: center;
      padding: 40px 20px;
      color: var(--text-muted);
    }

    .tg-event-empty-icon {
      font-size: 48px;
      margin-bottom: 12px;
    }

    .tg-select-all {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      margin-bottom: 12px;
      background: var(--bg-secondary);
      border-radius: 8px;
      font-size: 13px;
      color: var(--text-secondary);
      cursor: pointer;
    }

    .tg-select-all:hover {
      background: var(--bg-tertiary);
    }

    /* 이벤트 빠른 추가 */
    .events-quick-add {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      padding: 12px;
      background: var(--bg-secondary);
      border-radius: var(--radius-md);
      border: 1px solid var(--border-color);
    }

    .events-quick-input {
      flex: 1;
      padding: 10px 14px;
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-sm);
      color: var(--text-primary);
      font-size: 14px;
    }

    .events-quick-input::placeholder {
      color: var(--text-tertiary);
    }

    .events-quick-btn {
      width: 40px;
      height: 40px;
      background: var(--accent-pink);
      border: none;
      border-radius: var(--radius-sm);
      color: white;
      font-size: 20px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
    }

    .events-quick-btn:hover {
      transform: scale(1.05);
    }

    .events-detail-btn {
      width: 40px;
      height: 40px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-sm);
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .events-detail-btn:hover {
      background: var(--bg-secondary);
    }

    .events-section {
      margin-bottom: 28px;
    }

    .events-section-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 14px;
      padding: 8px 0;
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .events-section.submitted .events-section-title {
      color: #48bb78;
    }

    .events-list {
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .events-list.collapsed {
      display: none;
    }

    .event-card {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-sm);
      padding: 10px 14px;
      transition: all var(--transition-normal);
      box-shadow: 0 1px 4px var(--shadow-color);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .event-card:hover {
      border-color: rgba(102, 126, 234, 0.5);
      box-shadow: 0 2px 8px var(--shadow-color);
    }

    .event-card.urgent {
      border-left: 4px solid #f5576c;
      background: linear-gradient(90deg, rgba(245,87,108,0.08) 0%, transparent 30%);
    }

    .event-card.warning {
      border-left: 4px solid #ff9500;
      background: linear-gradient(90deg, rgba(255,149,0,0.08) 0%, transparent 30%);
    }

    .event-card.completed {
      opacity: 0.6;
      background: #151515;
    }

    .event-card-header {
      display: none;
    }

    .event-title {
      font-size: 14px;
      font-weight: 600;
      flex: 1;
      line-height: 1.3;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      min-width: 0;
    }

    .event-compact-date {
      font-size: 12px;
      color: var(--text-muted);
      white-space: nowrap;
      flex-shrink: 0;
    }

    .event-completed-date {
      font-size: 11px;
      color: var(--success);
      white-space: nowrap;
      flex-shrink: 0;
      cursor: pointer;
      padding: 2px 6px;
      border-radius: 4px;
      transition: background 0.2s;
    }

    .event-completed-date:hover {
      background: rgba(72, 187, 120, 0.15);
    }

    .event-card-main {
      flex: 1;
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .event-meta-info {
      font-size: 11px;
      color: var(--text-muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .event-description {
      font-size: 11px;
      color: var(--text-secondary);
      line-height: 1.3;
    }

    .events-group {
      margin-bottom: 16px;
    }

    .events-group-header {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 8px;
      padding: 4px 0;
      border-bottom: 1px solid var(--border-color);
      cursor: pointer;
      user-select: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .events-group-header:hover {
      color: var(--text-primary);
    }
    .events-group-header .toggle-icon {
      font-size: 11px;
      transition: transform 0.2s;
    }

    .event-tg-badge {
      margin-right: 4px;
      font-size: 12px;
    }

    .event-tg-synced {
      font-size: 10px;
      color: #48bb78;
      background: rgba(72, 187, 120, 0.1);
      padding: 2px 6px;
      border-radius: 4px;
      white-space: nowrap;
      flex-shrink: 0;
    }

    /* 이벤트 일괄 선택 */
    .event-bulk-select-btn {
      padding: 6px 14px;
      font-size: 13px;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      background: transparent;
      color: var(--text-secondary);
      cursor: pointer;
      min-height: 44px;
      min-width: 44px;
      transition: background 0.15s, color 0.15s;
    }
    .event-bulk-select-btn:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }
    .event-bulk-select-btn.active {
      background: var(--accent-primary);
      color: white;
      border-color: var(--accent-primary);
    }
    .event-bulk-actions {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 14px;
      margin-bottom: 12px;
      background: var(--bg-tertiary);
      border-radius: 10px;
      border: 1px solid var(--border-color);
    }
    .event-bulk-actions button {
      padding: 6px 14px;
      font-size: 13px;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      background: transparent;
      color: var(--text-secondary);
      cursor: pointer;
      min-height: 44px;
      min-width: 44px;
    }
    .event-bulk-actions .bulk-delete-btn {
      background: #f5576c;
      color: white;
      border-color: #f5576c;
    }
    .event-bulk-actions .bulk-delete-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .event-bulk-actions .bulk-cancel-btn:hover {
      background: var(--bg-secondary);
    }
    .event-bulk-count {
      font-size: 13px;
      color: var(--text-muted);
      margin-left: auto;
    }
    .event-check-col {
      display: flex;
      align-items: center;
      margin-right: 10px;
      flex-shrink: 0;
    }
    .event-check-col input[type="checkbox"] {
      width: 20px;
      height: 20px;
      cursor: pointer;
      min-width: 44px;
      min-height: 44px;
      accent-color: var(--accent-primary);
    }

    .event-dday {
      font-size: 12px;
      font-weight: bold;
      padding: 2px 8px;
      border-radius: 4px;
      background: var(--bg-tertiary);
      white-space: nowrap;
      flex-shrink: 0;
    }

    .event-card.urgent .event-dday {
      background: #f5576c;
      color: white;
    }

    .event-card.warning .event-dday {
      background: #ff9500;
      color: white;
    }

    .event-meta {
      display: none;
    }

    .event-meta-divider {
      color: #444;
    }

    .event-tag {
      font-size: 12px;
      padding: 3px 8px;
      border-radius: 4px;
      background: var(--bg-tertiary);
    }

    .event-tag.organizer {
      background: #667eea22;
      color: #99aaff;
      border: 1px solid #667eea44;
    }

    .event-tag.type {
      background: #f093fb22;
      color: #f5b8ff;
      border: 1px solid #f093fb44;
    }

    .event-date {
      font-size: 13px;
      color: var(--text-muted);
    }

    .event-actions {
      display: flex;
      gap: 6px;
      flex-shrink: 0;
      padding-top: 0;
    }

    /* 버튼 변형 - CSS 변수 사용 (통일) */
    .btn-link {
      background: transparent;
      color: var(--accent-primary);
      text-decoration: none;
      border: 1px solid rgba(102, 126, 234, 0.27);
    }

    .btn-link:hover {
      background: rgba(102, 126, 234, 0.13);
    }

    .btn-submit {
      background: var(--accent-success);
      color: white;
    }

    .btn-submit:hover {
      filter: brightness(0.9);
      transform: scale(1.02);
    }

    .btn-edit {
      background: transparent;
      color: var(--text-muted);
      padding: 8px 10px;
    }

    .btn-edit:hover {
      color: var(--text-primary);
    }

    .btn-undo {
      background: transparent;
      color: var(--text-muted);
      border: 1px solid var(--border-color);
    }

    .btn-undo:hover {
      border-color: var(--accent-warning);
      color: var(--accent-warning);
    }

    .btn-delete {
      background: transparent;
      color: var(--text-muted);
    }

    .btn-delete:hover {
      color: var(--accent-danger);
    }

    .events-empty {
      text-align: center;
      padding: 60px 20px;
      background: linear-gradient(180deg, #1a1a1a 0%, #151515 100%);
      border-radius: 16px;
      border: 1px solid #2a2a2a;
    }

    .events-empty-icon {
      font-size: 56px;
      margin-bottom: 16px;
    }

    .events-empty-text {
      color: var(--text-muted);
      font-size: 15px;
    }

    .events-summary {
      display: flex;
      gap: 20px;
      margin-bottom: 24px;
      padding: 16px;
      background: var(--bg-secondary);
      border-radius: 12px;
    }

    .events-summary-item {
      text-align: center;
    }

    .events-summary-value {
      font-size: 28px;
      font-weight: bold;
      color: #fff;
    }

    .events-summary-label {
      font-size: 12px;
      color: var(--text-muted);
      margin-top: 4px;
    }

    /* PC에서 이벤트 카드 그리드 */
    @media (min-width: 1024px) {
      .events-list {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 16px;
      }

      .events-header {
        margin-bottom: 28px;
      }

      .events-title {
        font-size: 26px;
      }
    }

    /* PWA 설치 배너 */
    .install-banner {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 15px;
      border-radius: 12px;
      margin-bottom: 20px;
      display: none;
    }

    .install-banner.show {
      display: block;
    }

    .install-banner-content {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .install-banner-text {
      font-size: 14px;
    }

    .install-banner-btn {
      padding: 10px 20px;
      background: white;
      border: none;
      border-radius: 8px;
      color: #667eea;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      white-space: nowrap;
    }

    .install-banner-close {
      background: transparent;
      border: none;
      color: white;
      font-size: 20px;
      cursor: pointer;
      padding: 5px;
    }

    /* ============================================
       히스토리 / 캘린더 스타일
       ============================================ */

    /* 히스토리 헤더 */
    .history-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .history-header h2 {
      font-size: 20px;
      margin: 0;
    }

    .history-summary {
      font-size: 14px;
      color: var(--text-secondary);
    }

    /* 히스토리 뷰 탭 */
    .history-view-tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 20px;
    }

    .history-view-tab {
      flex: 1;
      padding: 12px 16px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 10px;
      color: var(--text-secondary);
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .history-view-tab:hover {
      background: var(--bg-secondary);
    }

    .history-view-tab.active {
      background: var(--primary);
      border-color: var(--primary);
      color: white;
      font-weight: 600;
    }

    /* 라이프 리듬 히스토리 */
    .rhythm-history-empty {
      text-align: center;
      padding: 60px 20px;
      color: var(--text-muted);
    }

    .rhythm-history-empty-icon {
      font-size: 48px;
      margin-bottom: 16px;
    }

    .rhythm-history-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .rhythm-history-item {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      padding: 16px;
    }

    .rhythm-history-item.today {
      border-color: var(--primary);
      background: linear-gradient(135deg, var(--bg-secondary) 0%, rgba(102, 126, 234, 0.1) 100%);
    }

    .rhythm-history-date {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 12px;
    }

    .rhythm-history-day {
      font-weight: 600;
      color: var(--text-primary);
    }

    .rhythm-history-date-num {
      color: var(--text-secondary);
      font-size: 14px;
    }

    .rhythm-history-today-badge {
      font-size: 11px;
      background: var(--primary);
      color: white;
      padding: 2px 8px;
      border-radius: 10px;
    }

    .rhythm-history-timeline {
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 12px;
    }

    .rhythm-history-timeline.six-items {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
    }

    @media (min-width: 600px) {
      .rhythm-history-timeline.six-items {
        grid-template-columns: repeat(6, 1fr);
      }
    }

    .rhythm-history-time {
      font-family: 'SF Mono', Monaco, monospace;
      font-size: 12px;
      cursor: pointer;
      padding: 4px 6px;
      border-radius: 6px;
      transition: background 0.2s;
      text-align: center;
    }

    .rhythm-history-time:hover {
      background: var(--bg-tertiary);
    }

    .rhythm-history-time .empty {
      color: var(--text-muted);
    }

    .rhythm-history-arrow {
      color: var(--text-muted);
      font-size: 12px;
    }

    .rhythm-history-summary {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      font-size: 11px;
      color: var(--text-secondary);
    }

    .rhythm-history-summary span {
      background: var(--bg-tertiary);
      padding: 2px 6px;
      border-radius: 4px;
    }

    .rhythm-history-summary span.total {
      background: rgba(102, 126, 234, 0.15);
      color: var(--primary);
    }

    @media (max-width: 480px) {
      .rhythm-history-timeline {
        justify-content: center;
      }

      .rhythm-history-summary {
        justify-content: center;
      }
    }

    /* 주간 요약 카드 */
    .week-summary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 20px;
      color: white;
    }

    .week-summary-title {
      font-size: 14px;
      opacity: 0.9;
      margin-bottom: 10px;
    }

    .week-summary-stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
    }

    .week-stat {
      text-align: center;
    }

    .week-stat-value {
      font-size: 28px;
      font-weight: bold;
    }

    .week-stat-label {
      font-size: 12px;
      opacity: 0.85;
    }

    /* 미니 캘린더 */
    .calendar-container {
      background: var(--bg-secondary);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 20px;
      border: 1px solid var(--border-color);
    }

    .calendar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .calendar-title {
      font-size: 18px;
      font-weight: bold;
    }

    .calendar-nav {
      display: flex;
      gap: 10px;
    }

    .calendar-nav-btn {
      width: 36px;
      height: 36px;
      border: 1px solid var(--border-color);
      background: var(--bg-tertiary);
      border-radius: 8px;
      color: var(--text-primary);
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .calendar-nav-btn:hover {
      background: #667eea;
      border-color: #667eea;
    }

    .calendar-weekdays {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 5px;
      margin-bottom: 10px;
    }

    .calendar-weekday {
      text-align: center;
      font-size: 12px;
      color: var(--text-muted);
      padding: 8px 0;
    }

    .calendar-weekday:first-child {
      color: #f5576c;
    }

    .calendar-weekday:last-child {
      color: #667eea;
    }

    .calendar-days {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 5px;
    }

    .calendar-day {
      aspect-ratio: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
      background: var(--bg-tertiary);
      border: 1px solid transparent;
    }

    .calendar-day:hover {
      border-color: #667eea;
    }

    .calendar-day.empty {
      background: transparent;
      cursor: default;
    }

    .calendar-day.today {
      border: 2px solid #667eea;
      font-weight: bold;
    }

    .calendar-day.selected {
      background: #667eea;
      color: white;
    }

    .calendar-day.has-activity {
      background: rgba(102, 126, 234, 0.2);
    }

    .calendar-day.has-activity.level-1 {
      background: rgba(102, 126, 234, 0.2);
    }

    .calendar-day.has-activity.level-2 {
      background: rgba(102, 126, 234, 0.4);
    }

    .calendar-day.has-activity.level-3 {
      background: rgba(102, 126, 234, 0.6);
    }

    .calendar-day.has-activity.level-4 {
      background: rgba(102, 126, 234, 0.8);
      color: white;
    }

    .calendar-day-number {
      font-size: 14px;
    }

    .calendar-day-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #48bb78;
      position: absolute;
      bottom: 4px;
    }

    /* 캘린더 범례 */
    .calendar-legend {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 15px;
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--border-color);
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .legend-box {
      width: 14px;
      height: 14px;
      border-radius: 3px;
    }

    .legend-box.empty {
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
    }

    .legend-box.level-1 { background: rgba(102, 126, 234, 0.2); }
    .legend-box.level-2 { background: rgba(102, 126, 234, 0.4); }
    .legend-box.level-3 { background: rgba(102, 126, 234, 0.6); }
    .legend-box.level-4 { background: rgba(102, 126, 234, 0.8); }

    /* 일별 상세 */
    .day-detail {
      background: var(--bg-secondary);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 20px;
      border: 1px solid var(--border-color);
    }

    .day-detail-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding-bottom: 15px;
      border-bottom: 1px solid var(--border-color);
    }

    .day-detail-date {
      font-size: 18px;
      font-weight: bold;
    }

    .day-detail-stats {
      display: flex;
      gap: 15px;
      font-size: 14px;
      color: var(--text-secondary);
    }

    .day-detail-stat {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .day-detail-stat.completed {
      color: #48bb78;
    }

    .day-detail-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .day-task-item {
      display: flex;
      align-items: flex-start;
      gap: 12px;
      padding: 12px;
      background: var(--bg-tertiary);
      border-radius: 10px;
    }

    .day-task-time {
      font-size: 13px;
      color: var(--text-muted);
      white-space: nowrap;
      min-width: 50px;
    }

    .day-task-content {
      flex: 1;
    }

    .day-task-title {
      font-weight: 500;
      margin-bottom: 4px;
    }

    .day-task-title.completed {
      color: #48bb78;
    }

    .day-task-title.incomplete {
      color: var(--text-muted);
      text-decoration: line-through;
    }

    .day-task-meta {
      font-size: 12px;
      color: var(--text-secondary);
    }

    .day-task-status {
      font-size: 20px;
    }

    /* 빈 상태 */
    .day-empty {
      text-align: center;
      padding: 30px;
      color: var(--text-muted);
    }

    .day-empty-icon {
      font-size: 40px;
      margin-bottom: 10px;
    }

    /* 히스토리 리스트 (최근 기록) */
    .history-list {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .history-date-group {
      background: var(--bg-secondary);
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid var(--border-color);
    }

    .history-date-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px;
      background: var(--bg-tertiary);
      cursor: pointer;
    }

    .history-date-header:hover {
      background: rgba(102, 126, 234, 0.1);
    }

    .history-date-title {
      font-weight: bold;
    }

    .history-date-count {
      font-size: 14px;
      color: var(--text-secondary);
    }

    .history-date-tasks {
      padding: 10px 15px;
      display: none;
    }

    .history-date-tasks.show {
      display: block;
    }

    .history-task {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 0;
      border-bottom: 1px solid var(--border-light);
    }

    .history-task:last-child {
      border-bottom: none;
    }

    .history-task-check {
      color: #48bb78;
      font-size: 16px;
    }

    .history-task-title {
      flex: 1;
      font-size: 14px;
    }

    .history-task-time {
      font-size: 12px;
      color: var(--text-muted);
    }

    /* 모바일 최적화 */
    @media (max-width: 767px) {
      .week-summary-stats {
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
      }

      .week-stat-value {
        font-size: 22px;
      }

      .calendar-day {
        font-size: 12px;
      }

      .calendar-legend {
        flex-wrap: wrap;
        gap: 10px;
      }
    }

    /* ============================================
       설정 모달 스타일
       ============================================ */

    .settings-btn {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      border: 1px solid var(--border-color);
      background: var(--bg-secondary);
      font-size: 20px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .settings-btn:hover {
      background: var(--bg-tertiary);
      transform: scale(1.05);
    }

    .settings-modal {
      max-width: 500px;
      max-height: 90vh;
      overflow-y: auto;
    }

    .settings-section {
      margin-bottom: 24px;
    }

    .settings-section:last-child {
      margin-bottom: 0;
    }

    .settings-section-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 15px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border-color);
    }

    .settings-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 0;
      border-bottom: 1px solid var(--border-light);
    }

    .settings-row:last-child {
      border-bottom: none;
    }

    .settings-label {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .settings-label-icon {
      font-size: 20px;
    }

    .settings-label-text {
      display: flex;
      flex-direction: column;
    }

    .settings-label-title {
      font-weight: 500;
      font-size: 14px;
      letter-spacing: -0.01em;
    }

    .settings-label-desc {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 3px;
      font-weight: 400;
    }

    .settings-input {
      width: 150px;
      padding: 10px 16px;
      padding-right: 36px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      color: var(--text-primary);
      font-size: 14px;
      text-align: center;
      font-family: inherit;
      font-weight: 500;
      color-scheme: dark;
      position: relative;
    }

    .settings-input::-webkit-calendar-picker-indicator {
      filter: invert(1) brightness(1.5);
      cursor: pointer;
      padding: 6px;
      margin-left: 4px;
      opacity: 0.9;
      width: 20px;
      height: 20px;
      position: absolute;
      right: 8px;
    }

    .settings-input::-webkit-calendar-picker-indicator:hover {
      opacity: 1;
    }

    /* Firefox 시간 입력 */
    .settings-input::-moz-focus-inner {
      border: 0;
    }

    .settings-input:focus {
      outline: none;
      border-color: #667eea;
    }

    /* 라이트 모드 시간 입력 */
    [data-theme="light"] .settings-input {
      color-scheme: light;
    }

    [data-theme="light"] .settings-input::-webkit-calendar-picker-indicator {
      filter: none;
      opacity: 0.7;
    }

    [data-theme="light"] .settings-input::-webkit-calendar-picker-indicator:hover {
      opacity: 1;
    }

    .settings-time-preview {
      margin-top: 20px;
      padding: 15px;
      background: var(--bg-tertiary);
      border-radius: 12px;
      text-align: center;
    }

    .settings-time-preview-title {
      font-size: 12px;
      color: var(--text-muted);
      margin-bottom: 10px;
    }

    .settings-time-preview-timeline {
      display: flex;
      justify-content: space-around;
      align-items: center;
      gap: 5px;
    }

    .timeline-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }

    .timeline-icon {
      font-size: 20px;
    }

    .timeline-time {
      font-size: 12px;
      color: var(--text-secondary);
    }

    .timeline-arrow {
      color: var(--text-muted);
      font-size: 14px;
    }

    /* ============================================
       일일 목표 진행률 스타일
       ============================================ */

    .daily-goal-section {
      background: var(--bg-secondary);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 20px;
      border: 1px solid var(--border-color);
    }

    .daily-goal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .daily-goal-title {
      font-size: 14px;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .daily-goal-count {
      font-size: 14px;
      color: var(--text-secondary);
    }

    .daily-goal-count strong {
      color: #667eea;
      font-size: 18px;
    }

    .daily-goal-progress {
      height: 12px;
      background: var(--bg-tertiary);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 10px;
    }

    .daily-goal-fill {
      height: 100%;
      background: linear-gradient(90deg, #667eea, #764ba2);
      border-radius: 6px;
      transition: width 0.5s ease;
    }

    .daily-goal-fill.complete {
      background: linear-gradient(90deg, #48bb78, #38a169);
    }

    .daily-goal-fill.over {
      background: linear-gradient(90deg, #f6ad55, #ed8936);
    }

    .daily-goal-message {
      text-align: center;
      font-size: 14px;
      color: var(--text-secondary);
      padding: 10px;
      background: var(--bg-tertiary);
      border-radius: 8px;
    }

    .daily-goal-message.success {
      background: rgba(72, 187, 120, 0.15);
      color: #48bb78;
    }

    .daily-goal-message.over {
      background: rgba(246, 173, 85, 0.15);
      color: #f6ad55;
    }

    /* 일일 목표 (게이미피케이션 버전) */
    .daily-goal-compact {
      background: linear-gradient(135deg, var(--bg-secondary), var(--bg-tertiary));
      border-radius: var(--radius-lg);
      padding: 16px 20px;
      margin-bottom: 16px;
      border: 1px solid var(--border-color);
      position: relative;
      overflow: hidden;
    }

    .daily-goal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .daily-goal-info {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
    }

    .daily-goal-emoji {
      font-size: 20px;
    }

    .daily-goal-text {
      font-size: 14px;
      color: var(--text-secondary);
    }

    .daily-goal-text strong {
      color: #667eea;
      font-weight: 700;
      font-size: 16px;
    }

    .daily-goal-percentage {
      font-size: 22px;
      font-weight: 700;
      background: linear-gradient(135deg, #667eea, #764ba2);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .daily-goal-percentage.complete {
      background: linear-gradient(135deg, #48bb78, #38a169);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .daily-goal-track {
      position: relative;
      height: 24px;
      background: var(--bg-primary);
      border-radius: 12px;
      overflow: visible;
      margin-bottom: 8px;
    }

    .daily-goal-bar {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      border-radius: 12px;
      transition: width 0.5s ease;
    }

    .daily-goal-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #667eea, #764ba2);
      border-radius: 12px;
      transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
    }

    .daily-goal-bar-fill.complete {
      background: linear-gradient(90deg, #48bb78, #38a169);
    }

    .daily-goal-runner {
      position: absolute;
      right: -12px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 20px;
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
      animation: runner-bounce 0.5s ease infinite;
    }

    @keyframes runner-bounce {
      0%, 100% { transform: translateY(-50%) translateX(0); }
      50% { transform: translateY(-60%) translateX(2px); }
    }

    .daily-goal-finish {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 16px;
    }

    .daily-goal-message {
      font-size: 12px;
      color: var(--text-muted);
      text-align: center;
      margin-top: 4px;
    }

    .daily-goal-message.positive {
      color: #48bb78;
    }

    .daily-goal-message.encourage {
      color: #667eea;
    }

    /* 주간 통계 그래프 */
    .weekly-chart {
      display: flex;
      align-items: flex-end;
      justify-content: space-around;
      height: 120px;
      padding: 10px 0;
      margin-top: 15px;
    }

    .weekly-chart-bar {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      flex: 1;
    }

    .weekly-chart-fill {
      width: 30px;
      background: linear-gradient(180deg, #667eea, #764ba2);
      border-radius: 4px 4px 0 0;
      min-height: 4px;
      transition: height 0.3s ease;
    }

    .weekly-chart-fill.today {
      background: linear-gradient(180deg, #48bb78, #38a169);
    }

    .weekly-chart-fill.empty {
      background: var(--bg-tertiary);
    }

    .weekly-chart-label {
      font-size: 11px;
      color: var(--text-muted);
    }

    .weekly-chart-label.today {
      color: #48bb78;
      font-weight: bold;
    }

    .weekly-chart-value {
      font-size: 12px;
      color: var(--text-secondary);
    }

    /* 목표 설정 인풋 */
    .settings-input-number {
      width: 80px;
      padding: 10px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      color: var(--text-primary);
      font-size: 18px;
      text-align: center;
      font-family: inherit;
    }

    .settings-input-number:focus {
      outline: none;
      border-color: #667eea;
    }

    /* ============================================
       템플릿 스타일
       ============================================ */

    .templates-section {
      margin-top: 10px;
    }

    .templates-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      color: var(--text-secondary);
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .templates-toggle:hover {
      border-color: #667eea;
      color: #667eea;
    }

    .templates-list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 10px;
      padding: 12px;
      background: var(--bg-tertiary);
      border-radius: 10px;
    }

    .template-chip {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 12px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 20px;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .template-chip:hover {
      border-color: #667eea;
      background: rgba(102, 126, 234, 0.1);
    }

    .template-chip-icon {
      font-size: 14px;
    }

    .template-chip-delete {
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      color: var(--text-muted);
      font-size: 14px;
      cursor: pointer;
      border-radius: 50%;
      margin-left: 4px;
    }

    .template-chip-delete:hover {
      background: rgba(245, 87, 108, 0.2);
      color: #f5576c;
    }

    .template-add-btn {
      padding: 8px 12px;
      background: transparent;
      border: 1px dashed var(--border-color);
      border-radius: 20px;
      color: var(--text-muted);
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .template-add-btn:hover {
      border-color: #667eea;
      color: #667eea;
    }

    .template-empty {
      color: var(--text-muted);
      font-size: 13px;
      text-align: center;
      padding: 10px;
    }

    /* ============================================
       스와이프 힌트 & UX 개선
       ============================================ */

    .swipe-hint {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 15px;
      padding: 12px;
      margin-bottom: 15px;
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
      border: 1px dashed rgba(102, 126, 234, 0.3);
      border-radius: 12px;
      font-size: 13px;
      color: var(--text-secondary);
      animation: swipeHintPulse 2s ease-in-out infinite;
    }

    @keyframes swipeHintPulse {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 1; }
    }

    .swipe-hint-icon {
      font-size: 20px;
    }

    .swipe-hint-text {
      line-height: 1.4;
    }

    .swipe-hint-close {
      background: transparent;
      border: none;
      color: var(--text-muted);
      font-size: 16px;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 4px;
    }

    .swipe-hint-close:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    /* 저장 표시 */
    .save-indicator {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 10px 16px;
      background: #48bb78;
      color: white;
      border-radius: 8px;
      font-size: 13px;
      opacity: 0;
      transform: translateY(10px);
      transition: opacity 0.3s, transform 0.3s;
      z-index: 1000;
    }

    .save-indicator.show {
      opacity: 1;
      transform: translateY(0);
    }

    /* 동기부여 메시지 스타일 */
    .motivation-message {
      text-align: center;
      padding: 20px;
      background: linear-gradient(135deg, rgba(72, 187, 120, 0.1), rgba(56, 161, 105, 0.1));
      border-radius: 12px;
      margin: 10px 0;
    }

    .motivation-icon {
      font-size: 40px;
      margin-bottom: 10px;
    }

    .motivation-text {
      font-size: 16px;
      color: var(--text-primary);
      font-weight: 500;
    }

    .motivation-sub {
      font-size: 13px;
      color: var(--text-secondary);
      margin-top: 8px;
    }

    /* ============================================
       통근 트래커 스타일
       ============================================ */
    .commute-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px; }
    .commute-title { font-size: 18px; font-weight: 700; color: var(--text-primary); }
    .commute-sub-tabs { display: flex; gap: 4px; background: var(--bg-secondary); border-radius: 12px; padding: 3px; margin-bottom: 16px; }
    .commute-sub-tab { flex: 1; padding: 8px 12px; border: none; background: transparent; border-radius: 10px; font-size: 13px; font-weight: 600; color: var(--text-secondary); cursor: pointer; transition: all 0.2s; min-height: 44px; }
    .commute-sub-tab.active { background: var(--accent-primary); color: #fff; box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3); }
    .commute-route-list { display: flex; flex-direction: column; gap: 8px; margin-bottom: 16px; }
    .commute-route-card { display: flex; align-items: center; gap: 12px; padding: 14px 16px; background: var(--bg-card); border-radius: 14px; border: 2px solid transparent; cursor: pointer; transition: all 0.2s; min-height: 44px; }
    .commute-route-card:hover { border-color: var(--accent-primary); transform: translateY(-1px); }
    .commute-route-card.selected { border-color: var(--accent-primary); background: rgba(102, 126, 234, 0.08); }
    .commute-route-dot { width: 12px; height: 12px; border-radius: 50%; flex-shrink: 0; }
    .commute-route-info { flex: 1; min-width: 0; }
    .commute-route-name { font-size: 15px; font-weight: 600; color: var(--text-primary); }
    .commute-route-desc { font-size: 12px; color: var(--text-secondary); margin-top: 2px; }
    .commute-route-time { font-size: 13px; color: var(--text-muted); font-weight: 500; }
    .commute-route-actions { display: flex; gap: 4px; }
    .commute-route-action-btn { width: 32px; height: 32px; border: none; background: var(--bg-secondary); border-radius: 8px; cursor: pointer; font-size: 14px; display: flex; align-items: center; justify-content: center; transition: background 0.15s; }
    .commute-route-action-btn:hover { background: var(--bg-hover); }
    .commute-time-display { background: var(--bg-card); border-radius: 16px; padding: 20px; margin-bottom: 16px; }
    .commute-time-row { display: flex; align-items: center; justify-content: space-between; padding: 10px 0; }
    .commute-time-row + .commute-time-row { border-top: 1px solid var(--border-color); }
    .commute-time-label { font-size: 14px; color: var(--text-secondary); }
    .commute-time-value { font-size: 18px; font-weight: 700; color: var(--text-primary); }
    .commute-time-value.empty { color: var(--text-muted); font-weight: 400; }
    .commute-duration-badge { display: inline-flex; align-items: center; gap: 4px; padding: 6px 14px; border-radius: 20px; font-size: 15px; font-weight: 700; margin-top: 8px; }
    .commute-duration-badge.good { background: rgba(72, 187, 120, 0.15); color: #48bb78; }
    .commute-duration-badge.normal { background: rgba(237, 137, 54, 0.15); color: #ed8936; }
    .commute-duration-badge.bad { background: rgba(245, 101, 101, 0.15); color: #f56565; }
    .commute-recommend-card { background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1)); border-radius: 16px; padding: 18px; margin-bottom: 16px; }
    .commute-recommend-title { font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px; }
    .commute-recommend-time { font-size: 28px; font-weight: 800; color: var(--accent-primary); }
    .commute-recommend-detail { font-size: 12px; color: var(--text-secondary); margin-top: 6px; }
    .commute-recommend-confidence { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 11px; font-weight: 600; margin-top: 6px; }
    .commute-recommend-confidence.high { background: rgba(72, 187, 120, 0.15); color: #48bb78; }
    .commute-recommend-confidence.medium { background: rgba(237, 137, 54, 0.15); color: #ed8936; }
    .commute-recommend-confidence.low { background: rgba(160, 174, 192, 0.15); color: #a0aec0; }
    .commute-recent-summary { background: var(--bg-card); border-radius: 14px; padding: 16px; margin-bottom: 16px; }
    .commute-recent-title { font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 10px; }
    .commute-recent-row { display: flex; align-items: center; gap: 8px; padding: 6px 0; font-size: 13px; }
    .commute-recent-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
    .commute-recent-name { flex: 1; color: var(--text-primary); font-weight: 500; }
    .commute-recent-avg { color: var(--text-secondary); }
    .commute-recent-detail-row { display: flex; align-items: center; gap: 8px; padding: 8px 0; font-size: 13px; border-bottom: 1px solid var(--border-color); }
    .commute-recent-detail-row:last-of-type { border-bottom: none; }
    .commute-recent-day { width: 70px; font-weight: 500; color: var(--text-secondary); font-size: 12px; flex-shrink: 0; }
    .commute-recent-times { flex: 1; font-family: 'SF Mono', Monaco, monospace; font-size: 12px; color: var(--text-primary); }
    .commute-recent-duration { font-weight: 600; color: var(--primary); white-space: nowrap; }
    .commute-recent-avg-summary { margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-color); font-size: 13px; font-weight: 600; color: var(--text-primary); text-align: center; }
    .commute-history-list { display: flex; flex-direction: column; gap: 12px; }
    .commute-history-day { background: var(--bg-card); border-radius: 12px; padding: 12px; }
    .commute-history-date { font-size: 13px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px; padding-bottom: 6px; border-bottom: 1px solid var(--border-color); }
    .commute-history-trip { display: flex; align-items: center; gap: 8px; padding: 6px 0; font-size: 12px; }
    .commute-history-trip + .commute-history-trip { border-top: 1px dashed var(--border-color); padding-top: 8px; margin-top: 4px; }
    .commute-history-dir { font-weight: 500; width: 50px; flex-shrink: 0; }
    .commute-history-route { font-weight: 600; width: 80px; flex-shrink: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .commute-history-times { flex: 1; font-family: 'SF Mono', Monaco, monospace; color: var(--text-secondary); }
    .commute-history-dur { font-weight: 600; color: var(--primary); white-space: nowrap; }
    .commute-stats-card { background: var(--bg-card); border-radius: 16px; padding: 18px; margin-bottom: 12px; }
    .commute-stats-header { display: flex; align-items: center; gap: 8px; margin-bottom: 12px; }
    .commute-stats-route-name { font-size: 16px; font-weight: 700; color: var(--text-primary); }
    .commute-stats-count { font-size: 12px; color: var(--text-muted); padding: 2px 8px; background: var(--bg-secondary); border-radius: 10px; }
    .commute-stats-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
    .commute-stat-item { text-align: center; padding: 10px 6px; background: var(--bg-secondary); border-radius: 10px; }
    .commute-stat-value { font-size: 18px; font-weight: 700; color: var(--text-primary); }
    .commute-stat-label { font-size: 11px; color: var(--text-secondary); margin-top: 2px; }
    .commute-freq-bar-wrap { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
    .commute-freq-bar-label { width: 80px; font-size: 12px; font-weight: 500; color: var(--text-secondary); text-align: right; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .commute-freq-bar-track { flex: 1; height: 20px; background: var(--bg-secondary); border-radius: 10px; overflow: hidden; }
    .commute-freq-bar-fill { height: 100%; border-radius: 10px; transition: width 0.4s ease; min-width: 4px; }
    .commute-freq-bar-count { width: 40px; font-size: 12px; font-weight: 600; color: var(--text-primary); }
    .commute-weekday-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 4px; text-align: center; }
    .commute-weekday-item { padding: 8px 2px; background: var(--bg-secondary); border-radius: 8px; }
    .commute-weekday-label { font-size: 11px; color: var(--text-muted); font-weight: 600; }
    .commute-weekday-value { font-size: 14px; font-weight: 700; color: var(--text-primary); margin-top: 2px; }
    .commute-weekday-count { font-size: 10px; color: var(--text-muted); }
    .commute-best-badge { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 12px; font-weight: 700; background: rgba(72, 187, 120, 0.15); color: #48bb78; margin-left: 8px; }
    .commute-modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; align-items: center; justify-content: center; padding: 20px; }
    .commute-modal { background: var(--bg-primary); border-radius: 20px; padding: 24px; max-width: 400px; width: 100%; max-height: 80vh; overflow-y: auto; }
    .commute-modal-title { font-size: 18px; font-weight: 700; color: var(--text-primary); margin-bottom: 16px; }
    .commute-modal-field { margin-bottom: 14px; }
    .commute-modal-label { font-size: 13px; font-weight: 600; color: var(--text-secondary); margin-bottom: 6px; display: block; }
    .commute-modal-input { width: 100%; padding: 10px 14px; border: 1px solid var(--border-color); border-radius: 10px; background: var(--bg-card); color: var(--text-primary); font-size: 14px; box-sizing: border-box; }
    .commute-modal-input:focus { outline: none; border-color: var(--accent-primary); }
    .commute-modal-select { width: 100%; padding: 10px 14px; border: 1px solid var(--border-color); border-radius: 10px; background: var(--bg-card); color: var(--text-primary); font-size: 14px; box-sizing: border-box; }
    .commute-color-options { display: flex; gap: 8px; flex-wrap: wrap; }
    .commute-color-btn { width: 32px; height: 32px; border-radius: 50%; border: 3px solid transparent; cursor: pointer; transition: border-color 0.15s, transform 0.15s; }
    .commute-color-btn:hover { transform: scale(1.15); }
    .commute-color-btn.selected { border-color: var(--text-primary); }
    .commute-modal-actions { display: flex; gap: 8px; margin-top: 18px; }
    .commute-modal-actions button { flex: 1; padding: 12px; border: none; border-radius: 12px; font-size: 14px; font-weight: 600; cursor: pointer; min-height: 44px; }
    .commute-modal-cancel { background: var(--bg-secondary); color: var(--text-secondary); }
    .commute-modal-save { background: var(--accent-primary); color: #fff; }
    .commute-tag-prompt { position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%); background: var(--bg-card); border-radius: 16px; padding: 16px 20px; box-shadow: 0 8px 32px rgba(0,0,0,0.2); z-index: 999; max-width: 360px; width: calc(100% - 40px); animation: commuteSlideUp 0.3s ease; }
    .commute-tag-prompt-title { font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 10px; }
    .commute-tag-prompt-routes { display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 10px; }
    .commute-tag-prompt-btn { padding: 8px 14px; border: 1px solid var(--border-color); border-radius: 10px; background: var(--bg-secondary); color: var(--text-primary); font-size: 13px; font-weight: 500; cursor: pointer; min-height: 36px; transition: all 0.15s; }
    .commute-tag-prompt-btn:hover { border-color: var(--accent-primary); background: rgba(102, 126, 234, 0.08); }
    .commute-tag-prompt-later { font-size: 12px; color: var(--text-muted); cursor: pointer; text-align: center; }
    .commute-empty { text-align: center; padding: 40px 20px; color: var(--text-muted); }
    .commute-empty-icon { font-size: 48px; margin-bottom: 12px; }
    .commute-empty-text { font-size: 14px; margin-bottom: 16px; }
    .commute-add-btn { display: inline-flex; align-items: center; gap: 6px; padding: 10px 20px; background: var(--accent-primary); color: #fff; border: none; border-radius: 12px; font-size: 14px; font-weight: 600; cursor: pointer; min-height: 44px; }
    .commute-conditions-row { display: flex; gap: 6px; margin-top: 8px; }
    .commute-condition-btn { padding: 6px 12px; border: 1px solid var(--border-color); border-radius: 8px; background: var(--bg-secondary); font-size: 13px; cursor: pointer; min-height: 36px; transition: all 0.15s; }
    .commute-condition-btn.selected { border-color: var(--accent-primary); background: rgba(102, 126, 234, 0.1); color: var(--accent-primary); font-weight: 600; }
    @keyframes commuteSlideUp { from { transform: translateX(-50%) translateY(20px); opacity: 0; } to { transform: translateX(-50%) translateY(0); opacity: 1; } }
  </style>
</head>
<body>
  <div id="root"></div>

  <!-- 완료 애니메이션 오버레이 -->
  <div id="completion-overlay" class="completion-overlay">
    <div class="completion-content">
      <div class="completion-check">✓</div>
      <div class="completion-text">완료!</div>
      <div id="completion-streak" class="completion-streak"></div>
      <div id="completion-task-title" class="completion-task-title"></div>
    </div>
  </div>

  <!-- 파일 업로드용 히든 인풋 -->
  <input type="file" id="file-import" class="hidden-input" accept=".json">

  <!-- 실제 소요시간 입력 모달 -->
  <div id="time-input-modal" class="time-input-modal">
    <div class="time-input-header">
      <span class="time-input-title">⏱️ 실제로 얼마나 걸렸나요?</span>
      <button class="modal-close" onclick="closeTimeInputModal()">×</button>
    </div>
    <div class="time-input-options">
      <button class="time-option-btn" onclick="saveActualTime(2)">2분</button>
      <button class="time-option-btn" onclick="saveActualTime(5)">5분</button>
      <button class="time-option-btn" onclick="saveActualTime(10)">10분</button>
      <button class="time-option-btn" onclick="saveActualTime(15)">15분</button>
      <button class="time-option-btn" onclick="saveActualTime(20)">20분</button>
      <button class="time-option-btn" onclick="saveActualTime(30)">30분</button>
      <button class="time-option-btn" onclick="saveActualTime(45)">45분</button>
      <button class="time-option-btn" onclick="saveActualTime(60)">1시간</button>
    </div>
    <div class="time-input-custom">
      <input type="number" id="custom-time-input" placeholder="직접 입력 (분)" min="1" max="480">
      <button class="btn btn-primary" onclick="saveActualTime(parseInt(document.getElementById('custom-time-input').value))">저장</button>
      <button class="btn btn-secondary" onclick="closeTimeInputModal()">건너뛰기</button>
    </div>
  </div>

  <!-- 주간 리뷰 모달 -->
  <div id="weekly-review-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content weekly-review-modal">
      <div class="modal-header">
        <h2 id="weekly-review-title">📊 이번 주 리뷰</h2>
        <button class="modal-close" onclick="closeWeeklyReview()">×</button>
      </div>
      <div id="weekly-review-content" class="modal-body">
        <!-- 동적으로 채워짐 -->
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="closeWeeklyReview()">나중에</button>
        <button class="btn btn-primary" onclick="saveWeeklyPlan()">저장하기</button>
      </div>
    </div>
  </div>

  <!-- 본업 프로젝트 입력 모달 -->
  <div id="work-input-modal" class="work-modal">
    <div class="work-modal-content">
      <div class="work-modal-title" id="work-modal-title">새 프로젝트</div>
      <div id="work-modal-body">
        <!-- 동적으로 채워짐 -->
      </div>
      <div class="work-modal-actions">
        <button class="cancel" onclick="closeWorkModal()">취소</button>
        <button class="confirm" onclick="confirmWorkModal()">확인</button>
      </div>
    </div>
  </div>

  <!-- 빠른 수정 모달 (탭 이동 없이) -->
  <div id="quick-edit-modal" class="work-modal">
    <div class="work-modal-content" style="max-width: 400px;">
      <div class="work-modal-title">✏️ 작업 수정</div>
      <div id="quick-edit-body">
        <!-- 동적으로 채워짐 -->
      </div>
      <div class="work-modal-actions">
        <button class="cancel" onclick="closeQuickEditModal()">취소</button>
        <button class="confirm" onclick="saveQuickEdit()">저장</button>
      </div>
      <div style="text-align: center; margin-top: 12px;">
        <button class="btn-small" onclick="openFullEdit()" style="background: var(--bg-tertiary); color: var(--text-secondary);">
          📝 상세 편집으로 이동
        </button>
      </div>
    </div>
  </div>

  <!-- 키보드 단축키 도움말 (PC) -->
  <button class="shortcuts-toggle" onclick="toggleShortcutsHelp()" title="단축키 도움말">⌨️</button>
  <div id="shortcuts-help" class="shortcuts-help">
    <div class="shortcuts-help-title">
      <span>⌨️ 키보드 단축키</span>
      <button class="shortcuts-help-close" onclick="toggleShortcutsHelp()">×</button>
    </div>
    <div class="shortcut-item">
      <span class="shortcut-desc">새 작업 추가</span>
      <span class="shortcut-key">N</span>
    </div>
    <div class="shortcut-item">
      <span class="shortcut-desc">검색</span>
      <span class="shortcut-key">Ctrl+F</span>
    </div>
    <div class="shortcut-item">
      <span class="shortcut-desc">첫 Task 완료</span>
      <span class="shortcut-key">Ctrl+D</span>
    </div>
    <div class="shortcut-item">
      <span class="shortcut-desc">액션 탭</span>
      <span class="shortcut-key">1</span>
    </div>
    <div class="shortcut-item">
      <span class="shortcut-desc">업무 탭</span>
      <span class="shortcut-key">2</span>
    </div>
    <div class="shortcut-item">
      <span class="shortcut-desc">이벤트 탭</span>
      <span class="shortcut-key">3</span>
    </div>
    <div class="shortcut-item">
      <span class="shortcut-desc">대시보드 탭</span>
      <span class="shortcut-key">4</span>
    </div>
    <div class="shortcut-item">
      <span class="shortcut-desc">전체 탭</span>
      <span class="shortcut-key">5</span>
    </div>
    <div class="shortcut-item">
      <span class="shortcut-desc">기록 탭</span>
      <span class="shortcut-key">6</span>
    </div>
    <div class="shortcut-item">
      <span class="shortcut-desc">셔틀 토글</span>
      <span class="shortcut-key">S</span>
    </div>
    <div class="shortcut-item">
      <span class="shortcut-desc">도움말</span>
      <span class="shortcut-key">?</span>
    </div>
  </div>

  <script>
    // ============================================
    // 🔐 보안 유틸리티
    // ============================================

    /**
     * 고유 ID 생성 (crypto.randomUUID 기반)
     * Date.now() 대신 사용하여 브레인덤프 등 빠른 연속 생성 시 충돌 방지
     */
    function generateId() {
      return crypto.randomUUID();
    }

    /**
     * 기존 숫자 ID를 문자열로 마이그레이션 (하위 호환)
     * localStorage/Firebase에서 로드한 숫자 ID를 문자열로 변환
     */
    function migrateNumericIds() {
      // 태스크 ID 마이그레이션
      appState.tasks.forEach(t => {
        if (typeof t.id === 'number') t.id = String(t.id);
      });
      // 템플릿 ID 마이그레이션
      appState.templates.forEach(t => {
        if (typeof t.id === 'number') t.id = String(t.id);
      });
      // 본업 프로젝트 + 하위 항목 ID 마이그레이션
      appState.workProjects.forEach(p => {
        if (typeof p.id === 'number') p.id = String(p.id);
        (p.stages || []).forEach(stage => {
          (stage.subcategories || []).forEach(sub => {
            if (typeof sub.id === 'number') sub.id = String(sub.id);
            (sub.tasks || []).forEach(task => {
              if (typeof task.id === 'number') task.id = String(task.id);
            });
          });
        });
      });
      // 본업 템플릿 ID 마이그레이션
      (appState.workTemplates || []).forEach(t => {
        if (typeof t.id === 'number') t.id = String(t.id);
      });
      // 휴지통 ID 마이그레이션
      (appState.trash || []).forEach(t => {
        if (typeof t.id === 'number') t.id = String(t.id);
      });
      // activeWorkProject ID 마이그레이션
      if (typeof appState.activeWorkProject === 'number') {
        appState.activeWorkProject = String(appState.activeWorkProject);
      }
    }

    /**
     * XSS 방지: HTML 이스케이핑
     */
    function escapeHtml(text) {
      if (text === null || text === undefined) return '';
      const div = document.createElement('div');
      div.textContent = String(text);
      return div.innerHTML;
    }

    /**
     * localStorage에서 JSON을 안전하게 파싱
     */
    function safeParseJSON(key, defaultValue) {
      try {
        const data = localStorage.getItem(key);
        if (!data) return defaultValue;
        const parsed = JSON.parse(data);
        return parsed !== null ? parsed : defaultValue;
      } catch (e) {
        console.warn(`localStorage 파싱 실패 (${key}):`, e.message);
        return defaultValue;
      }
    }

    /**
     * 작업(Task) 데이터 검증
     */
    function validateTask(task) {
      if (!task || typeof task !== 'object') return null;

      // 필수 필드 검증
      if (typeof task.id !== 'number' && typeof task.id !== 'string') return null;
      if (typeof task.title !== 'string' || task.title.trim().length === 0) return null;

      // 안전한 객체 생성 (허용된 필드만)
      const validated = {
        id: task.id,
        title: String(task.title).trim().substring(0, 500),
        category: ['본업', '부업', '일상', '가족', '공부', '크립토'].includes(task.category) ? task.category : '일상',
        completed: Boolean(task.completed),
        completedAt: task.completedAt || null,
        deadline: typeof task.deadline === 'string' ? task.deadline : '',
        estimatedTime: Math.min(Math.max(0, Number(task.estimatedTime) || 0), 1440),
        actualTime: Math.min(Math.max(0, Number(task.actualTime) || 0), 1440),
        expectedRevenue: task.expectedRevenue || '',
        link: typeof task.link === 'string' ? task.link.substring(0, 2000) : '',
        tags: Array.isArray(task.tags) ? task.tags.filter(t => typeof t === 'string').slice(0, 20) : [],
        repeatType: ['none', 'daily', 'weekdays', 'weekends', 'weekly', 'custom', 'monthly'].includes(task.repeatType) ? task.repeatType : 'none',
        repeatDays: Array.isArray(task.repeatDays) ? task.repeatDays.filter(d => Number.isInteger(d) && d >= 0 && d <= 6) : [],
        createdAt: task.createdAt || new Date().toISOString(),
        priority: typeof task.priority === 'number' ? Math.min(Math.max(0, task.priority), 100) : 0,
        // 동기화 시 소실 방지: 추가 필드 보존
        updatedAt: task.updatedAt || task.completedAt || task.createdAt || new Date().toISOString()
      };

      // 선택적 필드 보존 (본업 프로젝트 관련)
      if (task.workProjectId) validated.workProjectId = task.workProjectId;
      if (typeof task.workStageIdx === 'number') validated.workStageIdx = task.workStageIdx;
      if (typeof task.workSubcatIdx === 'number') validated.workSubcatIdx = task.workSubcatIdx;
      if (Array.isArray(task.subtasks)) validated.subtasks = task.subtasks;
      if (task.organizer) validated.organizer = task.organizer;
      if (task.eventType) validated.eventType = task.eventType;
      if (task.repeatMonthDay) validated.repeatMonthDay = task.repeatMonthDay;
      if (task.lastCompletedAt) validated.lastCompletedAt = task.lastCompletedAt;
      if (task.source) validated.source = task.source;

      return validated;
    }

    /**
     * 작업 배열 검증
     */
    function validateTasks(tasks) {
      if (!Array.isArray(tasks)) return [];
      return tasks.map(validateTask).filter(t => t !== null);
    }

    /**
     * 오늘 통계 재계산 (중복 코드 방지)
     */
    function recomputeTodayStats() {
      const today = new Date().toDateString();
      appState.todayStats.completedToday = appState.tasks.filter(t => {
        if (!t.completed || !t.completedAt) return false;
        return new Date(t.completedAt).toDateString() === today;
      }).length;
    }

    /**
     * 완료 스트릭 계산 — completionLog 기반 연속 완료일 수
     * dayStartHour 반영: 새벽 완료는 전날로 간주
     */
    function calculateCompletionStreak() {
      const log = appState.completionLog || {};
      const dayStartHour = appState.settings?.dayStartHour || 5;

      // 논리적 오늘 계산
      const now = new Date();
      let logicalToday = new Date(now);
      if (now.getHours() < dayStartHour) {
        logicalToday.setDate(logicalToday.getDate() - 1);
      }

      let streak = 0;
      let checkDate = new Date(logicalToday);

      // 오늘 완료가 있으면 오늘부터, 없으면 어제부터 카운트
      const todayStr = getLocalDateStr(checkDate);
      const todayEntries = log[todayStr];
      const hasTodayCompletion = todayEntries && Array.isArray(todayEntries) && todayEntries.length > 0;

      if (!hasTodayCompletion) {
        // 오늘 완료 없으면 어제부터 체크 (스트릭 유지 가능)
        checkDate.setDate(checkDate.getDate() - 1);
      }

      // 연속 완료일 카운트
      for (let i = 0; i < 365; i++) {
        const dateStr = getLocalDateStr(checkDate);
        const entries = log[dateStr];
        if (entries && Array.isArray(entries) && entries.length > 0) {
          streak++;
          checkDate.setDate(checkDate.getDate() - 1);
        } else if (entries && entries._summary && entries.count > 0) {
          // 압축된 데이터
          streak++;
          checkDate.setDate(checkDate.getDate() - 1);
        } else {
          break;
        }
      }

      return { streak, hasTodayCompletion };
    }

    /**
     * 스트릭 배지 텍스트 반환
     */
    function getStreakBadge(streak) {
      if (streak >= 30) return '🏆 30일+';
      if (streak >= 14) return '⭐ 14일+';
      if (streak >= 7) return '💪 7일+';
      return '';
    }

    /**
     * 오늘 완료된 태스크만 필터링 (UI 표시용)
     * 히스토리/캘린더/수익 통계와 무관하게, 탭의 "완료됨" 섹션에 오늘 것만 표시
     */
    function getTodayCompletedTasks(tasks) {
      const today = new Date().toDateString();
      return tasks.filter(t => {
        if (!t.completed || !t.completedAt) return false;
        return new Date(t.completedAt).toDateString() === today;
      });
    }

    /**
     * 오래된 완료 태스크 자동 정리
     * - 반복 태스크: 7일 경과 시 제거 (이미 다음 회차 생성됨)
     * - 비반복 태스크: 30일 경과 시 제거
     * - 히스토리/캘린더는 별도 데이터를 사용하지 않으므로,
     *   정리 후에도 해당 기간 내 데이터는 유지됨
     */
    function cleanupOldCompletedTasks() {
      const now = Date.now();
      const SEVEN_DAYS = 7 * 24 * 60 * 60 * 1000;
      const THIRTY_DAYS = 30 * 24 * 60 * 60 * 1000;

      const before = appState.tasks.length;
      appState.tasks = appState.tasks.filter(t => {
        if (!t.completed || !t.completedAt) return true; // 미완료 태스크는 유지
        const elapsed = now - new Date(t.completedAt).getTime();
        // 반복 태스크: 7일 후 제거
        if (t.repeatType && t.repeatType !== 'none') {
          return elapsed < SEVEN_DAYS;
        }
        // 비반복 태스크: 30일 후 제거
        return elapsed < THIRTY_DAYS;
      });

      const removed = before - appState.tasks.length;
      if (removed > 0) {
        console.log(`[cleanup] 오래된 완료 태스크 ${removed}개 정리됨`);
      }
      return removed;
    }

    /**
     * 논리적 날짜 계산 (하루 시작 시각 기반)
     * 설정된 dayStartHour(기본 05:00) 이전이면 아직 "어제"로 취급
     * → 새벽 1시에 활동해도 리셋되지 않음, 5시 이후에 리셋됨
     */
    function getLogicalDate(d) {
      const dt = d || new Date();
      const dayStartHour = (appState.settings && appState.settings.dayStartHour) || 5;

      if (dt.getHours() < dayStartHour) {
        // 하루 시작 시각 이전 → 아직 "어제"
        const adjusted = new Date(dt);
        adjusted.setDate(adjusted.getDate() - 1);
        return getLocalDateStr(adjusted);
      }
      return getLocalDateStr(dt);
    }

    /**
     * 반복 태스크 일일 초기화 (논리적 날짜 변경 시 자동 실행)
     * - dayStartHour(기본 05:00) 기준으로 "하루"를 판단
     * - daily/weekdays 태스크: 완료 상태를 리셋하여 매일 새로 시작
     * - weekdays 태스크: 주말에는 초기화하지 않음 (금요일 완료 → 월요일에 리셋)
     * - 기존 createNextRepeatTask로 생긴 중복 태스크도 정리
     * - 스트릭: 어제 모든 반복 태스크 완료 시 유지, 아니면 리셋
     * - 트리거: 앱 로딩, visibilitychange, setInterval(1분), 기상 버튼
     */
    function checkDailyReset() {
      const now = new Date();
      const dayStartHour = (appState.settings && appState.settings.dayStartHour) || 5;

      // 하루 시작 시각 이전이면 리셋하지 않음 (새벽 활동 보호)
      if (now.getHours() < dayStartHour) return false;

      const logicalToday = getLogicalDate();
      const lastResetDate = localStorage.getItem('navigator-last-reset-date');

      if (lastResetDate === logicalToday) return false; // 이미 오늘 초기화됨

      // 논리적 "오늘"의 요일 (dayStartHour 이후이므로 now의 요일이 정확)
      const todayDay = now.getDay(); // 0=일, 6=토
      const isWeekday = todayDay !== 0 && todayDay !== 6;

      let changed = false;

      // 1단계: 반복 태스크 완료 상태 초기화
      appState.tasks.forEach(task => {
        if (task.repeatType !== 'daily' && task.repeatType !== 'weekdays') return;

        // weekdays 태스크: 주말(토/일)에는 초기화하지 않음
        if (task.repeatType === 'weekdays' && !isWeekday) return;

        if (task.completed && task.completedAt) {
          // 완료 시점의 논리적 날짜와 오늘의 논리적 날짜 비교
          const completedLogicalDate = getLogicalDate(new Date(task.completedAt));
          if (completedLogicalDate !== logicalToday) {
            // 이전 논리적 날짜에 완료된 태스크 → 초기화
            task.lastCompletedAt = task.completedAt; // 히스토리 보존
            task.completed = false;
            task.completedAt = null;
            task.updatedAt = new Date().toISOString();
            changed = true;
          }
        }
      });

      // 2단계: 중복 반복 태스크 정리 (같은 제목+카테고리+반복타입 태스크가 여러 개면 하나만 남김)
      // 완료 여부 상관없이 중복 정리하되, 완료된 것을 우선 유지
      const seen = new Map();
      const toRemove = [];

      appState.tasks.forEach(task => {
        if (task.repeatType !== 'daily' && task.repeatType !== 'weekdays') return;

        const key = `${task.title}|${task.repeatType}|${task.category}`;
        if (seen.has(key)) {
          // 중복 발견: 우선순위 결정 (완료된 것 > 미완료 / 최신 생성)
          const existing = seen.get(key);

          // 완료 상태 우선 비교
          if (task.completed && !existing.completed) {
            // 현재 태스크가 완료됨 → 기존 것 제거
            toRemove.push(existing.id);
            seen.set(key, task);
          } else if (!task.completed && existing.completed) {
            // 기존 것이 완료됨 → 현재 것 제거
            toRemove.push(task.id);
          } else {
            // 둘 다 같은 상태 → 더 최근에 생성된 것 유지
            const existingTime = new Date(existing.createdAt || 0).getTime();
            const currentTime = new Date(task.createdAt || 0).getTime();
            if (currentTime > existingTime) {
              toRemove.push(existing.id);
              seen.set(key, task);
            } else {
              toRemove.push(task.id);
            }
          }
        } else {
          seen.set(key, task);
        }
      });

      if (toRemove.length > 0) {
        appState.tasks = appState.tasks.filter(t => !toRemove.includes(t.id));
        changed = true;
        console.log(`[daily-reset] 중복 반복 태스크 ${toRemove.length}개 정리`);
      }

      // 3단계: 반복 태스크 스트릭 체크 (어제 모든 반복 태스크 완료 여부)
      if (lastResetDate) {
        checkDailyRepeatStreak();
      }

      localStorage.setItem('navigator-last-reset-date', logicalToday);

      if (changed) {
        console.log(`[daily-reset] 반복 태스크 초기화 완료 (하루 시작: ${dayStartHour}시)`);
      }

      return changed;
    }

    /**
     * 반복 태스크 스트릭 체크
     * 어제(논리적) 모든 daily/weekdays 태스크를 완료했으면 스트릭 유지, 아니면 리셋
     */
    function checkDailyRepeatStreak() {
      // "어제"를 논리적 날짜로 계산 (dayStartHour 기준)
      const logicalToday = getLogicalDate();
      const todayDate = new Date(logicalToday + 'T12:00:00'); // 정오 기준으로 Date 생성
      const yesterdayDate = new Date(todayDate);
      yesterdayDate.setDate(yesterdayDate.getDate() - 1);
      const yesterdayStr = getLocalDateStr(yesterdayDate);
      const yesterdayDay = yesterdayDate.getDay();
      const wasWeekday = yesterdayDay !== 0 && yesterdayDay !== 6;

      // daily + weekdays(어제가 평일인 경우만) 태스크 필터링
      const repeatTasks = appState.tasks.filter(t => {
        if (t.repeatType === 'daily') return true;
        if (t.repeatType === 'weekdays' && wasWeekday) return true;
        return false;
      });

      if (repeatTasks.length === 0) return; // 반복 태스크 없으면 무시

      // 어제 모든 반복 태스크가 완료되었는지 확인
      // (lastCompletedAt 또는 completedAt의 논리적 날짜가 어제인지)
      const allCompleted = repeatTasks.every(t => {
        const completedDateRaw = t.lastCompletedAt || t.completedAt;
        if (!completedDateRaw) return false;
        return getLogicalDate(new Date(completedDateRaw)) === yesterdayStr;
      });

      if (!allCompleted) {
        // 어제 반복 태스크를 전부 완료하지 못함 → 스트릭 리셋
        appState.streak.current = 0;
        if (!appState.user) {
          localStorage.setItem('navigator-streak', JSON.stringify(appState.streak));
        }
        console.log('[daily-reset] 어제 미완료 반복 태스크 있음 → 스트릭 리셋');
      }
    }

    // ============================================
    // 이벤트 탭 UI 상태 (비영속적 — 새로고침 시 초기화)
    // ============================================
    let _eventBulkSelectMode = false;
    const _eventBulkSelectedIds = new Set();
    const _collapsedEventGroups = new Set(); // 접힌 그룹 ID

    // ============================================
    // 앱 상태 관리
    // ============================================

    /**
     * @typedef {Object} Subtask
     * @property {string} text - 서브태스크 내용
     * @property {boolean} completed - 완료 여부
     */

    /**
     * @typedef {Object} Task
     * @property {string} id - 고유 ID (crypto.randomUUID, 레거시: 숫자→문자열 마이그레이션)
     * @property {string} title - 작업 제목
     * @property {'본업'|'부업'|'일상'|'가족'} category - 카테고리
     * @property {boolean} completed - 완료 여부
     * @property {string} [startDate] - 시작일 (YYYY-MM-DD)
     * @property {string} [deadline] - 마감일 (YYYY-MM-DD)
     * @property {number} [estimatedTime] - 예상 소요시간 (분)
     * @property {number|null} [actualTime] - 실제 소요시간 (분)
     * @property {string} [link] - 관련 링크 URL
     * @property {string|number} [expectedRevenue] - 예상 수익 (원)
     * @property {string} [description] - 작업 설명/메모
     * @property {'none'|'daily'|'weekdays'|'weekends'|'weekly'|'custom'|'monthly'} [repeatType] - 반복 유형
     * @property {number[]} [repeatDays] - 특정 요일 반복 시 요일 배열 (0=일 ~ 6=토)
     * @property {number|null} [repeatMonthDay] - 매월 반복 시 날짜 (1~31)
     * @property {string} [organizer] - 주최자 (부업용)
     * @property {string} [eventType] - 이벤트 종류 (부업용)
     * @property {string[]} [tags] - 태그 목록
     * @property {Subtask[]} [subtasks] - 서브태스크 목록
     * @property {string|null} [workProjectId] - 본업 프로젝트 연결 ID
     * @property {number|null} [workStageIdx] - 본업 단계 인덱스
     * @property {number|null} [workSubcatIdx] - 본업 중분류 인덱스
     * @property {string} createdAt - 생성 시각 (ISO 8601)
     * @property {string} updatedAt - 수정 시각 (ISO 8601)
     * @property {string} [completedAt] - 완료 시각 (ISO 8601)
     * @property {number} [priority] - 정렬 우선순위
     * @property {string} [deletedAt] - 삭제 시각 (휴지통용, ISO 8601)
     * @property {string} [telegramEventId] - 텔레그램 이벤트 연동 ID
     */

    /**
     * @typedef {Object} WorkTask
     * @property {string} title - 작업 제목
     * @property {'not-started'|'in-progress'|'done'} status - 진행 상태
     * @property {Array<{date: string, text: string}>} logs - 작업 로그
     * @property {string} createdAt - 생성 시각 (ISO 8601)
     * @property {number} [goal] - 목표 수량
     * @property {number} [count] - 현재 수량
     */

    /**
     * @typedef {Object} WorkSubcategory
     * @property {string} id - 고유 ID
     * @property {string} name - 중분류 이름
     * @property {WorkTask[]} tasks - 하위 작업 목록
     */

    /**
     * @typedef {Object} WorkStage
     * @property {string} name - 단계 이름 (준비/설계/진행/점검/실행/마무리)
     * @property {boolean} completed - 단계 완료 여부
     * @property {WorkSubcategory[]} subcategories - 중분류 목록
     * @property {string|null} startDate - 단계 시작일
     * @property {string|null} endDate - 단계 종료일
     */

    /**
     * @typedef {Object} WorkProject
     * @property {string} id - 고유 ID
     * @property {string} name - 프로젝트 이름
     * @property {number} currentStage - 현재 단계 인덱스
     * @property {string|null} deadline - 마감일 (YYYY-MM-DD)
     * @property {WorkStage[]} stages - 단계 목록
     * @property {string} createdAt - 생성 시각 (ISO 8601)
     * @property {string} updatedAt - 수정 시각 (ISO 8601)
     * @property {boolean} [archived] - 아카이브 여부
     */

    /**
     * @typedef {Object} CompletionLogEntry
     * @property {string} t - 작업 제목 (title)
     * @property {string} c - 카테고리 (category)
     * @property {string} at - 완료 시각 (HH:MM)
     * @property {string} [r] - 반복 유형 (repeatType, none이 아닌 경우만)
     * @property {number} [rv] - 수익 (revenue)
     * @property {number} [st] - 완료된 서브태스크 수
     */

    /**
     * @typedef {Object} CommuteRoute
     * @property {string} id - 고유 ID ('route-' 접두사 + UUID)
     * @property {string} name - 루트 이름
     * @property {'morning'|'evening'|'both'} type - 출퇴근 유형
     * @property {string} [description] - 루트 설명
     * @property {number} expectedDuration - 예상 소요시간 (분)
     * @property {string} color - 표시 색상 (hex)
     * @property {boolean} isActive - 활성 여부
     * @property {string} createdAt - 생성 시각 (ISO 8601)
     */

    /**
     * @typedef {Object} CommuteTrip
     * @property {string} routeId - 사용한 루트 ID
     * @property {string} [departTime] - 출발 시각 (HH:MM)
     * @property {string} [arriveTime] - 도착 시각 (HH:MM)
     * @property {number|null} duration - 소요시간 (분)
     * @property {'clear'|'rain'|'snow'|'delay'} conditions - 교통 상황
     */

    /**
     * @typedef {Object} MedicationSlot
     * @property {string} id - 슬롯 ID (예: 'med_morning')
     * @property {string} label - 표시 이름
     * @property {string} icon - 이모지 아이콘
     * @property {boolean} required - 필수 복약 여부
     */

    /**
     * @typedef {Object} LifeRhythmDay
     * @property {string|null} date - 날짜 (YYYY-MM-DD)
     * @property {string|null} wakeUp - 기상 시간 (HH:MM)
     * @property {string|null} homeDepart - 집 출발 시간
     * @property {string|null} workArrive - 회사 도착 시간
     * @property {string|null} workDepart - 회사 출발 시간
     * @property {string|null} homeArrive - 집 도착 시간
     * @property {string|null} sleep - 취침 시간
     * @property {Object<string, string|null>} medications - 복약 기록 { slotId: 'HH:MM' | null }
     */

    /**
     * @typedef {Object} AppState
     * @property {'action'|'schedule'|'all'|'work'|'more'} currentTab - 현재 활성 탭
     * @property {boolean} shuttleSuccess - 셔틀 탑승 여부
     * @property {Task[]} tasks - 모든 작업 목록
     * @property {boolean} showDetailedAdd - 상세 추가 폼 표시 여부
     * @property {boolean} showTaskList - 작업 리스트 표시 여부
     * @property {boolean} showCompletedTasks - 완료된 작업 표시 여부
     * @property {string} quickAddValue - 빠른 추가 입력값
     *
     * @property {Object} detailedTask - 상세 추가/수정용 임시 데이터
     * @property {string} detailedTask.title
     * @property {'본업'|'부업'|'일상'|'가족'} detailedTask.category
     * @property {string} detailedTask.startDate
     * @property {string} detailedTask.deadline
     * @property {number} detailedTask.estimatedTime
     * @property {string} detailedTask.link
     * @property {string} detailedTask.expectedRevenue
     * @property {string} detailedTask.description
     * @property {string} detailedTask.repeatType
     * @property {number[]} detailedTask.repeatDays
     * @property {number|null} detailedTask.repeatMonthDay
     * @property {string} detailedTask.organizer
     * @property {string} detailedTask.eventType
     * @property {string[]} detailedTask.tags
     * @property {Subtask[]} detailedTask.subtasks
     * @property {string|null} detailedTask.workProjectId
     * @property {number|null} detailedTask.workStageIdx
     * @property {number|null} detailedTask.workSubcatIdx
     *
     * @property {string[]} availableTags - 사용 가능한 태그 목록
     * @property {string|null} editingTaskId - 수정 중인 작업 ID
     * @property {string|null} quickEditTaskId - 빠른 수정 모달용 작업 ID
     * @property {Object|null} touchStart - 스와이프 시작 지점
     * @property {string|null} touchingTaskId - 스와이프 중인 작업 ID
     * @property {'default'|'granted'|'denied'} notificationPermission - 알림 권한 상태
     * @property {'all'|'weekday'|'weekend'|'today'} scheduleFilter - 일정 필터
     * @property {string} searchQuery - 검색어
     * @property {'all'|'본업'|'부업'|'일상'|'가족'} categoryFilter - 카테고리 필터
     * @property {string|null} tagFilter - 태그 필터
     * @property {Object<string, boolean>} showCompletedByCategory - 카테고리별 완료 작업 표시 여부
     * @property {'dark'|'light'} theme - 테마
     * @property {string|null} draggedTaskId - 드래그 중인 작업 ID
     * @property {boolean} focusMode - 포커스 모드
     *
     * @property {Object} streak - 연속 달성 기록
     * @property {number} streak.current - 현재 연속일
     * @property {number} streak.best - 최고 연속일
     * @property {string|null} streak.lastActiveDate - 마지막 활동 날짜
     *
     * @property {boolean} showOnboarding - 온보딩 모달 표시
     * @property {boolean} moreMenuOpen - 더보기 메뉴 열림 상태
     *
     * @property {Object} pomodoro - 포모도로 상태
     * @property {boolean} pomodoro.isRunning
     * @property {boolean} pomodoro.isBreak
     * @property {number} pomodoro.timeLeft - 남은 시간 (초)
     * @property {number} pomodoro.workDuration - 작업 시간 (초, 기본 25분)
     * @property {number} pomodoro.breakDuration - 휴식 시간 (초, 기본 5분)
     * @property {number} pomodoro.completedPomodoros - 완료한 포모도로 수
     * @property {string|null} pomodoro.currentTaskId - 현재 작업 중인 태스크 ID
     *
     * @property {Object} todayStats - 오늘의 진행 상황
     * @property {number} todayStats.completedToday - 오늘 완료한 작업 수
     * @property {number} todayStats.streak - 연속 완료 (세션 내)
     * @property {string|null} todayStats.lastCompletedDate - 마지막 완료 날짜
     *
     * @property {Object} lifeRhythm - 라이프 리듬 트래커
     * @property {LifeRhythmDay} lifeRhythm.today - 오늘 기록
     * @property {Object<string, LifeRhythmDay>} lifeRhythm.history - 날짜별 기록
     * @property {Object} lifeRhythm.settings - 설정
     * @property {number} lifeRhythm.settings.targetSleep - 목표 수면 시간
     * @property {number[]} lifeRhythm.settings.workdays - 근무일 (0=일 ~ 6=토)
     * @property {MedicationSlot[]} lifeRhythm.settings.medicationSlots - 복약 슬롯 목록
     *
     * @property {Object} commuteTracker - 통근 트래커
     * @property {CommuteRoute[]} commuteTracker.routes - 루트 목록
     * @property {Object<string, Object<string, CommuteTrip>>} commuteTracker.trips - 날짜별/방향별 통근 기록
     * @property {Object} commuteTracker.settings - 통근 설정
     * @property {string} commuteTracker.settings.targetArrivalTime - 목표 도착 시각
     * @property {number} commuteTracker.settings.bufferMinutes - 여유 시간 (분)
     * @property {string|null} commuteTracker.settings.preferredMorningRoute - 선호 출근 루트 ID
     * @property {string|null} commuteTracker.settings.preferredEveningRoute - 선호 퇴근 루트 ID
     * @property {boolean} commuteTracker.settings.enableAutoTag - 자동 태그 활성화
     *
     * @property {'morning'|'evening'} commuteSubTab - 통근 서브탭
     * @property {string|null} commuteRouteModal - 루트 모달 상태 ('add' | routeId | null)
     * @property {Object<string, string>} commuteSelectedRoute - 방향별 선택 루트 ID
     *
     * @property {Object} historyState - 히스토리/캘린더 상태
     * @property {number} historyState.viewingYear
     * @property {number} historyState.viewingMonth
     * @property {string|null} historyState.selectedDate - 선택된 날짜 (YYYY-MM-DD)
     * @property {Object<string, boolean>} historyState.expandedDates - 펼쳐진 날짜 그룹
     * @property {'tasks'|'rhythm'} historyView - 히스토리 뷰 모드
     *
     * @property {Object} settings - 사용자 설정
     * @property {string} settings.targetWakeTime - 목표 기상 시간 (HH:MM)
     * @property {string} settings.targetBedtime - 목표 취침 시간 (HH:MM)
     * @property {string} settings.workStartTime - 출근 시간 (HH:MM)
     * @property {string} settings.workEndTime - 퇴근 시간 (HH:MM)
     * @property {number} settings.dailyGoal - 일일 목표 (완료 작업 수)
     * @property {number} settings.weeklyGoal - 주간 목표
     * @property {boolean} settings.bedtimeReminder - 취침 알림 활성화
     * @property {number} settings.bedtimeReminderMinutes - 취침 알림 (N분 전)
     * @property {number} settings.dayStartHour - 하루 시작 시각 (기본 5)
     *
     * @property {Task[]} templates - 작업 템플릿 목록
     * @property {boolean} showSettings - 설정 모달 표시
     * @property {boolean} hideSwipeHint - 스와이프 힌트 숨기기
     *
     * @property {Object} quickTimer - ADHD 퀵 타이머
     * @property {boolean} quickTimer.isRunning
     * @property {number} quickTimer.timeLeft - 남은 시간 (초)
     * @property {string|null} quickTimer.taskId - 연결된 작업 ID
     *
     * @property {boolean} showCelebration - 축하 효과 표시
     * @property {string} lastMotivation - 마지막 동기부여 메시지
     * @property {Object<string, boolean>} expandedSubtasks - 펼쳐진 서브태스크 목록
     *
     * @property {Object} weeklyPlan - 주간 계획
     * @property {string[]} weeklyPlan.focusTasks - 이번 주 집중 작업 ID (최대 3개)
     * @property {string|null} weeklyPlan.lastReviewDate
     * @property {string|null} weeklyPlan.lastReminderDate
     * @property {boolean} weeklyPlan.dismissed
     *
     * @property {string|null} quickFilter - 퀵 필터 ('2min'|'5min'|'urgent'|null)
     * @property {Object|null} pendingTimeInput - 실제 소요시간 입력 대기 작업
     *
     * @property {WorkProject[]} workProjects - 업무 프로젝트 목록
     * @property {string|null} activeWorkProject - 현재 선택된 프로젝트 ID
     * @property {string[]} workProjectStages - 기본 단계 이름 목록
     * @property {'dashboard'|'detail'} workView - 본업 뷰 모드
     * @property {Object[]} workTemplates - 저장된 본업 템플릿 목록
     * @property {boolean} showArchivedProjects - 아카이브 프로젝트 표시 여부
     *
     * @property {Object|null} user - 로그인한 Firebase 사용자
     * @property {'offline'|'syncing'|'synced'|'error'} syncStatus - 동기화 상태
     * @property {string|null} lastSyncTime - 마지막 동기화 시간
     *
     * @property {Object<string, CompletionLogEntry[]>} completionLog - 날짜별 완료 기록
     *
     * @property {Object} deletedIds - Soft-Delete 추적 (동기화 시 오판 방지)
     * @property {Object<string, string>} deletedIds.tasks - { taskId: 삭제시각 }
     * @property {Object<string, string>} deletedIds.workProjects
     * @property {Object<string, string>} deletedIds.templates
     * @property {Object<string, string>} deletedIds.workTemplates
     *
     * @property {Task[]} trash - 삭제된 태스크 보관 (30일 후 자동 정리)
     */
    /** @type {AppState} */
    const appState = {
      currentTab: 'action',           // 현재 활성 탭
      shuttleSuccess: false,          // 셔틀 탑승 여부
      tasks: [],                      // 모든 작업 목록
      showDetailedAdd: false,         // 상세 추가 폼 표시 여부
      showTaskList: true,             // 작업 리스트 표시 여부
      showCompletedTasks: false,      // 완료된 작업 표시 여부
      quickAddValue: '',              // 빠른 추가 입력값
      detailedTask: {                 // 상세 추가/수정용 임시 데이터
        title: '',
        category: '부업',
        startDate: '',                // 시작일 (일정 범위 표시용)
        deadline: '',
        estimatedTime: 10,
        link: '',
        expectedRevenue: '',
        description: '',              // 작업 설명/메모
        repeatType: 'none',           // 반복 유형: none/daily/weekdays/weekends/weekly/custom/monthly
        repeatDays: [],               // 특정 요일 반복 시 요일 배열 (0=일, 1=월, ... 6=토)
        repeatMonthDay: null,         // 매월 반복 시 날짜 (1~31)
        organizer: '',                // 주최자 (부업용): 불개미, 코같투, 맨틀 등
        eventType: '',                // 이벤트 종류 (부업용): 의견작성, 리캡, AMA 등
        tags: [],                     // 태그 목록
        subtasks: [],                 // 서브태스크 목록
        workProjectId: null,          // 본업 프로젝트 연결 ID
        workStageIdx: null,           // 본업 단계 인덱스
        workSubcatIdx: null           // 본업 중분류 인덱스
      },
      availableTags: ['긴급', '회의', '전화', '외출', '대기중', '검토필요'],  // 사용 가능한 태그
      editingTaskId: null,            // 수정 중인 작업 ID (null이면 새로 추가)
      quickEditTaskId: null,          // 빠른 수정 모달용 작업 ID
      touchStart: null,               // 스와이프 시작 지점
      touchingTaskId: null,           // 스와이프 중인 작업 ID
      notificationPermission: 'default', // 알림 권한 상태
      scheduleFilter: 'all',          // 일정 필터: all/weekday/weekend/today
      searchQuery: '',                // 검색어
      categoryFilter: 'all',          // 카테고리 필터: all/본업/부업/일상/가족
      tagFilter: null,                 // 태그 필터: null이면 전체
      showCompletedByCategory: {},     // 전체 탭에서 카테고리별 완료 작업 표시 여부
      theme: 'dark',                   // 테마: dark/light
      draggedTaskId: null,             // 드래그 중인 작업 ID
      focusMode: false,                // 포커스 모드 (한 번에 하나만)
      streak: {                        // 연속 달성 기록
        current: 0,
        best: 0,
        lastActiveDate: null
      },
      showOnboarding: false,           // 온보딩 모달 표시
      moreMenuOpen: false,             // 더보기 메뉴 열림 상태
      // 포모도로 상태
      pomodoro: {
        isRunning: false,
        isBreak: false,
        timeLeft: 25 * 60,            // 25분 (초)
        workDuration: 25 * 60,        // 작업 시간
        breakDuration: 5 * 60,        // 휴식 시간
        completedPomodoros: 0,        // 완료한 포모도로 수
        currentTaskId: null           // 현재 작업 중인 태스크
      },
      // 오늘의 진행 상황
      todayStats: {
        completedToday: 0,            // 오늘 완료한 작업 수
        streak: 0,                    // 연속 완료 (세션 내)
        lastCompletedDate: null       // 마지막 완료 날짜
      },
      // 라이프 리듬 트래커 (6개 항목 + 복약)
      lifeRhythm: {
        today: {
          date: null,                 // 오늘 날짜 (YYYY-MM-DD)
          wakeUp: null,               // 기상 시간 (HH:MM)
          homeDepart: null,           // 집 출발 시간
          workArrive: null,           // 회사 도착 시간
          workDepart: null,           // 회사 출발 시간
          homeArrive: null,           // 집 도착 시간
          sleep: null,                // 취침 시간
          medications: {}             // 복약 기록 { slotId: 'HH:MM' or null }
        },
        history: {},                  // 날짜별 기록
        settings: {
          targetSleep: 7,             // 목표 수면 시간
          workdays: [1, 2, 3, 4, 5],  // 근무일 (0=일, 1=월, ... 6=토)
          medicationSlots: [
            { id: 'med_morning', label: 'ADHD약(아침)', icon: '💊', required: true },
            { id: 'med_afternoon_adhd', label: 'ADHD약(점심)', icon: '💊', required: true },
            { id: 'med_afternoon_nutrient', label: '영양제(점심)', icon: '🌿', required: false },
            { id: 'med_evening', label: '영양제(저녁)', icon: '🌿', required: false }
          ]
        }
      },
      // 통근 트래커
      commuteTracker: {
        routes: [],
        trips: {},
        settings: {
          targetArrivalTime: '09:00',
          bufferMinutes: 10,
          preferredMorningRoute: null,
          preferredEveningRoute: null,
          enableAutoTag: true
        }
      },
      commuteSubTab: 'morning',
      commuteRouteModal: null,
      commuteSelectedRoute: {},
      // 히스토리/캘린더 상태
      historyState: {
        viewingYear: new Date().getFullYear(),
        viewingMonth: new Date().getMonth(),
        selectedDate: null,           // 선택된 날짜 (YYYY-MM-DD)
        expandedDates: {}             // 펼쳐진 날짜 그룹
      },
      historyView: 'tasks',           // 히스토리 뷰: tasks / rhythm
      // 사용자 설정
      settings: {
        targetWakeTime: '07:00',      // 목표 기상 시간
        targetBedtime: '23:00',       // 목표 취침 시간
        workStartTime: '11:00',       // 출근 시간 (회사 모드 시작)
        workEndTime: '20:00',         // 퇴근 시간 (회사 모드 끝)
        dailyGoal: 5,                 // 일일 목표 (완료 작업 수)
        weeklyGoal: 25,               // 주간 목표 (완료 작업 수)
        bedtimeReminder: true,        // 취침 알림 활성화
        bedtimeReminderMinutes: 30,   // 취침 몇 분 전 알림
        dayStartHour: 5               // 하루 시작 시각 (이 시각 이후 반복 태스크 리셋, 기본 05:00)
      },
      templates: [],                    // 작업 템플릿 목록
      showSettings: false,             // 설정 모달 표시
      hideSwipeHint: false,            // 스와이프 힌트 숨기기
      // ADHD 특화 기능
      quickTimer: {
        isRunning: false,
        timeLeft: 5 * 60,              // 5분 (초)
        taskId: null                    // 타이머와 연결된 작업 ID
      },
      showCelebration: false,          // 축하 효과 표시
      lastMotivation: '',              // 마지막 동기부여 메시지
      expandedSubtasks: {},             // 펼쳐진 서브태스크 목록 (taskId: true/false)
      // 주간 계획
      weeklyPlan: {
        focusTasks: [],                   // 이번 주 집중할 작업 ID 목록 (최대 3개)
        lastReviewDate: null,             // 마지막 주간 리뷰 날짜
        lastReminderDate: null,           // 마지막 월요일 리마인더 날짜
        dismissed: false                  // 이번 주 리마인더 닫음 여부
      },
      quickFilter: null,                  // 퀵 필터: null, '2min', '5min', 'urgent'
      pendingTimeInput: null,             // 실제 소요시간 입력 대기 중인 작업
      // 본업 프로젝트 관리
      workProjects: [],                   // 업무 프로젝트 목록
      activeWorkProject: null,            // 현재 선택된 프로젝트 ID
      workProjectStages: ['준비', '설계', '진행', '점검', '실행', '마무리'],
      workView: 'dashboard',              // 뷰 모드: 'dashboard' | 'detail'
      workTemplates: [],                  // 저장된 템플릿 목록
      showArchivedProjects: false,        // 아카이브 프로젝트 표시 여부
      // Firebase 동기화
      user: null,                       // 로그인한 사용자
      syncStatus: 'offline',            // 동기화 상태: offline/syncing/synced/error
      lastSyncTime: null,               // 마지막 동기화 시간
      // 태스크 완료 영구 기록 (날짜별)
      // { "2026-02-05": [{ t, c, at, r?, rv?, st? }], ... }
      completionLog: {},
      // Soft-Delete 추적: 삭제된 항목의 ID + 삭제 시각 기록
      // 다른 기기에서 동기화 시 "로컬에만 있음 = 새 항목" 오판 방지
      deletedIds: {
        tasks: {},          // { "task-uuid": "2026-02-05T..." }
        workProjects: {},
        templates: {},
        workTemplates: {}
      },
      // 휴지통: 삭제된 태스크 보관 (30일 후 자동 정리)
      trash: []
    };

    // ============================================
    // 로컬스토리지 관리
    // ============================================
    
    /**
     * 로컬스토리지에서 데이터 로드
     * 에러 처리 포함
     */
    function loadState() {
      try {
        const savedTasks = localStorage.getItem('navigator-tasks');
        const isFirstVisit = !savedTasks && !localStorage.getItem('navigator-visited');

        // 🔐 작업 데이터 검증 후 로드
        if (savedTasks) {
          const parsedTasks = safeParseJSON('navigator-tasks', []);
          appState.tasks = validateTasks(parsedTasks);
        }

        // 🔐 boolean 검증
        const savedShuttle = localStorage.getItem('navigator-shuttle');
        if (savedShuttle) {
          appState.shuttleSuccess = Boolean(safeParseJSON('navigator-shuttle', false));
        }

        // 테마 로드
        const savedTheme = localStorage.getItem('navigator-theme');
        if (savedTheme) {
          appState.theme = savedTheme;
        }
        applyTheme();

        // 태그 로드
        const parsedTags = safeParseJSON('navigator-tags', null);
        if (parsedTags) appState.availableTags = parsedTags;

        // 스트릭 로드
        const parsedStreak = safeParseJSON('navigator-streak', null);
        if (parsedStreak) appState.streak = parsedStreak;
        updateStreak();

        // 설정 로드
        const parsedSettings = safeParseJSON('navigator-settings', null);
        if (parsedSettings) appState.settings = { ...appState.settings, ...parsedSettings };

        // 템플릿 로드
        const parsedTemplates = safeParseJSON('navigator-templates', null);
        if (parsedTemplates) appState.templates = parsedTemplates;

        // 주간 계획 로드
        const parsedWeeklyPlan = safeParseJSON('navigator-weekly-plan', null);
        if (parsedWeeklyPlan) appState.weeklyPlan = { ...appState.weeklyPlan, ...parsedWeeklyPlan };

        // 본업 프로젝트 로드
        const parsedWorkProjects = safeParseJSON('navigator-work-projects', null);
        if (parsedWorkProjects) {
          appState.workProjects = parsedWorkProjects;
          // 첫 프로젝트 자동 선택
          if (appState.workProjects.length > 0 && !appState.activeWorkProject) {
            const activeProject = appState.workProjects.find(p => !p.archived);
            appState.activeWorkProject = activeProject ? activeProject.id : null;
          }
        }

        // 본업 템플릿 로드
        const parsedWorkTemplates = safeParseJSON('navigator-work-templates', null);
        if (parsedWorkTemplates) appState.workTemplates = parsedWorkTemplates;

        // 라이프 리듬 로드
        loadLifeRhythm();

        // 통근 트래커 로드
        loadCommuteTracker();

        // 완료 기록 영구 로그 로드 + 1년 이상 데이터 압축
        loadCompletionLog();
        compactOldCompletionLog();

        // Soft-Delete 추적 데이터 로드
        const parsedDeletedIds = safeParseJSON('navigator-deleted-ids', null);
        if (parsedDeletedIds) appState.deletedIds = parsedDeletedIds;
        // 30일 이상 된 deletedIds 자동 정리
        cleanupOldDeletedIds();

        // 휴지통 로드 + 30일 자동 정리
        const parsedTrash = safeParseJSON('navigator-trash', null);
        if (Array.isArray(parsedTrash)) appState.trash = parsedTrash;
        cleanupOldTrash();

        // 오늘 완료한 작업 수 계산
        recomputeTodayStats();

        // 오래된 완료 태스크 정리
        cleanupOldCompletedTasks();

        // 반복 태스크(daily/weekdays) 일일 초기화
        const dailyResetDone = checkDailyReset();
        if (dailyResetDone) {
          recomputeTodayStats(); // 초기화 후 오늘 통계 재계산
          saveState(); // 모바일에서 beforeunload 미발생 시 데이터 유실 방지
        }

        // 첫 방문 시 온보딩
        if (isFirstVisit) {
          setTimeout(() => showOnboarding(), 500);
        }

        // 기존 숫자 ID → 문자열 마이그레이션 (crypto.randomUUID 전환 호환)
        migrateNumericIds();

        // 백업 리마인더 체크
        checkBackupReminder();

        // 데이터 유실 자동 감지: localStorage가 비어있지만 동기화 백업에 데이터가 있으면 복구 제안
        const shrinkage = checkDataShrinkage();
        if (shrinkage.blocked) {
          console.warn('[startup] 데이터 유실 감지:', shrinkage.details);
          setTimeout(() => {
            if (confirm(
              '⚠️ 데이터 유실이 감지되었습니다.\n\n' +
              shrinkage.details + '\n\n' +
              '동기화 백업에서 복원하시겠습니까?'
            )) {
              restoreFromSyncBackup();
            }
          }, 1000);
        }

      } catch (error) {
        console.error('데이터 로드 실패:', error);
        showToast('데이터 로드 중 오류가 발생했습니다', 'error');
      }
    }

    /**
     * 로컬스토리지에 데이터 저장 (실제 저장 로직)
     */
    function _doSaveState(immediate = false) {
      try {
        // 로그인 사용자: Firestore IndexedDB가 주 저장소 → localStorage 캐싱 스킵
        // 비로그인 또는 IndexedDB 사용 불가(프라이빗 브라우징): localStorage 폴백
        if (!appState.user || !isIndexedDBAvailable) {
          localStorage.setItem('navigator-tasks', JSON.stringify(appState.tasks));
          localStorage.setItem('navigator-shuttle', JSON.stringify(appState.shuttleSuccess));
          localStorage.setItem('navigator-theme', appState.theme);
          localStorage.setItem('navigator-tags', JSON.stringify(appState.availableTags));
          localStorage.setItem('navigator-settings', JSON.stringify(appState.settings));
          localStorage.setItem('navigator-streak', JSON.stringify(appState.streak));
          localStorage.setItem('navigator-templates', JSON.stringify(appState.templates));
          localStorage.setItem('navigator-weekly-plan', JSON.stringify(appState.weeklyPlan));
          localStorage.setItem('navigator-work-projects', JSON.stringify(appState.workProjects));
          localStorage.setItem('navigator-work-templates', JSON.stringify(appState.workTemplates));
          localStorage.setItem('navigator-commute-tracker', JSON.stringify(appState.commuteTracker));
          localStorage.setItem('navigator-completion-log', JSON.stringify(appState.completionLog));
          localStorage.setItem('navigator-deleted-ids', JSON.stringify(appState.deletedIds));
          localStorage.setItem('navigator-trash', JSON.stringify(appState.trash));
        }

        // Firebase 동기화 (로그인된 경우, 디바운스 적용)
        if (appState.user) {
          syncToFirebase(immediate);
        }
      } catch (error) {
        console.error('데이터 저장 실패:', error);
        showToast('데이터 저장 중 오류가 발생했습니다', 'error');
      }
    }

    // 디바운스된 저장 (연속 입력 시 500ms 후 한 번만 저장)
    let saveStateTimeout = null;
    function saveState() {
      if (saveStateTimeout) {
        clearTimeout(saveStateTimeout);
      }
      saveStateTimeout = setTimeout(() => {
        _doSaveState();
        saveStateTimeout = null;
      }, 500);
    }

    // 즉시 저장이 필요한 경우 (앱 종료 전 등)
    // 디바운스된 sync 타이머도 취소하고 즉시 동기화
    function saveStateImmediate() {
      if (saveStateTimeout) {
        clearTimeout(saveStateTimeout);
        saveStateTimeout = null;
      }
      if (syncDebounceTimer) {
        clearTimeout(syncDebounceTimer);
        syncDebounceTimer = null;
      }
      _doSaveState(true);
    }

    // localStorage에만 동기적으로 저장 (Firebase 호출 없음)
    // beforeunload에서 사용 — async setDoc은 브라우저가 기다리지 않으므로
    function _doSaveStateLocalOnly() {
      try {
        localStorage.setItem('navigator-tasks', JSON.stringify(appState.tasks));
        localStorage.setItem('navigator-shuttle', JSON.stringify(appState.shuttleSuccess));
        localStorage.setItem('navigator-theme', appState.theme);
        localStorage.setItem('navigator-tags', JSON.stringify(appState.availableTags));
        localStorage.setItem('navigator-settings', JSON.stringify(appState.settings));
        localStorage.setItem('navigator-streak', JSON.stringify(appState.streak));
        localStorage.setItem('navigator-templates', JSON.stringify(appState.templates));
        localStorage.setItem('navigator-weekly-plan', JSON.stringify(appState.weeklyPlan));
        localStorage.setItem('navigator-work-projects', JSON.stringify(appState.workProjects));
        localStorage.setItem('navigator-work-templates', JSON.stringify(appState.workTemplates));
        localStorage.setItem('navigator-commute-tracker', JSON.stringify(appState.commuteTracker));
        localStorage.setItem('navigator-completion-log', JSON.stringify(appState.completionLog));
        localStorage.setItem('navigator-deleted-ids', JSON.stringify(appState.deletedIds));
        localStorage.setItem('navigator-trash', JSON.stringify(appState.trash));
      } catch (error) {
        console.error('로컬 저장 실패:', error);
      }
    }

    // ============================================
    // Firebase 동기화
    // ============================================

    let unsubscribeSnapshot = null;
    let isSyncing = false;
    let pendingSync = false; // 동기화 중 추가 변경 발생 시 재동기화 예약
    let lastSyncToastTime = 0; // 동기화 토스트 간격 제한용 (30초)
    let isFirstRealtimeLoad = true; // 앱 첫 로드 시 토스트 미표시용
    let isLoadingFromCloud = false; // 클라우드 초기 로드 중 sync 차단 (빈 데이터 업로드 방지)
    let syncDebounceTimer = null; // syncToFirebase 디바운스 타이머
    const SYNC_DEBOUNCE_MS = 1500; // 동기화 디바운스 간격 (1.5초)
    let lastOwnWriteTimestamp = null; // 핑퐁 방지: 자기가 마지막으로 쓴 timestamp

    // IndexedDB 가용성 체크 (프라이빗 브라우징에서 사용 불가 시 localStorage 폴백)
    let isIndexedDBAvailable = true;
    try {
      const testReq = indexedDB.open('__idb_test__');
      testReq.onerror = () => { isIndexedDBAvailable = false; };
      testReq.onsuccess = () => { testReq.result.close(); indexedDB.deleteDatabase('__idb_test__'); };
    } catch (e) {
      isIndexedDBAvailable = false;
    }

    /**
     * Google 로그인
     */
    async function loginWithGoogle() {
      try {
        if (!window.firebaseAuth) {
          showToast('Firebase 로딩 중...', 'info');
          return;
        }
        const result = await window.firebaseSignIn(window.firebaseAuth, window.firebaseProvider);
        appState.user = {
          uid: result.user.uid,
          email: result.user.email,
          displayName: result.user.displayName,
          photoURL: result.user.photoURL
        };
        showToast('로그인 성공! 동기화를 시작합니다', 'success');

        // 클라우드 데이터 가져오기
        await loadFromFirebase();

        // 실시간 동기화 시작
        startRealtimeSync();

        renderStatic();
      } catch (error) {
        console.error('로그인 실패:', error);
        showToast('로그인에 실패했습니다', 'error');
      }
    }
    window.loginWithGoogle = loginWithGoogle;

    /**
     * 로그아웃
     */
    async function logout() {
      try {
        // 로그아웃 전 현재 데이터를 localStorage에 덤프 (비로그인 상태 대비)
        _doSaveStateLocalOnly();

        await window.firebaseSignOut(window.firebaseAuth);
        appState.user = null;
        appState.syncStatus = 'offline';

        // 실시간 동기화 중지
        if (unsubscribeSnapshot) {
          unsubscribeSnapshot();
          unsubscribeSnapshot = null;
        }

        showToast('로그아웃되었습니다', 'info');
        renderStatic();
      } catch (error) {
        console.error('로그아웃 실패:', error);
      }
    }
    window.logout = logout;

    /**
     * 수동 동기화 갱신 - 클라우드에서 최신 데이터를 가져와 병합 후 다시 업로드
     */
    async function forceSync() {
      if (!appState.user) {
        showToast('로그인이 필요합니다', 'info');
        return;
      }
      if (isSyncing) {
        showToast('동기화 진행 중입니다', 'info');
        return;
      }

      try {
        showToast('🔄 동기화 갱신 중...', 'info');
        // 디바운스 타이머 취소 (loadFromFirebase에서 병합 후 syncToFirebase 호출)
        if (saveStateTimeout) {
          clearTimeout(saveStateTimeout);
          saveStateTimeout = null;
        }
        // 클라우드에서 가져와 병합 후 업로드 (loadFromFirebase 내에서 syncToFirebase 호출)
        await loadFromFirebase();
        recomputeTodayStats();
        renderStatic();
        showToast('✅ 동기화 완료!', 'success');
      } catch (error) {
        console.error('수동 동기화 실패:', error);
        showToast('동기화에 실패했습니다', 'error');
      }
    }
    window.forceSync = forceSync;

    /**
     * Firebase에 데이터 저장 (디바운스 래퍼)
     * 빈번한 변경을 배치 처리하여 Firebase 쓰기 횟수를 줄임
     * @param {boolean} immediate - true이면 디바운스 없이 즉시 동기화 (로드 후 머지 등)
     */
    function syncToFirebase(immediate = false) {
      if (!appState.user) return;

      if (immediate) {
        // 즉시 동기화: 디바운스 타이머 취소 후 바로 실행
        if (syncDebounceTimer) {
          clearTimeout(syncDebounceTimer);
          syncDebounceTimer = null;
        }
        _doSyncToFirebase();
        return;
      }

      // 디바운스: 5초 내 추가 호출이 있으면 마지막 호출만 실행
      if (syncDebounceTimer) {
        clearTimeout(syncDebounceTimer);
      }
      syncDebounceTimer = setTimeout(() => {
        syncDebounceTimer = null;
        _doSyncToFirebase();
      }, SYNC_DEBOUNCE_MS);
    }

    /**
     * Firebase에 데이터 저장 (실제 로직)
     * syncToFirebase()를 통해서만 호출 — 직접 호출 금지
     */
    async function _doSyncToFirebase() {
      if (!appState.user) return;

      // 클라우드 초기 로드 중에는 동기화 차단 (빈 데이터 업로드 방지)
      // → loadFromFirebase() 완료 후 pendingSync로 재시도됨
      if (isLoadingFromCloud) {
        pendingSync = true;
        console.log('[sync] 클라우드 로드 중 - 동기화 대기');
        return;
      }

      // 동기화 중이면 다음 동기화 예약 (변경사항 누락 방지)
      if (isSyncing) {
        pendingSync = true;
        return;
      }

      // 데이터 축소(유실) 감지: 이전에 데이터가 있었는데 지금 전부 사라졌으면 차단
      const shrinkage = checkDataShrinkage();
      if (shrinkage.blocked) {
        console.warn('⚠️ 데이터 축소 감지, 동기화 차단:', shrinkage.details);
        showToast('⚠️ 데이터 손실 감지 — 동기화를 차단했습니다. 설정 > 동기화 백업에서 복원하세요.', 'error');
        appState.syncStatus = 'error';
        updateSyncIndicator();
        return;
      }

      try {
        isSyncing = true;
        pendingSync = false;
        appState.syncStatus = 'syncing';

        // 동기화 전 자동 백업 (데이터가 있을 때만 저장)
        createSyncBackup();

        const userDoc = window.firebaseDoc(window.firebaseDb, 'users', appState.user.uid);
        const writeTimestamp = new Date().toISOString();
        // { merge: true } — 텔레그램 봇 등 외부에서 추가한 필드(events 등) 보존
        await window.firebaseSetDoc(userDoc, {
          tasks: appState.tasks,
          settings: appState.settings,
          streak: appState.streak,
          templates: appState.templates,
          availableTags: appState.availableTags,
          workProjects: appState.workProjects,
          workTemplates: appState.workTemplates,
          lifeRhythm: appState.lifeRhythm,
          commuteTracker: appState.commuteTracker,
          completionLog: appState.completionLog,
          weeklyPlan: appState.weeklyPlan,
          shuttleSuccess: appState.shuttleSuccess,
          theme: appState.theme,
          deletedIds: appState.deletedIds,
          trash: appState.trash,
          lastUpdated: writeTimestamp
        }, { merge: true });

        // 핑퐁 방지: 자기가 쓴 timestamp 기록 → onSnapshot에서 자기 것인지 판별
        lastOwnWriteTimestamp = writeTimestamp;

        appState.syncStatus = 'synced';
        appState.lastSyncTime = new Date();
        updateSyncIndicator();

        // 성공적인 동기화 후 데이터 수 기록
        updateDataCounts();

        // 동기화 성공 토스트 (30초 간격 제한)
        const now = Date.now();
        if (now - lastSyncToastTime > 30000) {
          lastSyncToastTime = now;
          showToast('☁️ 클라우드 동기화 완료', 'success');
        }
      } catch (error) {
        console.error('동기화 실패:', error);
        appState.syncStatus = 'error';
        updateSyncIndicator();
      } finally {
        isSyncing = false;
        // 동기화 중 추가 변경이 있었으면 재동기화
        if (pendingSync) {
          pendingSync = false;
          _doSyncToFirebase();
        }
      }
    }

    /**
     * Firebase에서 데이터 로드
     */
    /**
     * 태스크별 타임스탬프 기반 병합
     * - 같은 ID: updatedAt이 더 최신인 쪽을 사용
     * - 한쪽에만 있는 태스크: 그대로 보존
     */
    function mergeTasks(localTasks, cloudTasks, deletedIds) {
      // deletedIds가 없으면 appState에서 가져오기
      const deleted = deletedIds || (appState.deletedIds && appState.deletedIds.tasks) || {};
      const localMap = new Map(localTasks.map(t => [t.id, t]));
      const cloudMap = new Map(cloudTasks.map(t => [t.id, t]));
      const allIds = new Set([...localMap.keys(), ...cloudMap.keys()]);
      const merged = [];

      for (const id of allIds) {
        // Soft-Delete: 삭제 기록이 있으면 병합에서 제외 (부활 방지)
        if (deleted[id]) continue;

        const local = localMap.get(id);
        const cloud = cloudMap.get(id);

        if (local && !cloud) {
          merged.push(local);
        } else if (cloud && !local) {
          merged.push(cloud);
        } else {
          // 양쪽 다 있으면 updatedAt 기준으로 최신 선택
          const localTime = new Date(local.updatedAt || local.completedAt || local.createdAt || 0).getTime();
          const cloudTime = new Date(cloud.updatedAt || cloud.completedAt || cloud.createdAt || 0).getTime();
          merged.push(cloudTime >= localTime ? cloud : local);
        }
      }

      return merged;
    }

    /**
     * ID 기반 배열 병합 (범용)
     * - 한쪽에만 있으면 그대로 보존
     * - 양쪽 다 있으면 updatedAt이 더 최신인 쪽 사용
     * workProjects, templates, workTemplates 등에 사용
     */
    function mergeById(localArr, cloudArr, deletedIds) {
      const deleted = deletedIds || {};
      const localMap = new Map((localArr || []).map(p => [p.id, p]));
      const cloudMap = new Map((cloudArr || []).map(p => [p.id, p]));
      const allIds = new Set([...localMap.keys(), ...cloudMap.keys()]);
      const merged = [];

      for (const id of allIds) {
        // Soft-Delete: 삭제 기록이 있으면 병합에서 제외 (부활 방지)
        if (deleted[id]) continue;

        const local = localMap.get(id);
        const cloud = cloudMap.get(id);

        if (local && !cloud) {
          merged.push(local);
        } else if (cloud && !local) {
          merged.push(cloud);
        } else {
          const localTime = new Date(local.updatedAt || local.createdAt || 0).getTime();
          const cloudTime = new Date(cloud.updatedAt || cloud.createdAt || 0).getTime();
          merged.push(cloudTime >= localTime ? cloud : local);
        }
      }

      return merged;
    }

    /**
     * deletedIds 병합: 로컬 + 클라우드 양쪽의 삭제 기록을 합침
     * 한쪽에서 삭제한 항목은 다른 쪽에서도 삭제 유지
     */
    function mergeDeletedIds(local, cloud) {
      const merged = {};
      const types = new Set([...Object.keys(local || {}), ...Object.keys(cloud || {})]);
      for (const type of types) {
        merged[type] = { ...(local[type] || {}), ...(cloud[type] || {}) };
      }
      return merged;
    }

    /**
     * 30일 이상 된 deletedIds 항목 자동 정리 (앱 시작 시 호출)
     */
    function cleanupOldDeletedIds() {
      const cutoff = Date.now() - 30 * 24 * 60 * 60 * 1000; // 30일 전
      let cleaned = 0;
      for (const type of Object.keys(appState.deletedIds)) {
        const ids = appState.deletedIds[type];
        for (const id of Object.keys(ids)) {
          if (new Date(ids[id]).getTime() < cutoff) {
            delete ids[id];
            cleaned++;
          }
        }
      }
      if (cleaned > 0) {
        console.log(`[deletedIds] ${cleaned}개 오래된 삭제 기록 정리`);
      }
    }

    // 라이프 리듬 히스토리 병합: js/rhythm.js로 분리됨

    /**
     * 동기화 전 자동 백업 생성
     * Firebase에 쓰기 전 현재 상태를 localStorage에 스냅샷으로 저장
     * 데이터 유실 시 복원 가능 (최근 1개 유지, 데이터가 있을 때만)
     */
    function createSyncBackup() {
      try {
        // 데이터가 하나도 없으면 백업할 가치 없음
        if (appState.tasks.length === 0 && appState.workProjects.length === 0) return;

        const backup = {
          timestamp: new Date().toISOString(),
          tasks: appState.tasks,
          workProjects: appState.workProjects,
          workTemplates: appState.workTemplates,
          templates: appState.templates,
          settings: appState.settings,
          lifeRhythm: appState.lifeRhythm,
          availableTags: appState.availableTags,
          streak: appState.streak,
          completionLog: appState.completionLog
        };

        localStorage.setItem('navigator-sync-backup', JSON.stringify(backup));
      } catch (e) {
        console.warn('동기화 백업 생성 실패:', e);
      }
    }

    /**
     * 동기화 백업에서 데이터 복원
     * 데이터 유실 감지 시 또는 수동으로 호출
     */
    function restoreFromSyncBackup() {
      const raw = localStorage.getItem('navigator-sync-backup');
      if (!raw) {
        showToast('복원할 동기화 백업이 없습니다', 'error');
        return;
      }

      try {
        const backup = JSON.parse(raw);
        const taskCount = (backup.tasks || []).length;
        const wpCount = (backup.workProjects || []).length;
        const timeStr = new Date(backup.timestamp).toLocaleString('ko-KR');

        if (!confirm(
          `동기화 백업에서 복원하시겠습니까?\n\n` +
          `백업 시각: ${timeStr}\n` +
          `태스크: ${taskCount}개\n` +
          `본업 프로젝트: ${wpCount}개\n\n` +
          `현재 데이터를 백업 데이터로 교체합니다.`
        )) return;

        // 복원
        if (backup.tasks) appState.tasks = validateTasks(backup.tasks);
        if (backup.workProjects) appState.workProjects = backup.workProjects;
        if (backup.workTemplates) appState.workTemplates = backup.workTemplates;
        if (backup.templates) appState.templates = backup.templates;
        if (backup.settings) appState.settings = { ...appState.settings, ...backup.settings };
        if (backup.lifeRhythm) {
          // 복원된 lifeRhythm에 med_afternoon → med_afternoon_adhd 마이그레이션
          if (backup.lifeRhythm.today?.medications?.med_afternoon !== undefined) {
            backup.lifeRhythm.today.medications.med_afternoon_adhd = backup.lifeRhythm.today.medications.med_afternoon;
            delete backup.lifeRhythm.today.medications.med_afternoon;
          }
          if (backup.lifeRhythm.history) {
            for (const date of Object.keys(backup.lifeRhythm.history)) {
              const meds = backup.lifeRhythm.history[date]?.medications;
              if (meds?.med_afternoon !== undefined) {
                meds.med_afternoon_adhd = meds.med_afternoon;
                delete meds.med_afternoon;
              }
            }
          }
          // medicationSlots 마이그레이션: med_afternoon → ADHD약 + 영양제 2개
          const slots = backup.lifeRhythm.settings?.medicationSlots;
          if (slots) {
            const oldIdx = slots.findIndex(s => s.id === 'med_afternoon');
            if (oldIdx !== -1) {
              slots.splice(oldIdx, 1,
                { id: 'med_afternoon_adhd', label: 'ADHD약(점심)', icon: '💊', required: true },
                { id: 'med_afternoon_nutrient', label: '영양제(점심)', icon: '🌿', required: false }
              );
            }
          }
          appState.lifeRhythm = backup.lifeRhythm;
        }
        if (backup.availableTags) appState.availableTags = backup.availableTags;
        if (backup.streak) appState.streak = backup.streak;
        if (backup.completionLog) appState.completionLog = backup.completionLog;

        // 로컬 저장 + Firebase 동기화
        _doSaveState();

        recomputeTodayStats();
        renderStatic();
        showToast('✅ 동기화 백업에서 복원 완료!', 'success');
      } catch (e) {
        console.error('백업 복원 실패:', e);
        showToast('백업 복원 중 오류가 발생했습니다', 'error');
      }
    }
    window.restoreFromSyncBackup = restoreFromSyncBackup;

    /**
     * 데이터 축소(유실) 감지
     * 이전에 기록된 데이터 수와 비교하여 급격한 감소를 탐지
     * @returns {{ blocked: boolean, details: string }}
     */
    function checkDataShrinkage() {
      const raw = localStorage.getItem('navigator-last-data-counts');
      if (!raw) return { blocked: false, details: '' };

      try {
        const last = JSON.parse(raw);
        const issues = [];

        // 이전에 데이터가 있었는데 지금 0이면 = 유실 가능성
        if (last.tasks > 3 && appState.tasks.length === 0) {
          issues.push(`tasks: ${last.tasks} → 0`);
        }
        if (last.workProjects > 0 && appState.workProjects.length === 0) {
          issues.push(`workProjects: ${last.workProjects} → 0`);
        }
        if (last.templates > 0 && (!appState.templates || appState.templates.length === 0)) {
          issues.push(`templates: ${last.templates} → 0`);
        }
        if (last.workTemplates > 0 && (!appState.workTemplates || appState.workTemplates.length === 0)) {
          issues.push(`workTemplates: ${last.workTemplates} → 0`);
        }

        return {
          blocked: issues.length > 0,
          details: issues.join(', ')
        };
      } catch (e) {
        return { blocked: false, details: '' };
      }
    }

    /**
     * 현재 데이터 수 기록 (성공적인 동기화 후 호출)
     * 다음 동기화 시 데이터 축소 감지에 사용
     */
    function updateDataCounts() {
      try {
        const counts = {
          tasks: appState.tasks.length,
          workProjects: appState.workProjects.length,
          templates: (appState.templates || []).length,
          workTemplates: (appState.workTemplates || []).length,
          timestamp: new Date().toISOString()
        };
        localStorage.setItem('navigator-last-data-counts', JSON.stringify(counts));
      } catch (e) {
        // 무시 - 필수 기능이 아님
      }
    }

    async function loadFromFirebase() {
      if (!appState.user) return;

      // 진행 중인 saveState 디바운스 타이머 취소 (빈 데이터가 먼저 Firebase에 업로드되는 것 방지)
      if (saveStateTimeout) {
        clearTimeout(saveStateTimeout);
        saveStateTimeout = null;
      }

      isLoadingFromCloud = true;

      try {
        appState.syncStatus = 'syncing';
        updateSyncIndicator();
        const userDoc = window.firebaseDoc(window.firebaseDb, 'users', appState.user.uid);
        const docSnap = await window.firebaseGetDoc(userDoc);

        if (docSnap.exists()) {
          const data = docSnap.data();

          // Soft-Delete: 삭제 기록 병합 (merge 전에 수행해야 삭제된 항목 필터링 가능)
          appState.deletedIds = mergeDeletedIds(appState.deletedIds, data.deletedIds);

          // 휴지통 병합 (ID 기준 합집합, 더 최근 deletedAt 우선)
          if (Array.isArray(data.trash)) {
            const trashMap = new Map();
            (appState.trash || []).forEach(t => trashMap.set(t.id, t));
            data.trash.forEach(t => {
              const existing = trashMap.get(t.id);
              if (!existing || (t.deletedAt && (!existing.deletedAt || t.deletedAt > existing.deletedAt))) {
                trashMap.set(t.id, t);
              }
            });
            appState.trash = Array.from(trashMap.values());
          }

          const cloudTasks = validateTasks(data.tasks || []);
          const localTasks = appState.tasks || [];

          // 태스크별 타임스탬프 기반 병합 (deletedIds 전달하여 삭제 항목 제외)
          appState.tasks = mergeTasks(localTasks, cloudTasks, appState.deletedIds.tasks);

          if (data.settings) {
            appState.settings = { ...appState.settings, ...data.settings };
          }
          if (data.streak) {
            // 스트릭은 더 높은 값 보존
            const cloudStreak = data.streak;
            appState.streak = {
              lastActiveDate: appState.streak.lastActiveDate > cloudStreak.lastActiveDate
                ? appState.streak.lastActiveDate : cloudStreak.lastActiveDate,
              best: Math.max(appState.streak.best || 0, cloudStreak.best || 0),
              current: appState.streak.lastActiveDate > cloudStreak.lastActiveDate
                ? appState.streak.current : cloudStreak.current
            };
          }
          // 템플릿: ID 기반 병합 (deletedIds 전달)
          appState.templates = mergeById(appState.templates, data.templates, appState.deletedIds.templates);
          if (data.availableTags) {
            // 태그 병합 (양쪽 합집합)
            const mergedTags = [...new Set([...(appState.availableTags || []), ...data.availableTags])];
            appState.availableTags = mergedTags;
          }
          // 본업 프로젝트: ID 기반 병합 (deletedIds 전달)
          appState.workProjects = mergeById(appState.workProjects, data.workProjects, appState.deletedIds.workProjects);
          if (appState.workProjects.length > 0 && !appState.activeWorkProject) {
            const activeProject = appState.workProjects.find(p => !p.archived);
            appState.activeWorkProject = activeProject ? activeProject.id : null;
          }
          // 본업 템플릿: ID 기반 병합 (deletedIds 전달)
          appState.workTemplates = mergeById(appState.workTemplates, data.workTemplates, appState.deletedIds.workTemplates);
          // 라이프 리듬 병합 (히스토리 필드별 병합, 오늘 데이터도 필드별)
          if (data.lifeRhythm) {
            const cloudRhythm = data.lifeRhythm;
            const localRhythm = appState.lifeRhythm;
            // 히스토리: 날짜별 + 필드별 병합 (양쪽 기록 보존)
            const mergedHistory = mergeRhythmHistory(localRhythm.history, cloudRhythm.history);
            // 오늘 데이터: 필드별 병합 (양쪽 값 보존)
            const localToday = localRhythm.today || {};
            const cloudToday = cloudRhythm.today || {};
            // 복약 기록 병합 (슬롯별)
            const lMedsToday = (localToday.medications || {});
            const cMedsToday = (cloudToday.medications || {});
            // med_afternoon → med_afternoon_adhd 마이그레이션
            if (lMedsToday.med_afternoon !== undefined) { lMedsToday.med_afternoon_adhd = lMedsToday.med_afternoon; delete lMedsToday.med_afternoon; }
            if (cMedsToday.med_afternoon !== undefined) { cMedsToday.med_afternoon_adhd = cMedsToday.med_afternoon; delete cMedsToday.med_afternoon; }
            const allMedSlots = new Set([...Object.keys(lMedsToday), ...Object.keys(cMedsToday)]);
            const mergedMeds = {};
            for (const slot of allMedSlots) {
              mergedMeds[slot] = lMedsToday[slot] || cMedsToday[slot] || null;
            }
            const mergedToday = {
              date: localToday.date || cloudToday.date,
              wakeUp: localToday.wakeUp || cloudToday.wakeUp || null,
              homeDepart: localToday.homeDepart || cloudToday.homeDepart || null,
              workArrive: localToday.workArrive || cloudToday.workArrive || null,
              workDepart: localToday.workDepart || cloudToday.workDepart || null,
              homeArrive: localToday.homeArrive || cloudToday.homeArrive || null,
              sleep: localToday.sleep || cloudToday.sleep || null,
              medications: mergedMeds
            };
            // settings 병합 시 medicationSlots는 로컬 우선 (마이그레이션 결과 보호)
            const mergedRhythmSettings = { ...(localRhythm.settings || {}), ...(cloudRhythm.settings || {}) };
            if (localRhythm.settings?.medicationSlots) {
              mergedRhythmSettings.medicationSlots = localRhythm.settings.medicationSlots;
            }
            appState.lifeRhythm = {
              ...localRhythm,
              history: mergedHistory,
              today: mergedToday,
              settings: mergedRhythmSettings
            };
            // Firestore IndexedDB가 캐시 담당 → localStorage 캐싱 불필요
          }
          // 통근 트래커 병합
          if (data.commuteTracker) {
            const cloud = data.commuteTracker;
            const local = appState.commuteTracker;
            const routeMap = {};
            (local.routes || []).forEach(r => { routeMap[r.id] = r; });
            (cloud.routes || []).forEach(r => { if (!routeMap[r.id]) routeMap[r.id] = r; });
            appState.commuteTracker.routes = Object.values(routeMap);
            const mergedTrips = { ...(cloud.trips || {}), ...(local.trips || {}) };
            appState.commuteTracker.trips = mergedTrips;
            appState.commuteTracker.settings = { ...(cloud.settings || {}), ...(local.settings || {}) };
          }
          // 완료 기록 영구 로그 병합
          if (data.completionLog) {
            appState.completionLog = mergeCompletionLog(appState.completionLog, data.completionLog);
          }
          // 주간 계획 병합
          if (data.weeklyPlan) {
            appState.weeklyPlan = data.weeklyPlan;
          }
          // 셔틀/테마 동기화
          if (data.shuttleSuccess !== undefined) {
            appState.shuttleSuccess = data.shuttleSuccess;
          }
          if (data.theme) {
            appState.theme = data.theme;
          }

          // Firestore IndexedDB가 캐시 담당 → localStorage 캐싱 불필요

          appState.syncStatus = 'synced';

          // 병합 완료 후 숫자 ID → 문자열 마이그레이션 (클라우드 데이터 호환)
          migrateNumericIds();
          // 병합 완료 → 로드 잠금 해제 후 클라우드에 즉시 반영
          isLoadingFromCloud = false;
          updateDataCounts();
          syncToFirebase(true);
        } else {
          // 클라우드에 데이터 없으면 현재 로컬 데이터 즉시 업로드
          isLoadingFromCloud = false;
          updateDataCounts();
          syncToFirebase(true);
        }

        appState.lastSyncTime = new Date();
        updateSyncIndicator();
      } catch (error) {
        console.error('데이터 로드 실패:', error);
        appState.syncStatus = 'error';
      } finally {
        // 에러 시에도 로드 잠금 해제 보장
        isLoadingFromCloud = false;
      }
    }

    /**
     * 실시간 동기화 시작
     */
    function startRealtimeSync() {
      if (!appState.user || unsubscribeSnapshot) return;

      const userDoc = window.firebaseDoc(window.firebaseDb, 'users', appState.user.uid);
      unsubscribeSnapshot = window.firebaseOnSnapshot(userDoc, (doc) => {
        if (doc.exists() && !isSyncing) {
          const data = doc.data();
          const cloudUpdated = new Date(data.lastUpdated);
          const localUpdated = appState.lastSyncTime;

          // 클라우드가 더 최신이면 업데이트
          if (!localUpdated || cloudUpdated > localUpdated) {
            // Soft-Delete: 삭제 기록 병합 (merge 전에 수행)
            if (data.deletedIds) {
              appState.deletedIds = mergeDeletedIds(appState.deletedIds, data.deletedIds);
            }
            // 휴지통 실시간 병합
            if (Array.isArray(data.trash)) {
              const trashMap = new Map();
              (appState.trash || []).forEach(t => trashMap.set(t.id, t));
              data.trash.forEach(t => {
                const existing = trashMap.get(t.id);
                if (!existing || (t.deletedAt && (!existing.deletedAt || t.deletedAt > existing.deletedAt))) {
                  trashMap.set(t.id, t);
                }
              });
              appState.trash = Array.from(trashMap.values());
            }
            if (data.tasks) {
              // 태스크별 병합 (deletedIds 전달하여 삭제 항목 제외)
              const cloudTasks = validateTasks(data.tasks);
              appState.tasks = mergeTasks(appState.tasks, cloudTasks, appState.deletedIds.tasks);
            }
            if (data.settings) {
              appState.settings = { ...appState.settings, ...data.settings };
            }
            if (data.streak) {
              const cloudStreak = data.streak;
              appState.streak = {
                lastActiveDate: appState.streak.lastActiveDate > cloudStreak.lastActiveDate
                  ? appState.streak.lastActiveDate : cloudStreak.lastActiveDate,
                best: Math.max(appState.streak.best || 0, cloudStreak.best || 0),
                current: appState.streak.lastActiveDate > cloudStreak.lastActiveDate
                  ? appState.streak.current : cloudStreak.current
              };
            }
            // 템플릿: ID 기반 병합 (deletedIds 전달)
            appState.templates = mergeById(appState.templates, data.templates, appState.deletedIds.templates);
            if (data.availableTags) {
              appState.availableTags = [...new Set([...(appState.availableTags || []), ...data.availableTags])];
            }
            // 본업 프로젝트: ID 기반 병합 (deletedIds 전달)
            appState.workProjects = mergeById(appState.workProjects, data.workProjects, appState.deletedIds.workProjects);
            // 본업 템플릿: ID 기반 병합 (deletedIds 전달)
            appState.workTemplates = mergeById(appState.workTemplates, data.workTemplates, appState.deletedIds.workTemplates);
            // 라이프 리듬 병합 (필드별)
            if (data.lifeRhythm) {
              const cloudRhythm = data.lifeRhythm;
              const localRhythm = appState.lifeRhythm;
              const mergedHistory = mergeRhythmHistory(localRhythm.history, cloudRhythm.history);
              const localToday = localRhythm.today || {};
              const cloudToday = cloudRhythm.today || {};
              // 복약 기록 병합 (슬롯별)
              const lMedsRT = (localToday.medications || {});
              const cMedsRT = (cloudToday.medications || {});
              // med_afternoon → med_afternoon_adhd 마이그레이션
              if (lMedsRT.med_afternoon !== undefined) { lMedsRT.med_afternoon_adhd = lMedsRT.med_afternoon; delete lMedsRT.med_afternoon; }
              if (cMedsRT.med_afternoon !== undefined) { cMedsRT.med_afternoon_adhd = cMedsRT.med_afternoon; delete cMedsRT.med_afternoon; }
              const allMedSlotsRT = new Set([...Object.keys(lMedsRT), ...Object.keys(cMedsRT)]);
              const mergedMedsRT = {};
              for (const slot of allMedSlotsRT) {
                mergedMedsRT[slot] = lMedsRT[slot] || cMedsRT[slot] || null;
              }
              const mergedToday = {
                date: localToday.date || cloudToday.date,
                wakeUp: localToday.wakeUp || cloudToday.wakeUp || null,
                homeDepart: localToday.homeDepart || cloudToday.homeDepart || null,
                workArrive: localToday.workArrive || cloudToday.workArrive || null,
                workDepart: localToday.workDepart || cloudToday.workDepart || null,
                homeArrive: localToday.homeArrive || cloudToday.homeArrive || null,
                sleep: localToday.sleep || cloudToday.sleep || null,
                medications: mergedMedsRT
              };
              // settings 병합 시 medicationSlots는 로컬 우선 (마이그레이션 결과 보호)
              const mergedRhythmSettingsRT = { ...(localRhythm.settings || {}), ...(cloudRhythm.settings || {}) };
              if (localRhythm.settings?.medicationSlots) {
                mergedRhythmSettingsRT.medicationSlots = localRhythm.settings.medicationSlots;
              }
              appState.lifeRhythm = {
                ...localRhythm,
                history: mergedHistory,
                today: mergedToday,
                settings: mergedRhythmSettingsRT
              };
              // Firestore IndexedDB가 캐시 담당 → localStorage 캐싱 불필요
            }
            // 완료 기록 영구 로그 병합
            if (data.completionLog) {
              appState.completionLog = mergeCompletionLog(appState.completionLog, data.completionLog);
            }
            if (data.weeklyPlan) {
              appState.weeklyPlan = data.weeklyPlan;
            }
            if (data.shuttleSuccess !== undefined) {
              appState.shuttleSuccess = data.shuttleSuccess;
            }
            if (data.theme) {
              appState.theme = data.theme;
            }

            appState.lastSyncTime = cloudUpdated;
            appState.syncStatus = 'synced';

            // 숫자 ID → 문자열 ID 마이그레이션 (다른 기기에서 온 데이터 포함)
            migrateNumericIds();

            // 오늘 통계 재계산 + 오래된 완료 태스크 정리
            recomputeTodayStats();
            cleanupOldCompletedTasks();

            renderStatic();
            updateSyncIndicator();

            // 다른 기기에서 변경사항 수신 토스트 (첫 로드 시 미표시)
            if (isFirstRealtimeLoad) {
              isFirstRealtimeLoad = false;
            } else {
              showToast('📲 다른 기기에서 변경사항 수신됨', 'success');
            }

            // 핑퐁 방지 재업로드: 다른 기기에서 온 변경이면 병합 결과를 Firebase에 재업로드
            // 자기가 쓴 것(lastOwnWriteTimestamp)이면 스킵 → 무한 루프 차단
            if (data.lastUpdated && data.lastUpdated !== lastOwnWriteTimestamp) {
              syncToFirebase(); // 디바운스 적용
            }
          }
        }
      });
    }

    /**
     * 동기화 상태 표시 업데이트
     */
    function updateSyncIndicator() {
      const indicator = document.getElementById('sync-indicator');
      if (!indicator) return;

      const statusMap = {
        'offline': { icon: '☁️', text: '오프라인', color: '#888' },
        'syncing': { icon: '🔄', text: '동기화 중...', color: '#667eea' },
        'synced': { icon: '✅', text: '동기화됨', color: '#48bb78' },
        'error': { icon: '⚠️', text: '동기화 오류', color: '#f5576c' }
      };

      const status = statusMap[appState.syncStatus] || statusMap['offline'];
      indicator.innerHTML = status.icon + ' ' + status.text;
      indicator.style.color = status.color;
    }

    // ============================================
    // 우선순위 계산 로직
    // ============================================
    
    /**
     * 작업의 우선순위 점수 계산
     * 점수가 높을수록 우선순위 높음
     */
    function calculatePriority(task) {
      let score = 0;
      const now = new Date();
      const hasDeadline = !!task.deadline;

      // 1. 마감시간 기반 점수 (가장 중요)
      if (hasDeadline) {
        const deadline = new Date(task.deadline);
        const hoursLeft = (deadline - now) / (1000 * 60 * 60);

        if (hoursLeft < 0) score -= 100;      // 이미 지남: 패널티
        else if (hoursLeft < 3) score += 100; // 3시간 내: 최우선
        else if (hoursLeft < 24) score += 70; // 하루 내: 높은 우선순위
        else if (hoursLeft < 72) score += 40; // 3일 내: 중간 우선순위
        else score += 20;                     // 마감 있지만 여유 있음
      }

      // 2. 카테고리 기본 점수 (마감 유무에 따라 차등)
      if (task.category === '본업') {
        score += hasDeadline ? 40 : 15;  // 마감 없으면 하단으로
      } else if (task.category === '부업') {
        score += hasDeadline ? 35 : 12;
      } else if (task.category === '일상') {
        score += hasDeadline ? 25 : 10;
      } else if (task.category === '가족') {
        score += hasDeadline ? 25 : 10;
      }

      // 3. 부업의 경우 ROI 계산 (수익/시간)
      if (task.category === '부업' && task.expectedRevenue) {
        const roi = task.expectedRevenue / task.estimatedTime;
        score += Math.min(roi * 0.1, 30); // 최대 30점까지
      }

      // 4. 짧은 작업 우대 (빠른 성취감)
      if (task.estimatedTime <= 10) score += 10;

      return score;
    }

    /**
     * 작업의 긴급도 레벨 반환
     */
    function getUrgencyLevel(task) {
      if (!task.deadline) return 'normal';
      
      const now = new Date();
      const deadline = new Date(task.deadline);
      const hoursLeft = (deadline - now) / (1000 * 60 * 60);
      
      if (hoursLeft < 0) return 'expired';   // 마감 지남
      if (hoursLeft < 3) return 'urgent';    // 긴급 (빨강)
      if (hoursLeft < 24) return 'warning';  // 주의 (주황)
      return 'normal';                       // 일반
    }

    // ============================================
    // 모드 및 필터링
    // ============================================
    
    /**
     * 시간 문자열(HH:MM)을 시간(hour)으로 변환
     */
    function parseTimeToHour(timeStr) {
      const [hour] = timeStr.split(':').map(Number);
      return hour;
    }

    /**
     * 현재 시간대 기반 모드 결정
     * 설정된 시간 기준으로 계산
     */
    function getCurrentMode() {
      const now = new Date();
      const hour = now.getHours();
      const dayOfWeek = now.getDay(); // 0=일, 6=토
      const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
      const settings = appState.settings;

      const workStart = parseTimeToHour(settings.workStartTime);
      const workEnd = parseTimeToHour(settings.workEndTime);
      const bedtime = parseTimeToHour(settings.targetBedtime);
      const wakeTime = parseTimeToHour(settings.targetWakeTime);

      // 주말은 휴식 모드 (단, 취침 시간 가까우면 생존 모드)
      if (isWeekend) {
        if (!appState.shuttleSuccess && hour >= bedtime - 2 && hour < bedtime + 1) return '생존';
        return '주말';
      }

      // 회사 시간 (평일만)
      if (hour >= workStart && hour < workEnd) return '회사';

      // 셔틀 성공 시 여유 모드 (퇴근 후 ~ 취침)
      if (appState.shuttleSuccess && hour >= workEnd - 1 && hour < bedtime) return '여유';

      // 셔틀 실패 시 생존 모드 (취침 2시간 전부터)
      if (!appState.shuttleSuccess && hour >= bedtime - 2 && hour < bedtime + 1) return '생존';

      // 출근 전 시간 (기상 ~ 회사 시작)
      if (hour >= wakeTime && hour < workStart) return '출근';

      // 그 외는 휴식
      return '휴식';
    }

    /**
     * 모드별 시간 레이블 반환
     */
    function getModeTimeLabel(mode, hour) {
      switch(mode) {
        case '회사': return '퇴근까지';
        case '여유': return '취침까지';
        case '생존': return '취침까지';
        case '출근': return '출근까지';
        case '주말': return '오늘 남은 시간';
        case '휴식': return '기상까지';
        default: return '남은 시간';
      }
    }

    /**
     * 모드별 남은 시간 계산 (설정 기반)
     */
    function getModeTimeRemaining(mode, hour, now) {
      const settings = appState.settings;
      const workEnd = parseTimeToHour(settings.workEndTime);
      const bedtime = parseTimeToHour(settings.targetBedtime);
      const wakeTime = parseTimeToHour(settings.targetWakeTime);
      const workStart = parseTimeToHour(settings.workStartTime);

      let endHour;
      switch(mode) {
        case '회사': endHour = workEnd; break;
        case '여유': endHour = bedtime; break;
        case '생존': endHour = bedtime; break;
        case '출근': endHour = workStart; break;
        case '주말': endHour = bedtime; break;
        case '휴식': endHour = wakeTime; break;
        default: endHour = 24;
      }

      let hoursLeft, minutesLeft;

      // 휴식 모드: 기상 시간까지 계산
      if (mode === '휴식') {
        if (hour >= 0 && hour < wakeTime) {
          // 자정 이후 ~ 기상시간 전
          hoursLeft = wakeTime - hour - 1;
          minutesLeft = 60 - now.getMinutes();
          if (minutesLeft === 60) { minutesLeft = 0; hoursLeft++; }
        } else {
          // 자정 이전
          hoursLeft = (24 - hour) + wakeTime - 1;
          minutesLeft = 60 - now.getMinutes();
          if (minutesLeft === 60) { minutesLeft = 0; hoursLeft++; }
        }
      } else {
        hoursLeft = endHour - hour - 1;
        minutesLeft = 60 - now.getMinutes();
        if (minutesLeft === 60) { minutesLeft = 0; hoursLeft++; }
      }

      if (hoursLeft < 0) hoursLeft = 0;
      if (minutesLeft < 0) minutesLeft = 0;

      return `${hoursLeft}시간 ${minutesLeft}분`;
    }

    /**
     * 현재 모드에 맞게 작업 필터링 및 정렬
     */
    function getFilteredTasks() {
      const mode = getCurrentMode();
      const now = new Date();
      const todayEnd = new Date(now);
      todayEnd.setHours(23, 59, 59, 999);

      let filtered = appState.tasks.filter(t => {
        // 완료된 작업 제외
        if (t.completed) return false;

        // 반복 작업 중 미래 마감일(내일 이후)인 작업 제외
        // 이렇게 해야 오늘 완료한 반복 작업의 "다음 회차"가 오늘 목록에 안 나옴
        if (t.deadline && t.repeatType && t.repeatType !== 'none') {
          const deadline = new Date(t.deadline);
          if (deadline > todayEnd) {
            return false; // 내일 이후 마감인 반복 작업은 숨김
          }
        }

        return true;
      });

      // 우선순위와 긴급도 계산
      filtered = filtered.map(t => ({
        ...t,
        priority: calculatePriority(t),
        urgency: getUrgencyLevel(t)
      }));

      // 우선순위 기준 정렬 (높은 순)
      filtered.sort((a, b) => b.priority - a.priority);

      // 모드별 필터링
      if (mode === '회사') {
        filtered = filtered.filter(t => t.category === '본업');
      } else if (mode === '생존') {
        // 생존 모드: 짧고 긴급한 것만
        filtered = filtered.filter(t => t.estimatedTime <= 15 || t.priority > 90);
      }

      // 검색 및 카테고리 필터 적용
      filtered = getSearchFilteredTasks(filtered);

      // 퀵 필터 적용
      if (appState.quickFilter) {
        switch (appState.quickFilter) {
          case '2min':
            filtered = filtered.filter(t => t.estimatedTime && t.estimatedTime <= 2);
            break;
          case '5min':
            filtered = filtered.filter(t => t.estimatedTime && t.estimatedTime <= 5);
            break;
          case 'urgent':
            filtered = filtered.filter(t => {
              if (!t.deadline) return false;
              const hoursLeft = (new Date(t.deadline) - new Date()) / (1000 * 60 * 60);
              return hoursLeft <= 24 && hoursLeft > 0;
            });
            break;
        }
      }

      return filtered;
    }

    /**
     * 카테고리별 통계 계산
     */
    function getCategoryStats() {
      const categories = ['본업', '부업', '일상'];
      return categories.map(cat => {
        const allTasks = appState.tasks.filter(t => t.category === cat);
        const completed = allTasks.filter(t => t.completed).length;
        const total = allTasks.length;
        const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;
        return { 
          category: cat, 
          total: total - completed,  // 남은 작업
          completed, 
          percentage 
        };
      });
    }

    /**
     * 수익 통계 계산 (월별/카테고리별)
     */
    function getRevenueStats() {
      const completedTasks = appState.tasks.filter(t => t.completed && t.expectedRevenue);

      // 월별 수익 (최근 6개월)
      const monthlyRevenue = {};
      const now = new Date();
      for (let i = 5; i >= 0; i--) {
        const d = new Date(now.getFullYear(), now.getMonth() - i, 1);
        const key = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;
        monthlyRevenue[key] = { month: key, label: `${d.getMonth() + 1}월`, revenue: 0, count: 0 };
      }

      // 카테고리별 수익
      const categoryRevenue = { '부업': 0, '본업': 0, '일상': 0, '가족': 0 };

      // 총 수익
      let totalRevenue = 0;
      let thisMonthRevenue = 0;
      const thisMonthKey = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;

      completedTasks.forEach(task => {
        const revenue = parseInt(task.expectedRevenue) || 0;
        totalRevenue += revenue;

        // 완료일 기준 월별 집계
        const completedDate = task.completedAt ? new Date(task.completedAt) : new Date();
        const monthKey = `${completedDate.getFullYear()}-${String(completedDate.getMonth() + 1).padStart(2, '0')}`;

        if (monthlyRevenue[monthKey]) {
          monthlyRevenue[monthKey].revenue += revenue;
          monthlyRevenue[monthKey].count++;
        }

        if (monthKey === thisMonthKey) {
          thisMonthRevenue += revenue;
        }

        // 카테고리별 집계
        if (categoryRevenue.hasOwnProperty(task.category)) {
          categoryRevenue[task.category] += revenue;
        }
      });

      // 월별 데이터를 배열로 변환
      const monthlyData = Object.values(monthlyRevenue);
      const maxMonthlyRevenue = Math.max(...monthlyData.map(m => m.revenue), 1);

      // 카테고리별 데이터를 배열로 변환
      const categoryData = Object.entries(categoryRevenue)
        .filter(([_, v]) => v > 0)
        .map(([category, revenue]) => ({
          category,
          revenue,
          percentage: totalRevenue > 0 ? Math.round((revenue / totalRevenue) * 100) : 0
        }))
        .sort((a, b) => b.revenue - a.revenue);

      return {
        totalRevenue,
        thisMonthRevenue,
        monthlyData,
        maxMonthlyRevenue,
        categoryData,
        taskCount: completedTasks.length
      };
    }

    /**
     * 자산관리 앱으로 수익 내보내기
     * 완료된 부업 Task의 수익을 자산관리 transaction 형식으로 변환
     */
    function exportToAssetManager() {
      const completedTasks = appState.tasks.filter(t =>
        t.completed &&
        t.expectedRevenue &&
        parseInt(t.expectedRevenue) > 0
      );

      if (completedTasks.length === 0) {
        showToast('내보낼 수익 데이터가 없습니다', 'warning');
        return;
      }

      // 자산관리 transaction 형식으로 변환
      const transactions = completedTasks.map(task => {
        const completedDate = task.completedAt ? new Date(task.completedAt) : new Date();
        return {
          type: 'income',
          category: task.category === '부업' ? '에어드랍' : (task.category === '본업' ? '급여' : '기타수입'),
          amount: parseInt(task.expectedRevenue),
          title: task.title,
          description: `[Navigator] ${task.category} - ${task.title}`,
          date: getLocalDateStr(completedDate),
          tags: ['navigator', task.category.toLowerCase()],
          source: 'navigator'
        };
      });

      // JSON으로 변환
      const exportData = {
        source: 'navigator',
        exportedAt: new Date().toISOString(),
        summary: {
          totalRevenue: transactions.reduce((sum, t) => sum + t.amount, 0),
          taskCount: transactions.length
        },
        transactions: transactions
      };

      // 클립보드에 복사
      const jsonStr = JSON.stringify(exportData, null, 2);

      navigator.clipboard.writeText(jsonStr).then(() => {
        showToast(`${transactions.length}개 수익 데이터가 클립보드에 복사되었습니다.\n자산관리 앱에서 가져오기 해주세요.`, 'success');
      }).catch(() => {
        // 클립보드 접근 실패 시 다운로드 제공
        downloadAssetExport(exportData);
      });
    }

    /**
     * 수익 데이터 JSON 다운로드
     */
    function downloadAssetExport(data) {
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `navigator-revenue-${getLocalDateStr()}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showToast('수익 데이터 파일이 다운로드되었습니다', 'success');
    }

    // 전역 함수로 노출
    window.exportToAssetManager = exportToAssetManager;

    /**
     * 긴급 작업 목록 반환
     */
    function getUrgentTasks() {
      return appState.tasks
        .filter(t => !t.completed && t.deadline)
        .map(t => ({
          ...t,
          urgency: getUrgencyLevel(t)
        }))
        .filter(t => t.urgency === 'urgent' || t.urgency === 'warning')
        .sort((a, b) => new Date(a.deadline) - new Date(b.deadline));
    }

    // ============================================
    // 데이터 인사이트 함수
    // ============================================

    /**
     * 시간대별 생산성 분석
     */
    function getHourlyProductivity() {
      const hourlyData = {};
      for (let i = 0; i < 24; i++) {
        hourlyData[i] = 0;
      }

      // completionLog 기반 시간대별 집계
      for (const entries of Object.values(appState.completionLog || {})) {
        (entries || []).forEach(e => {
          const hour = parseInt(e.at.split(':')[0], 10);
          if (hour >= 0 && hour < 24) hourlyData[hour]++;
        });
      }

      // 가장 생산적인 시간대 찾기
      let maxHour = 0;
      let maxCount = 0;
      for (let i = 0; i < 24; i++) {
        if (hourlyData[i] > maxCount) {
          maxCount = hourlyData[i];
          maxHour = i;
        }
      }

      // 시간대별 그룹화 (아침/점심/오후/저녁/밤)
      const periods = {
        morning: { name: '아침 (6-11시)', count: 0, hours: [6, 7, 8, 9, 10, 11] },
        lunch: { name: '점심 (11-14시)', count: 0, hours: [11, 12, 13, 14] },
        afternoon: { name: '오후 (14-18시)', count: 0, hours: [14, 15, 16, 17, 18] },
        evening: { name: '저녁 (18-22시)', count: 0, hours: [18, 19, 20, 21, 22] },
        night: { name: '밤 (22-6시)', count: 0, hours: [22, 23, 0, 1, 2, 3, 4, 5] }
      };

      for (let i = 0; i < 24; i++) {
        if (i >= 6 && i < 11) periods.morning.count += hourlyData[i];
        else if (i >= 11 && i < 14) periods.lunch.count += hourlyData[i];
        else if (i >= 14 && i < 18) periods.afternoon.count += hourlyData[i];
        else if (i >= 18 && i < 22) periods.evening.count += hourlyData[i];
        else periods.night.count += hourlyData[i];
      }

      // 가장 생산적인 시간대
      let bestPeriod = 'morning';
      let bestCount = 0;
      Object.keys(periods).forEach(key => {
        if (periods[key].count > bestCount) {
          bestCount = periods[key].count;
          bestPeriod = key;
        }
      });

      return {
        hourlyData,
        peakHour: maxHour,
        peakCount: maxCount,
        periods,
        bestPeriod: periods[bestPeriod],
        totalCompleted: Object.values(hourlyData).reduce((a, b) => a + b, 0)
      };
    }

    /**
     * 카테고리별 완료 분배
     */
    function getCategoryDistribution() {
      const distribution = {};
      let total = 0;

      // completionLog 기반 카테고리 분포
      for (const entries of Object.values(appState.completionLog || {})) {
        (entries || []).forEach(e => {
          const cat = e.c || '기타';
          distribution[cat] = (distribution[cat] || 0) + 1;
          total++;
        });
      }
      const result = Object.keys(distribution).map(cat => ({
        category: cat,
        count: distribution[cat],
        percentage: total > 0 ? Math.round((distribution[cat] / total) * 100) : 0
      })).sort((a, b) => b.count - a.count);

      return { distribution: result, total };
    }

    /**
     * 요일별 생산성 분석
     */
    function getDayOfWeekProductivity() {
      const dayNames = ['일', '월', '화', '수', '목', '금', '토'];
      const dayData = [0, 0, 0, 0, 0, 0, 0];

      // completionLog 기반 요일별 집계
      for (const [dateKey, entries] of Object.entries(appState.completionLog || {})) {
        const day = new Date(dateKey).getDay();
        dayData[day] += (entries || []).length;
      }

      const maxDay = dayData.indexOf(Math.max(...dayData));

      return {
        data: dayNames.map((name, i) => ({ name, count: dayData[i] })),
        bestDay: dayNames[maxDay],
        bestDayCount: dayData[maxDay]
      };
    }

    // ============================================
    // 히스토리 / 캘린더 관련 함수
    // ============================================

    /**
     * 특정 날짜의 완료된 작업 목록 가져오기
     */
    function getCompletedTasksByDate(dateStr) {
      const results = [];
      const seen = new Set();

      // 1. completionLog에서 조회 (영구 기록) — 동일 제목+시간도 각각 표시
      const logEntries = (appState.completionLog || {})[dateStr] || [];
      logEntries.forEach((e, idx) => {
        const key = 'log|' + idx + '|' + e.t + '|' + e.at;
        seen.add(key);
        // tasks 중복 체크용 별도 키도 등록
        const dedupKey = e.t + '|' + e.at;
        seen.add(dedupKey);
        results.push({
          title: e.t,
          category: e.c,
          completedAt: dateStr + 'T' + e.at,
          repeatType: e.r || null,
          expectedRevenue: e.rv || 0,
          estimatedTime: 0,
          fromLog: true,
          logIndex: idx  // completionLog 내 원래 인덱스 (수정/삭제용)
        });
      });

      // 2. appState.tasks에서 보완 (completionLog에 없는 항목)
      appState.tasks.forEach(t => {
        if (!t.completed || !t.completedAt) return;
        const completedDate = getLocalDateStr(new Date(t.completedAt));
        if (completedDate !== dateStr) return;
        const timeStr = new Date(t.completedAt).toTimeString().slice(0, 5);
        const key = t.title + '|' + timeStr;
        if (!seen.has(key)) {
          seen.add(key);
          results.push(t);
        }
      });

      return results.sort((a, b) => new Date(a.completedAt) - new Date(b.completedAt));
    }

    /**
     * 날짜별 완료 작업 수 맵 생성
     */
    function getCompletionMap() {
      const map = {};
      // completionLog 기반 (과거 영구 기록 포함)
      for (const [dateKey, entries] of Object.entries(appState.completionLog || {})) {
        (entries || []).forEach(e => {
          if (e._summary) {
            map[dateKey] = (map[dateKey] || 0) + (e.count || 0);
          } else {
            map[dateKey] = (map[dateKey] || 0) + 1;
          }
        });
      }
      // appState.tasks 현재 데이터로 보완 (completionLog와 중복되지 않는 항목만 추가)
      appState.tasks.forEach(t => {
        if (t.completed && t.completedAt) {
          const dateKey = getLocalDateStr(new Date(t.completedAt));
          const timeStr = new Date(t.completedAt).toTimeString().slice(0, 5);
          const logEntries = (appState.completionLog || {})[dateKey] || [];
          // completionLog에 같은 제목+시간 항목이 없는 경우만 카운트
          const isDuplicate = logEntries.some(e => e.t === t.title && e.at === timeStr);
          if (!isDuplicate) {
            map[dateKey] = (map[dateKey] || 0) + 1;
          }
        }
      });
      return map;
    }

    /**
     * 주간 통계 계산
     */
    function getWeeklyStats() {
      const now = new Date();
      const weekStart = new Date(now);
      weekStart.setDate(now.getDate() - now.getDay()); // 이번 주 일요일
      weekStart.setHours(0, 0, 0, 0);

      // completionLog 기반 일별 완료 수 계산
      const completionMap = getCompletionMap();
      const dailyCounts = [];
      for (let i = 0; i < 7; i++) {
        const day = new Date(weekStart);
        day.setDate(weekStart.getDate() + i);
        const dayStr = getLocalDateStr(day);
        dailyCounts.push(completionMap[dayStr] || 0);
      }

      const totalCompleted = dailyCounts.reduce((a, b) => a + b, 0);
      const daysWithActivity = dailyCounts.filter(c => c > 0).length;
      const avgPerDay = daysWithActivity > 0 ? (totalCompleted / daysWithActivity).toFixed(1) : 0;

      return {
        total: totalCompleted,
        avgPerDay: avgPerDay,
        activeDays: daysWithActivity,
        dailyCounts: dailyCounts
      };
    }

    /**
     * 캘린더 이전 달로 이동
     */
    function prevMonth() {
      appState.historyState.viewingMonth--;
      if (appState.historyState.viewingMonth < 0) {
        appState.historyState.viewingMonth = 11;
        appState.historyState.viewingYear--;
      }
      appState.historyState.selectedDate = null;
      renderStatic();
    }

    /**
     * 캘린더 다음 달로 이동
     */
    function nextMonth() {
      appState.historyState.viewingMonth++;
      if (appState.historyState.viewingMonth > 11) {
        appState.historyState.viewingMonth = 0;
        appState.historyState.viewingYear++;
      }
      appState.historyState.selectedDate = null;
      renderStatic();
    }

    /**
     * 캘린더에서 날짜 선택
     */
    function selectDate(dateStr) {
      if (appState.historyState.selectedDate === dateStr) {
        appState.historyState.selectedDate = null;
      } else {
        appState.historyState.selectedDate = dateStr;
      }
      renderStatic();
    }

    /**
     * 히스토리에서 날짜 그룹 토글
     */
    function toggleHistoryDate(dateStr) {
      appState.historyState.expandedDates[dateStr] = !appState.historyState.expandedDates[dateStr];
      renderStatic();
    }

    /**
     * 캘린더 렌더링 HTML 생성
     */
    function renderCalendar() {
      const year = appState.historyState.viewingYear;
      const month = appState.historyState.viewingMonth;
      const completionMap = getCompletionMap();

      const firstDay = new Date(year, month, 1);
      const lastDay = new Date(year, month + 1, 0);
      const daysInMonth = lastDay.getDate();
      const startDayOfWeek = firstDay.getDay();

      const today = new Date();
      const todayStr = getLocalDateStr(today);

      const monthNames = ['1월', '2월', '3월', '4월', '5월', '6월',
                          '7월', '8월', '9월', '10월', '11월', '12월'];

      let daysHtml = '';

      // 빈 칸 (이전 달)
      for (let i = 0; i < startDayOfWeek; i++) {
        daysHtml += '<div class="calendar-day empty"></div>';
      }

      // 날짜 칸
      for (let day = 1; day <= daysInMonth; day++) {
        const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
        const count = completionMap[dateStr] || 0;
        const isToday = dateStr === todayStr;
        const isSelected = dateStr === appState.historyState.selectedDate;

        // 활동 레벨 (1-4)
        let level = 0;
        if (count > 0) level = 1;
        if (count >= 3) level = 2;
        if (count >= 5) level = 3;
        if (count >= 7) level = 4;

        const classes = [
          'calendar-day',
          isToday ? 'today' : '',
          isSelected ? 'selected' : '',
          count > 0 ? 'has-activity' : '',
          count > 0 ? `level-${level}` : ''
        ].filter(Boolean).join(' ');

        daysHtml += `
          <div class="${classes}" onclick="selectDate('${dateStr}')">
            <span class="calendar-day-number">${day}</span>
            ${count > 0 ? '<span class="calendar-day-dot"></span>' : ''}
          </div>
        `;
      }

      return `
        <div class="calendar-container">
          <div class="calendar-header">
            <div class="calendar-title">${year}년 ${monthNames[month]}</div>
            <div class="calendar-nav">
              <button class="calendar-nav-btn" onclick="prevMonth()">◀</button>
              <button class="calendar-nav-btn" onclick="nextMonth()">▶</button>
            </div>
          </div>
          <div class="calendar-weekdays">
            <div class="calendar-weekday">일</div>
            <div class="calendar-weekday">월</div>
            <div class="calendar-weekday">화</div>
            <div class="calendar-weekday">수</div>
            <div class="calendar-weekday">목</div>
            <div class="calendar-weekday">금</div>
            <div class="calendar-weekday">토</div>
          </div>
          <div class="calendar-days">
            ${daysHtml}
          </div>
          <div class="calendar-legend">
            <div class="legend-item"><div class="legend-box empty"></div>없음</div>
            <div class="legend-item"><div class="legend-box level-1"></div>1-2개</div>
            <div class="legend-item"><div class="legend-box level-2"></div>3-4개</div>
            <div class="legend-item"><div class="legend-box level-3"></div>5-6개</div>
            <div class="legend-item"><div class="legend-box level-4"></div>7+개</div>
          </div>
        </div>
      `;
    }

    /**
     * 시간 입력 편의 파싱: 1430→14:30, 930→09:30, 9→09:00, 14:30→14:30
     */
    function parseTimeInput(input) {
      if (!input) return null;
      const s = input.trim().replace(/[：]/, ':'); // 전각 콜론도 처리
      // 이미 HH:MM 형식
      if (/^\d{1,2}:\d{2}$/.test(s)) {
        const [h, m] = s.split(':').map(Number);
        if (h >= 0 && h <= 23 && m >= 0 && m <= 59) return String(h).padStart(2, '0') + ':' + String(m).padStart(2, '0');
        return null;
      }
      // 숫자만 입력
      const digits = s.replace(/\D/g, '');
      if (!digits) return null;
      let h, m;
      if (digits.length === 4) { h = parseInt(digits.slice(0, 2)); m = parseInt(digits.slice(2)); }       // 1430
      else if (digits.length === 3) { h = parseInt(digits.slice(0, 1)); m = parseInt(digits.slice(1)); }   // 930
      else if (digits.length <= 2) { h = parseInt(digits); m = 0; }                                        // 9, 14
      else return null;
      if (h >= 0 && h <= 23 && m >= 0 && m <= 59) return String(h).padStart(2, '0') + ':' + String(m).padStart(2, '0');
      return null;
    }

    /**
     * completionLog 항목 추가 (과거 날짜에 완료 기록 추가)
     */
    function addCompletionLogEntry(dateStr) {
      const title = prompt('제목:');
      if (title === null) return; // 취소
      if (!title.trim()) { showToast('제목을 입력해주세요', 'error'); return; }

      const categories = ['본업', '부업', '일상', '가족'];
      const catIdx = prompt('카테고리 (1:본업, 2:부업, 3:일상, 4:가족):', '3');
      if (catIdx === null) return;
      const cat = categories[parseInt(catIdx) - 1] || '일상';

      // 오늘이면 현재 시간, 과거 날짜면 12:00 기본값
      const todayStr = getLocalDateStr(new Date());
      const defaultTime = dateStr === todayStr ? new Date().toTimeString().slice(0, 5) : '12:00';
      const time = prompt('완료 시간 (예: 1430, 930, 9, 14:30):', defaultTime);
      if (time === null) return;
      const parsed = parseTimeInput(time);
      if (!parsed && time.trim()) {
        showToast('시간 형식이 올바르지 않아 기본값을 사용합니다', 'warning');
      }
      const finalTime = parsed || defaultTime;

      const revenueStr = prompt('수익 (원, 없으면 0):', '0');
      if (revenueStr === null) return;
      const revenue = parseInt(revenueStr) || 0;

      // completionLog에 추가
      if (!appState.completionLog) appState.completionLog = {};
      if (!appState.completionLog[dateStr]) appState.completionLog[dateStr] = [];
      appState.completionLog[dateStr].push({
        t: title.trim(),
        c: cat,
        at: finalTime,
        rv: revenue
      });

      saveState();
      recomputeTodayStats();
      renderStatic();
      showToast('기록이 추가되었습니다', 'success');
    }
    window.addCompletionLogEntry = addCompletionLogEntry;

    /**
     * completionLog 항목 수정 (과거 완료 기록 수정)
     */
    function editCompletionLogEntry(dateStr, index) {
      const entries = (appState.completionLog || {})[dateStr];
      if (!entries || !entries[index]) return;
      const entry = entries[index];

      const newTitle = prompt('제목:', entry.t);
      if (newTitle === null) return; // 취소
      if (!newTitle.trim()) { showToast('제목을 입력해주세요', 'error'); return; }

      const categories = ['본업', '부업', '일상', '가족'];
      const catIdx = prompt(`카테고리 (1:본업, 2:부업, 3:일상, 4:가족):\n현재: ${entry.c}`, String(categories.indexOf(entry.c) + 1));
      if (catIdx === null) return;
      const newCat = categories[parseInt(catIdx) - 1] || entry.c;

      const newTime = prompt('완료 시간 (예: 1430, 930, 9, 14:30):', entry.at);
      if (newTime === null) return;

      const newRevenue = prompt('수익 (원, 없으면 0):', String(entry.rv || 0));
      if (newRevenue === null) return;

      // 업데이트 적용
      entry.t = newTitle.trim();
      entry.c = newCat;
      const parsedTime = parseTimeInput(newTime);
      if (parsedTime) {
        entry.at = parsedTime;
      } else if (newTime.trim()) {
        showToast('시간 형식이 올바르지 않아 기존 값을 유지합니다', 'warning');
      }
      entry.rv = parseInt(newRevenue) || 0;

      saveState();
      recomputeTodayStats();
      renderStatic();
      showToast('기록이 수정되었습니다', 'success');
    }
    window.editCompletionLogEntry = editCompletionLogEntry;

    /**
     * completionLog 항목 삭제 (과거 완료 기록 삭제)
     */
    function deleteCompletionLogEntry(dateStr, index) {
      const entries = (appState.completionLog || {})[dateStr];
      if (!entries || !entries[index]) return;

      if (!confirm(`"${entries[index].t}" 기록을 삭제하시겠습니까?`)) return;

      entries.splice(index, 1);
      // 해당 날짜에 기록이 0개면 날짜 키 자체 제거
      if (entries.length === 0) delete appState.completionLog[dateStr];

      saveState();
      recomputeTodayStats();
      renderStatic();
      showToast('기록이 삭제되었습니다', 'success');
    }
    window.deleteCompletionLogEntry = deleteCompletionLogEntry;

    /**
     * completionLog 항목 수정 (날짜/시간 변경)
     */
    function editCompletionLogEntry(dateStr, index) {
      const entries = (appState.completionLog || {})[dateStr];
      if (!entries || !entries[index]) return;
      const entry = entries[index];

      // 모달 HTML
      const modalId = 'edit-log-modal';
      if (document.getElementById(modalId)) document.getElementById(modalId).remove();

      const modal = document.createElement('div');
      modal.id = modalId;
      modal.className = 'modal-overlay';
      modal.style.cssText = 'display:flex;z-index:10000';
      modal.innerHTML = `
        <div class="modal" style="max-width:340px">
          <div class="modal-header">
            <h3 style="margin:0;font-size:16px">📝 기록 수정</h3>
            <button class="modal-close" onclick="document.getElementById('${modalId}').remove()" aria-label="닫기">×</button>
          </div>
          <div class="modal-body" style="padding:16px">
            <div style="margin-bottom:12px;font-size:14px;color:var(--text-secondary)">${escapeHtml(entry.t)}</div>
            <label style="display:block;margin-bottom:8px;font-size:13px;font-weight:600">날짜</label>
            <input type="date" id="edit-log-date" value="${dateStr}" style="width:100%;padding:10px;border-radius:8px;border:1px solid var(--border-color);background:var(--bg-secondary);color:var(--text-primary);font-size:15px;margin-bottom:12px">
            <label style="display:block;margin-bottom:8px;font-size:13px;font-weight:600">시간</label>
            <input type="text" id="edit-log-time" value="${entry.at || '12:00'}" placeholder="HH:MM (예: 1430, 9:30)" style="width:100%;padding:10px;border-radius:8px;border:1px solid var(--border-color);background:var(--bg-secondary);color:var(--text-primary);font-size:15px">
          </div>
          <div class="modal-footer" style="padding:12px 16px;display:flex;gap:8px;justify-content:flex-end">
            <button class="btn btn-secondary" onclick="document.getElementById('${modalId}').remove()">취소</button>
            <button class="btn btn-primary" onclick="applyEditCompletionLog('${dateStr}', ${index})">저장</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      // 오버레이 클릭으로 닫기
      modal.addEventListener('click', (e) => { if (e.target === modal) modal.remove(); });
      document.getElementById('edit-log-time').focus();
    }
    window.editCompletionLogEntry = editCompletionLogEntry;

    function applyEditCompletionLog(origDate, origIndex) {
      const entries = (appState.completionLog || {})[origDate];
      if (!entries || !entries[origIndex]) return;
      const entry = entries[origIndex];

      const newDate = document.getElementById('edit-log-date').value;
      const rawTime = document.getElementById('edit-log-time').value;
      const newTime = parseTimeInput(rawTime);

      if (!newDate) { showToast('날짜를 입력해주세요', 'error'); return; }
      if (!newTime) { showToast('올바른 시간을 입력해주세요 (예: 14:30, 930)', 'error'); return; }

      // 기존 위치에서 제거
      entries.splice(origIndex, 1);
      if (entries.length === 0) delete appState.completionLog[origDate];

      // 새 위치에 추가
      if (!appState.completionLog[newDate]) appState.completionLog[newDate] = [];
      appState.completionLog[newDate].push({ ...entry, at: newTime });

      // 모달 닫기
      const modal = document.getElementById('edit-log-modal');
      if (modal) modal.remove();

      saveState();
      recomputeTodayStats();
      renderStatic();
      showToast('기록이 수정되었습니다', 'success');
    }
    window.applyEditCompletionLog = applyEditCompletionLog;

    /**
     * 선택된 날짜의 상세 정보 렌더링
     */
    function renderDayDetail() {
      const selectedDate = appState.historyState.selectedDate;
      if (!selectedDate) return '';

      const tasks = getCompletedTasksByDate(selectedDate);
      const date = new Date(selectedDate);
      const dayNames = ['일', '월', '화', '수', '목', '금', '토'];
      const dateTitle = `${date.getMonth() + 1}월 ${date.getDate()}일 ${dayNames[date.getDay()]}요일`;

      // 총 소요 시간 + 수익 계산
      const totalTime = tasks.reduce((sum, t) => sum + (t.estimatedTime || 0), 0);
      const totalRevenue = tasks.reduce((sum, t) => sum + (t.expectedRevenue || 0), 0);

      // 라이프 리듬 정보 (해당 날짜)
      const rhythmData = (appState.lifeRhythm.history || {})[selectedDate];
      // 복약 정보
      const medsData = rhythmData ? (rhythmData.medications || {}) : {};
      const medSlots = getMedicationSlots ? getMedicationSlots() : [];

      return `
        <div class="day-detail">
          <div class="day-detail-header">
            <div style="display:flex;justify-content:space-between;align-items:center;">
              <div class="day-detail-date">${dateTitle}</div>
              <button onclick="addCompletionLogEntry('${selectedDate}')"
                style="background:var(--accent-color);color:#fff;border:none;border-radius:6px;padding:4px 10px;font-size:13px;cursor:pointer;white-space:nowrap;"
                aria-label="이 날짜에 기록 추가">➕ 기록 추가</button>
            </div>
            <div class="day-detail-stats">
              <div class="day-detail-stat completed">✓ ${tasks.length}개 완료</div>
              ${totalRevenue > 0 ? `<div class="day-detail-stat">💰 ${totalRevenue.toLocaleString()}원</div>` : ''}
              ${totalTime > 0 ? `<div class="day-detail-stat">⏱ ${totalTime}분</div>` : ''}
            </div>
          </div>
          ${rhythmData ? `
            <div class="day-detail-rhythm" style="padding: 8px 12px; margin-bottom: 8px; background: var(--bg-secondary); border-radius: 8px; font-size: 13px;">
              <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                ${rhythmData.wakeUp ? `<span>☀️ ${rhythmData.wakeUp}</span>` : ''}
                ${rhythmData.homeDepart ? `<span>🏠→ ${rhythmData.homeDepart}</span>` : ''}
                ${rhythmData.workArrive ? `<span>🏢 ${rhythmData.workArrive}</span>` : ''}
                ${rhythmData.workDepart ? `<span>🏢→ ${rhythmData.workDepart}</span>` : ''}
                ${rhythmData.homeArrive ? `<span>→🏠 ${rhythmData.homeArrive}</span>` : ''}
                ${rhythmData.sleep ? `<span>🌙 ${rhythmData.sleep}</span>` : ''}
              </div>
              ${Object.keys(medsData).length > 0 ? `
                <div style="margin-top: 4px; display: flex; flex-wrap: wrap; gap: 6px;">
                  ${medSlots.map(slot => {
                    const taken = medsData[slot.id];
                    return taken ? `<span style="color: var(--accent-color);">${slot.icon || '💊'} ${slot.label} ${taken}</span>` :
                      `<span style="color: var(--text-muted);">${slot.icon || '💊'} ${slot.label} -</span>`;
                  }).join('')}
                </div>
              ` : ''}
            </div>
          ` : ''}
          ${tasks.length > 0 ? `
            <div class="day-detail-list">
              ${tasks.map(task => {
                const completedTime = new Date(task.completedAt);
                const timeStr = completedTime.toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' });
                const cat = task.category || '기타';
                const revenue = task.expectedRevenue || 0;
                return `
                  <div class="day-task-item">
                    <div class="day-task-time">${timeStr}</div>
                    <div class="day-task-content">
                      <div class="day-task-title completed">${escapeHtml(task.title)}</div>
                      <div class="day-task-meta">
                        <span class="category ${cat}">${escapeHtml(cat)}</span>
                        ${revenue > 0 ? ` · 💰${revenue.toLocaleString()}` : ''}
                        ${task.estimatedTime ? ` · ${task.estimatedTime}분` : ''}
                      </div>
                    </div>
                    ${task.fromLog && task.logIndex !== undefined ? `
                      <div class="day-task-actions" style="display:flex;gap:4px;align-items:center;">
                        <button onclick="editCompletionLogEntry('${selectedDate}', ${task.logIndex})"
                          style="background:none;border:none;cursor:pointer;padding:4px;font-size:14px;"
                          aria-label="기록 수정" title="수정">✏️</button>
                        <button onclick="deleteCompletionLogEntry('${selectedDate}', ${task.logIndex})"
                          style="background:none;border:none;cursor:pointer;padding:4px;font-size:14px;"
                          aria-label="기록 삭제" title="삭제">❌</button>
                      </div>
                    ` : `<div class="day-task-status">✅</div>`}
                  </div>
                `;
              }).join('')}
            </div>
          ` : `
            <div class="day-empty">
              <div class="day-empty-icon">📭</div>
              <div>이 날 완료한 작업이 없습니다</div>
              <button onclick="addCompletionLogEntry('${selectedDate}')"
                style="margin-top:12px;background:var(--accent-color);color:#fff;border:none;border-radius:8px;padding:8px 16px;font-size:14px;cursor:pointer;"
                aria-label="이 날짜에 기록 추가">➕ 기록 추가</button>
            </div>
          `}
        </div>
      `;
    }

    /**
     * 최근 기록 리스트 렌더링
     */
    function renderRecentHistory() {
      // completionLog + appState.tasks 통합 조회 (날짜별 그룹화)
      const grouped = {};

      // 1. completionLog 기반 (영구 기록)
      for (const [dateKey, entries] of Object.entries(appState.completionLog || {})) {
        if (!Array.isArray(entries)) continue; // 압축 데이터 스킵
        if (!grouped[dateKey]) grouped[dateKey] = [];
        entries.forEach((e, idx) => {
          grouped[dateKey].push({
            title: e.t,
            category: e.c,
            completedAt: dateKey + 'T' + e.at,
            expectedRevenue: e.rv || 0,
            _logDate: dateKey,
            _logIndex: idx
          });
        });
      }

      // 2. appState.tasks 보완 (completionLog에 없는 항목)
      appState.tasks.forEach(t => {
        if (!t.completed || !t.completedAt) return;
        const dateKey = getLocalDateStr(new Date(t.completedAt));
        if (!grouped[dateKey]) grouped[dateKey] = [];
        const timeStr = new Date(t.completedAt).toTimeString().slice(0, 5);
        const exists = grouped[dateKey].some(e => {
          const eTime = new Date(e.completedAt).toTimeString().slice(0, 5);
          return e.title === t.title && eTime === timeStr;
        });
        if (!exists) {
          grouped[dateKey].push(t);
        }
      });

      const allDates = Object.keys(grouped);
      if (allDates.length === 0) {
        return `
          <div class="day-empty">
            <div class="day-empty-icon">📝</div>
            <div>아직 완료한 작업이 없습니다</div>
            <div style="margin-top: 10px; font-size: 14px; color: var(--text-secondary);">
              작업을 완료하면 여기에 기록됩니다
            </div>
          </div>
        `;
      }

      // 최근 날짜순 정렬 — 30일
      const sortedDates = allDates.sort((a, b) => new Date(b) - new Date(a));
      const recentDates = sortedDates.slice(0, 30);

      return `
        <div class="history-list">
          ${recentDates.map(dateStr => {
            const tasks = grouped[dateStr].sort((a, b) =>
              new Date(a.completedAt) - new Date(b.completedAt)
            );
            const date = new Date(dateStr);
            const dayNames = ['일', '월', '화', '수', '목', '금', '토'];
            const isToday = dateStr === getLocalDateStr();
            const isYesterday = dateStr === getLocalDateStr(new Date(Date.now() - 86400000));

            let dateTitle;
            if (isToday) dateTitle = '오늘';
            else if (isYesterday) dateTitle = '어제';
            else dateTitle = `${date.getMonth() + 1}월 ${date.getDate()}일 (${dayNames[date.getDay()]})`;

            const isExpanded = appState.historyState.expandedDates[dateStr];
            const dayRevenue = tasks.reduce((s, t) => s + (t.expectedRevenue || 0), 0);

            return `
              <div class="history-date-group">
                <div class="history-date-header" onclick="toggleHistoryDate('${dateStr}')">
                  <div class="history-date-title">${dateTitle}</div>
                  <div class="history-date-count">✓ ${tasks.length}개${dayRevenue > 0 ? ` · 💰${dayRevenue.toLocaleString()}` : ''} ${isExpanded ? '▲' : '▼'}</div>
                </div>
                <div class="history-date-tasks ${isExpanded ? 'show' : ''}">
                  ${tasks.map(task => {
                    const time = new Date(task.completedAt).toLocaleTimeString('ko-KR', {
                      hour: '2-digit', minute: '2-digit'
                    });
                    const hasLog = task._logDate !== undefined && task._logIndex !== undefined;
                    return `
                      <div class="history-task">
                        <span class="history-task-check">✓</span>
                        <span class="history-task-title">${escapeHtml(task.title)}</span>
                        ${hasLog ? `<span class="history-task-time" onclick="editCompletionLogEntry('${task._logDate}', ${task._logIndex})" style="cursor:pointer;text-decoration:underline dotted;text-underline-offset:2px" title="클릭하여 날짜/시간 수정">${time}</span>` : `<span class="history-task-time">${time}</span>`}
                        ${hasLog ? `<button class="btn-small delete" onclick="deleteCompletionLogEntry('${task._logDate}', ${task._logIndex})" title="기록 삭제" aria-label="기록 삭제" style="padding:2px 6px;font-size:12px;min-width:28px;min-height:28px;opacity:0.4;margin-left:4px;">×</button>` : ''}
                      </div>
                    `;
                  }).join('')}
                </div>
              </div>
            `;
          }).join('')}
        </div>
      `;
    }

    // ============================================
    // 사용자 액션 핸들러
    // ============================================
    
    /**
     * 탭 전환
     */
    function switchTab(tab) {
      appState.currentTab = tab;
      renderStatic();
    }

    /**
     * 테마 전환
     */
    function toggleTheme() {
      appState.theme = appState.theme === 'dark' ? 'light' : 'dark';
      document.body.setAttribute('data-theme', appState.theme);
      saveState();
      renderStatic();
    }

    /**
     * 테마 적용 (페이지 로드 시)
     */
    function applyTheme() {
      document.body.setAttribute('data-theme', appState.theme);
    }

    /**
     * 설정 모달 열기
     */
    function openSettings() {
      appState.showSettings = true;
      renderStatic();
    }

    /**
     * 설정 모달 닫기
     */
    function closeSettings() {
      appState.showSettings = false;
      renderStatic();
    }

    /**
     * 개별 설정 업데이트
     */
    function updateSetting(key, value) {
      appState.settings[key] = value;
      saveState();
      renderStatic();
    }

    // ============================================
    // 템플릿 관리
    // ============================================

    /**
     * 현재 작업을 템플릿으로 저장
     */
    function saveAsTemplate(task) {
      const template = {
        id: generateId(),
        title: task.title,
        category: task.category,
        estimatedTime: task.estimatedTime,
        tags: task.tags || [],
        icon: getCategoryIcon(task.category)
      };

      appState.templates.push(template);
      saveTemplates();
      showToast('템플릿으로 저장되었습니다', 'success');
      renderStatic();
    }

    /**
     * 카테고리별 아이콘 반환
     */
    function getCategoryIcon(category) {
      switch(category) {
        case '본업': return '💼';
        case '부업': return '💰';
        case '일상': return '🏠';
        case '가족': return '👨‍👩‍👧';
        default: return '📌';
      }
    }

    /**
     * 템플릿 삭제
     */
    function deleteTemplate(templateId) {
      // Soft-Delete: 삭제 기록 남기기 (동기화 시 부활 방지)
      appState.deletedIds.templates[templateId] = new Date().toISOString();
      appState.templates = appState.templates.filter(t => t.id !== templateId);
      saveTemplates();
      renderStatic();
    }

    /**
     * 템플릿으로 작업 추가
     */
    function addFromTemplate(templateId) {
      const template = appState.templates.find(t => t.id === templateId);
      if (!template) return;

      const now = new Date().toISOString();
      appState.tasks.push({
        id: generateId(),
        title: template.title,
        category: template.category,
        deadline: '',
        estimatedTime: template.estimatedTime,
        link: '',
        expectedRevenue: '',
        tags: template.tags || [],
        completed: false,
        createdAt: now,
        updatedAt: now
      });

      saveState();
      renderStatic();
      showToast(`"${template.title}" 추가됨`, 'success');

      if (navigator.vibrate) {
        navigator.vibrate(50);
      }
    }

    /**
     * 빠른 추가에서 템플릿 저장
     */
    function saveCurrentAsTemplate() {
      const title = appState.quickAddValue.trim();
      if (!title) {
        showToast('제목을 먼저 입력하세요', 'error');
        return;
      }

      const template = {
        id: generateId(),
        title: title,
        category: '부업',
        estimatedTime: 10,
        tags: [],
        icon: '💰'
      };

      appState.templates.push(template);
      saveTemplates();
      appState.quickAddValue = '';
      const input = document.getElementById('quick-add-input');
      if (input) input.value = '';

      showToast('템플릿으로 저장됨', 'success');
      renderStatic();
    }

    /**
     * 템플릿 저장 (localStorage)
     */
    function saveTemplates() {
      try {
        if (!appState.user) {
          localStorage.setItem('navigator-templates', JSON.stringify(appState.templates));
        }
        // Firebase 동기화 (로그인된 경우)
        if (appState.user) {
          syncToFirebase();
        }
      } catch (e) {
        console.error('템플릿 저장 실패:', e);
      }
    }

    /**
     * 템플릿 로드 (localStorage)
     */
    function loadTemplates() {
      try {
        const saved = localStorage.getItem('navigator-templates');
        if (saved) {
          appState.templates = JSON.parse(saved);
        }
      } catch (e) {
        console.error('템플릿 로드 실패:', e);
        appState.templates = [];
      }
    }

    /**
     * 일상/가족 빠른 추가
     */
    function quickAddLifeTask() {
      const input = document.getElementById('life-quick-input');
      if (!input || !input.value.trim()) return;

      let title = input.value.trim();
      let category = '일상';

      // #가족 태그 감지
      if (title.includes('#가족')) {
        category = '가족';
        title = title.replace('#가족', '').trim();
      }

      const newTask = {
        id: generateId(),
        title: title,
        category: category,
        completed: false,
        deadline: '',
        estimatedTime: 15,
        link: '',
        expectedRevenue: '',
        repeatType: 'none',
        tags: [],
        subtasks: [],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };

      appState.tasks.push(newTask);
      saveState();
      input.value = '';
      renderStatic();

      // 바로 수정 모달 열기 (상세 설정 기회 제공)
      setTimeout(() => {
        appState.quickEditTaskId = newTask.id;
        showQuickEditModal(newTask);
      }, 100);
    }
    window.quickAddLifeTask = quickAddLifeTask;

    /**
     * 완료된 반복 작업 리셋 (일상 카테고리 반복 작업만)
     */
    function resetCompletedRepeatTasks() {
      const repeatTasks = appState.tasks.filter(t =>
        t.category === '일상' &&
        t.completed &&
        t.repeatType &&
        t.repeatType !== 'none'
      );

      if (repeatTasks.length === 0) {
        showToast('리셋할 반복 작업이 없습니다', 'info');
        return;
      }

      appState.tasks = appState.tasks.map(t => {
        if (t.category === '일상' && t.completed && t.repeatType && t.repeatType !== 'none') {
          return {
            ...t,
            completed: false,
            completedAt: null,
            updatedAt: new Date().toISOString()
          };
        }
        return t;
      });

      saveState();
      renderStatic();
      showToast(`${repeatTasks.length}개 반복 작업 리셋됨`, 'success');
    }
    window.resetCompletedRepeatTasks = resetCompletedRepeatTasks;

    /**
     * 본업 빠른 추가 (프로젝트 없이)
     */
    function quickAddWorkTask() {
      const input = document.getElementById('work-quick-input');
      if (!input || !input.value.trim()) return;

      const newTask = {
        id: generateId(),
        title: input.value.trim(),
        category: '본업',
        completed: false,
        deadline: '',
        estimatedTime: 30,
        link: '',
        expectedRevenue: '',
        repeatType: 'none',
        tags: [],
        subtasks: [],
        workProjectId: null,
        workStageIdx: null,
        workSubcatIdx: null,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };

      appState.tasks.push(newTask);
      saveState();
      input.value = '';
      renderStatic();

      // 바로 수정 모달 열기 (상세 설정 기회 제공)
      setTimeout(() => {
        appState.quickEditTaskId = newTask.id;
        showQuickEditModal(newTask);
      }, 100);
    }
    window.quickAddWorkTask = quickAddWorkTask;

    /**
     * 이벤트 빠른 추가 (이벤트 탭에서 바로)
     */
    function quickAddEvent() {
      const input = document.getElementById('event-quick-input');
      if (!input || !input.value.trim()) return;

      const title = input.value.trim();

      // 주최자 자동 감지 (불개미, 코같투, 맨틀 등)
      const organizers = ['불개미', '코같투', '맨틀', '핀테크', '길드'];
      let organizer = '';
      for (const org of organizers) {
        if (title.includes(org)) {
          organizer = org;
          break;
        }
      }

      const newTask = {
        id: generateId(),
        title: title,
        category: '부업',
        completed: false,
        deadline: '',
        estimatedTime: 10,
        link: '',
        expectedRevenue: '',
        organizer: organizer,
        eventType: '',
        repeatType: 'none',
        tags: [],
        subtasks: [],
        createdAt: new Date().toISOString()
      };

      appState.tasks.push(newTask);
      saveState();
      input.value = '';
      renderStatic();

      // 바로 수정 모달 열기 (상세 설정 기회 제공)
      setTimeout(() => {
        appState.quickEditTaskId = newTask.id;
        showQuickEditModal(newTask);
      }, 100);
    }
    window.quickAddEvent = quickAddEvent;

    /**
     * 부업 이벤트 상세 추가 (부업 탭에서 호출)
     */
    function addNewEvent() {
      appState.detailedTask = {
        title: '',
        category: '부업',
        startDate: '',
        deadline: '',
        estimatedTime: 10,
        link: '',
        expectedRevenue: '',
        description: '',
        repeatType: 'none',
        repeatDays: [],
        repeatMonthDay: null,
        organizer: '',
        eventType: '',
        tags: [],
        subtasks: []
      };
      appState.showDetailedAdd = true;
      appState.editingTaskId = null;
      appState.currentTab = 'action';
      renderStatic();
      // 폼으로 스크롤
      setTimeout(() => {
        const form = document.querySelector('.detailed-add');
        if (form) form.scrollIntoView({ behavior: 'smooth' });
      }, 100);
    }

    /**
     * 셔틀 상태 토글
     */
    function toggleShuttle() {
      appState.shuttleSuccess = !appState.shuttleSuccess;
      saveState();
      renderStatic();
    }

    /**
     * 템플릿에서 빠른 추가
     */
    const quickTemplates = {
      writing: {
        title: '아티클 작성',
        category: '부업',
        estimatedTime: 30,
        link: 'http://localhost:3000/editor',
        tags: ['글쓰기']
      }
    };

    function addFromTemplate(templateName) {
      const template = quickTemplates[templateName];
      if (!template) {
        showToast('템플릿을 찾을 수 없습니다', 'error');
        return;
      }

      const now = new Date().toISOString();
      appState.tasks.push({
        id: generateId(),
        ...template,
        completed: false,
        createdAt: now,
        updatedAt: now
      });

      saveState();
      renderStatic();
      showToast(`"${template.title}" 추가됨`, 'success');

      if (navigator.vibrate) {
        navigator.vibrate(50);
      }
    }
    window.addFromTemplate = addFromTemplate;

    /**
     * 카테고리 프리픽스 파싱 (#부업 제목 → 카테고리: 부업, 제목: 제목)
     */
    function parseCategoryPrefix(input) {
      const categoryMap = {
        '#부업': '부업',
        '#본업': '본업',
        '#일상': '일상',
        '#가족': '가족',
        '#크립토': '부업',
        '#에어드랍': '부업',
        '#이벤트': '부업'
      };

      let category = '부업';  // 기본값
      let title = input.trim();

      // 해시태그 패턴 매칭 (대소문자 무시)
      for (const [prefix, cat] of Object.entries(categoryMap)) {
        if (title.toLowerCase().startsWith(prefix.toLowerCase())) {
          category = cat;
          title = title.substring(prefix.length).trim();
          break;
        }
      }

      return { category, title };
    }

    /**
     * 빠른 추가 (제목만 입력) - 카테고리 프리픽스 지원
     * 사용법: "#부업 제목" 또는 "#본업 제목" 형식
     */
    function quickAdd() {
      const rawInput = appState.quickAddValue.trim();
      if (!rawInput) {
        showToast('제목을 입력하세요', 'error');
        return;
      }

      // 카테고리 프리픽스 파싱
      const { category, title } = parseCategoryPrefix(rawInput);

      if (!title) {
        showToast('제목을 입력하세요', 'error');
        return;
      }

      const now = new Date().toISOString();
      appState.tasks.push({
        id: generateId(),
        title: title,
        category: category,
        deadline: '',
        estimatedTime: 10,
        link: '',
        expectedRevenue: '',
        completed: false,
        createdAt: now,
        updatedAt: now
      });

      appState.quickAddValue = '';
      const input = document.getElementById('quick-add-input');
      if (input) input.value = '';

      saveState();
      renderStatic();
      showToast(`[${category}] 작업이 추가되었습니다`, 'success');

      if (navigator.vibrate) {
        navigator.vibrate(50);
      }
    }

    /**
     * 브레인 덤프 모달 표시
     * 여러 작업을 한 번에 입력 (한 줄에 하나씩, #카테고리 지원)
     */
    function showBrainDumpModal() {
      // 기존 모달 제거
      const existing = document.getElementById('brain-dump-modal');
      if (existing) existing.remove();

      const modal = document.createElement('div');
      modal.id = 'brain-dump-modal';
      modal.className = 'modal-overlay';
      modal.onclick = (e) => { if (e.target === modal) modal.remove(); };
      modal.innerHTML = `
        <div class="modal" style="max-width: 500px;">
          <div class="modal-header">
            <h2>🧠 브레인 덤프</h2>
          </div>
          <div class="modal-body">
            <textarea id="brain-dump-input" class="brain-dump-textarea"
              placeholder="한 줄에 하나씩 작업을 입력하세요&#10;&#10;예시:&#10;보고서 작성&#10;#부업 NFT 이벤트 확인&#10;#일상 장보기&#10;#가족 병원 예약"
            ></textarea>
            <div class="brain-dump-hint">
              💡 <strong>#부업</strong>, <strong>#본업</strong>, <strong>#일상</strong>, <strong>#가족</strong>으로 카테고리 지정 (기본: 부업)
            </div>
            <div class="brain-dump-count" id="brain-dump-count">0줄</div>
          </div>
          <div class="modal-footer" style="flex-direction: row; justify-content: flex-end;">
            <button class="btn-small" onclick="document.getElementById('brain-dump-modal').remove()" style="padding: 10px 20px; font-size: 15px;">취소</button>
            <button class="btn-small complete" onclick="processBrainDump()" style="padding: 10px 20px; font-size: 15px;">추가</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);

      const textarea = document.getElementById('brain-dump-input');
      textarea.focus();
      // 줄 수 카운터
      textarea.addEventListener('input', () => {
        const lines = textarea.value.split('\n').filter(l => l.trim()).length;
        document.getElementById('brain-dump-count').textContent = lines + '줄';
      });
    }

    /**
     * 브레인 덤프 처리 — textarea 내용을 줄 단위로 파싱하여 태스크 생성
     */
    function processBrainDump() {
      const textarea = document.getElementById('brain-dump-input');
      if (!textarea) return;

      const lines = textarea.value.split('\n').filter(l => l.trim());
      if (lines.length === 0) {
        showToast('작업을 입력하세요', 'error');
        return;
      }

      const now = new Date().toISOString();
      let addedCount = 0;

      for (const line of lines) {
        const { category, title } = parseCategoryPrefix(line.trim());
        if (!title) continue;

        appState.tasks.push({
          id: generateId(), // crypto.randomUUID 기반 고유 ID
          title: title,
          category: category,
          deadline: '',
          estimatedTime: 10,
          link: '',
          expectedRevenue: '',
          completed: false,
          createdAt: now,
          updatedAt: now
        });
        addedCount++;
      }

      if (addedCount === 0) {
        showToast('유효한 작업이 없습니다', 'error');
        return;
      }

      // 모달 닫기
      const modal = document.getElementById('brain-dump-modal');
      if (modal) modal.remove();

      // 한 번만 저장/렌더링 (성능 최적화)
      saveState();
      renderStatic();
      showToast(`${addedCount}개 작업이 추가되었습니다`, 'success');

      if (navigator.vibrate) {
        navigator.vibrate([50, 30, 50]);
      }
    }

    /**
     * 상세 추가/수정
     */
    function detailedAdd() {
      const task = appState.detailedTask;
      if (!task.title) {
        showToast('제목을 입력하세요', 'error');
        return;
      }

      // 본업 프로젝트에 연결된 경우
      if (task.category === '본업' && task.workProjectId && task.workSubcatIdx !== null) {
        const project = appState.workProjects.find(p => p.id === task.workProjectId);
        if (project) {
          const stageIdx = task.workStageIdx || 0;
          const subcatIdx = task.workSubcatIdx;
          const subcat = project.stages[stageIdx]?.subcategories?.[subcatIdx];

          if (subcat) {
            subcat.tasks.push({
              title: task.title,
              status: 'not-started',
              logs: [],
              createdAt: new Date().toISOString()
            });
            project.updatedAt = new Date().toISOString();
            saveWorkProjects();
            showToast(`"${project.name}" 프로젝트에 추가됨`, 'success');

            // 폼 초기화 후 종료
            appState.detailedTask = {
              title: '',
              category: '부업',
              startDate: '',
              deadline: '',
              estimatedTime: 10,
              link: '',
              expectedRevenue: '',
              description: '',
              repeatType: 'none',
              repeatDays: [],
              repeatMonthDay: null,
              organizer: '',
              eventType: '',
              tags: [],
              subtasks: [],
              workProjectId: null,
              workStageIdx: null,
              workSubcatIdx: null
            };
            appState.showDetailedAdd = false;
            renderStatic();
            return;
          }
        }
        showToast('프로젝트 연결 실패. 중분류를 확인하세요.', 'error');
        return;
      }

      if (appState.editingTaskId) {
        // 수정 모드
        appState.tasks = appState.tasks.map(t =>
          t.id === appState.editingTaskId
            ? { ...task, id: t.id, completed: t.completed, createdAt: t.createdAt, updatedAt: new Date().toISOString() }
            : t
        );
        showToast('작업이 수정되었습니다', 'success');
      } else {
        // 추가 모드
        const now = new Date().toISOString();
        appState.tasks.push({
          id: generateId(),
          ...task,
          completed: false,
          createdAt: now,
          updatedAt: now
        });
        showToast('작업이 추가되었습니다', 'success');
      }
      
      // 폼 초기화
      appState.detailedTask = {
        title: '',
        category: '부업',
        startDate: '',
        deadline: '',
        estimatedTime: 10,
        link: '',
        expectedRevenue: '',
        description: '',
        repeatType: 'none',
        repeatDays: [],
        repeatMonthDay: null,
        organizer: '',
        eventType: '',
        tags: [],
        subtasks: [],
        workProjectId: null,
        workStageIdx: null,
        workSubcatIdx: null
      };
      appState.showDetailedAdd = false;
      appState.editingTaskId = null;

      saveState();
      renderStatic();

      if (navigator.vibrate) {
        navigator.vibrate(50);
      }
    }

    /**
     * 작업 완료
     * 반복 작업인 경우 다음 주기로 새 작업 생성
     */
    function completeTask(id) {
      const task = appState.tasks.find(t => t.id === id);
      if (!task) return;

      // 이미 완료된 작업이면 무시 (중복 클릭 방지)
      if (task.completed) return;

      const now = new Date();
      const completedAt = now.toISOString();

      // 완료 처리
      appState.tasks = appState.tasks.map(t =>
        t.id === id ? { ...t, completed: true, completedAt: completedAt, updatedAt: completedAt } : t
      );

      // completionLog에 영구 기록 저장
      const dateKey = getLocalDateStr(now);
      const timeStr = now.toTimeString().slice(0, 5); // "HH:MM"
      const logEntry = { t: task.title, c: task.category, at: timeStr };
      if (task.repeatType && task.repeatType !== 'none') logEntry.r = task.repeatType;
      if (task.expectedRevenue) logEntry.rv = Number(task.expectedRevenue);
      if (task.subtasks && task.subtasks.length > 0) {
        const doneCount = task.subtasks.filter(s => s.completed).length;
        if (doneCount > 0) logEntry.st = doneCount;
      }
      if (!appState.completionLog[dateKey]) appState.completionLog[dateKey] = [];
      appState.completionLog[dateKey].push(logEntry);
      saveCompletionLog();

      // 오늘 통계 업데이트
      appState.todayStats.completedToday++;
      appState.todayStats.streak++;

      // 스트릭 기록
      recordActivity();

      // 반복 작업이면 다음 주기 작업 자동 생성
      // daily/weekdays는 checkDailyReset()이 자동 초기화하므로 중복 생성하지 않음
      if (task.repeatType && task.repeatType !== 'none'
          && task.repeatType !== 'daily' && task.repeatType !== 'weekdays') {
        // 동일 제목+카테고리+반복타입의 미완료 태스크가 이미 있으면 중복 생성 방지
        const isDuplicate = appState.tasks.some(t =>
          t.id !== task.id &&
          !t.completed &&
          t.title === task.title &&
          t.category === task.category &&
          t.repeatType === task.repeatType
        );
        if (!isDuplicate) {
          const nextTask = createNextRepeatTask(task);
          if (nextTask) {
            appState.tasks.push(nextTask);
          }
        }
      }

      saveState();

      // telegram-event-bot 연동: 연결된 이벤트 상태 업데이트
      if (task.source && task.source.type === 'telegram-event') {
        updateLinkedEventStatus(task, true);
      }

      // 완료 애니메이션 표시
      showCompletionAnimation(task.title, appState.todayStats.streak);

      // 실행취소 토스트 표시 (3초)
      showUndoToast(id, task.title);

      // 마일스톤 체크 (ADHD 특화 - 도파민 보상)
      checkMilestone();

      if (navigator.vibrate) {
        navigator.vibrate([50, 100, 50]);
      }
    }

    /**
     * 완료 애니메이션 표시
     */
    function showCompletionAnimation(taskTitle, streak) {
      const overlay = document.getElementById('completion-overlay');
      const titleEl = document.getElementById('completion-task-title');
      const streakEl = document.getElementById('completion-streak');

      if (overlay) {
        if (titleEl) titleEl.textContent = taskTitle;
        if (streakEl) {
          if (streak > 1) {
            streakEl.textContent = `🔥 ${streak}연속 완료!`;
            streakEl.style.display = 'block';
            streakEl.classList.add('streak-fire-animate');
          } else {
            streakEl.style.display = 'none';
          }
        }

        overlay.classList.add('show');

        // 5연속 이상이면 confetti 효과
        if (streak >= 5) {
          showConfetti();
        }

        setTimeout(() => {
          overlay.classList.remove('show');
          if (streakEl) streakEl.classList.remove('streak-fire-animate');
          renderStatic();
        }, 1500);
      } else {
        renderStatic();
      }
    }

    /**
     * Confetti 효과 표시
     */
    function showConfetti() {
      const container = document.createElement('div');
      container.className = 'confetti-container';
      document.body.appendChild(container);

      const colors = ['#667eea', '#764ba2', '#f093fb', '#48bb78', '#f6ad55', '#ed64a6'];
      const shapes = ['circle', 'square', 'triangle'];

      for (let i = 0; i < 100; i++) {
        const confetti = document.createElement('div');
        const color = colors[Math.floor(Math.random() * colors.length)];
        const shape = shapes[Math.floor(Math.random() * shapes.length)];

        confetti.className = `confetti ${shape}`;
        confetti.style.left = Math.random() * 100 + '%';
        confetti.style.background = shape !== 'triangle' ? color : 'transparent';
        confetti.style.color = color;
        confetti.style.animationDelay = Math.random() * 0.5 + 's';
        confetti.style.animationDuration = (Math.random() * 1 + 2) + 's';

        container.appendChild(confetti);
      }

      setTimeout(() => {
        container.remove();
      }, 4000);
    }

    /**
     * 성취 뱃지 팝업 표시
     */
    function showAchievement(icon, title, description) {
      const popup = document.createElement('div');
      popup.className = 'achievement-popup';
      popup.innerHTML = `
        <div class="achievement-icon">${escapeHtml(icon)}</div>
        <div class="achievement-title">${escapeHtml(title)}</div>
        <div class="achievement-desc">${escapeHtml(description)}</div>
      `;
      document.body.appendChild(popup);

      setTimeout(() => {
        popup.style.animation = 'achievement-pop 0.3s ease-in reverse forwards';
        setTimeout(() => popup.remove(), 300);
      }, 2500);
    }

    // ============================================
    // ADHD 특화 기능
    // ============================================

    let quickTimerInterval = null;

    /**
     * 5분 퀵타이머 시작
     */
    function startQuickTimer(taskId = null) {
      if (appState.quickTimer.isRunning) {
        stopQuickTimer();
        return;
      }

      appState.quickTimer = {
        isRunning: true,
        timeLeft: 5 * 60,
        taskId: taskId
      };

      showMotivation('시작이 반이에요! 5분만 집중해봐요 💪');

      quickTimerInterval = setInterval(() => {
        appState.quickTimer.timeLeft--;

        if (appState.quickTimer.timeLeft <= 0) {
          stopQuickTimer();
          showMotivation('5분 완료! 계속할 수 있어요! 🎉');
          if (navigator.vibrate) {
            navigator.vibrate([200, 100, 200]);
          }
        }

        renderQuickTimerDisplay();
      }, 1000);

      renderStatic();

      if (navigator.vibrate) {
        navigator.vibrate(100);
      }
    }
    window.startQuickTimer = startQuickTimer;

    /**
     * 퀵타이머 중지
     */
    function stopQuickTimer() {
      if (quickTimerInterval) {
        clearInterval(quickTimerInterval);
        quickTimerInterval = null;
      }
      appState.quickTimer.isRunning = false;
      appState.quickTimer.timeLeft = 5 * 60;
      renderStatic();
    }
    window.stopQuickTimer = stopQuickTimer;

    /**
     * 퀵타이머 디스플레이 업데이트
     */
    function renderQuickTimerDisplay() {
      const display = document.getElementById('quick-timer-display');
      if (display) {
        const mins = Math.floor(appState.quickTimer.timeLeft / 60);
        const secs = appState.quickTimer.timeLeft % 60;
        display.textContent = mins + ':' + String(secs).padStart(2, '0');
      }
    }

    /**
     * 동기부여 메시지 표시
     */
    function showMotivation(message) {
      appState.lastMotivation = message;

      // 기존 토스트 제거
      const existing = document.querySelector('.motivation-toast');
      if (existing) existing.remove();

      const toast = document.createElement('div');
      toast.className = 'motivation-toast';
      toast.textContent = message;
      document.body.appendChild(toast);

      setTimeout(() => {
        toast.remove();
      }, 3000);
    }
    window.showMotivation = showMotivation;

    /**
     * 축하 효과 (콘페티)
     */
    function showCelebration(emoji = '🎉') {
      appState.showCelebration = true;

      // 축하 텍스트
      const textEl = document.createElement('div');
      textEl.className = 'celebration-text';
      textEl.textContent = emoji;
      document.body.appendChild(textEl);

      // 콘페티 효과
      const overlay = document.createElement('div');
      overlay.className = 'celebration-overlay';
      const colors = ['#667eea', '#f093fb', '#4ecdc4', '#ffd93d', '#f5576c', '#48bb78'];

      for (let i = 0; i < 50; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.left = Math.random() * 100 + 'vw';
        confetti.style.top = '-10px';
        confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.animationDelay = Math.random() * 0.5 + 's';
        confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '2px';
        overlay.appendChild(confetti);
      }

      document.body.appendChild(overlay);

      setTimeout(() => {
        textEl.remove();
        overlay.remove();
        appState.showCelebration = false;
      }, 3000);
    }
    window.showCelebration = showCelebration;

    /**
     * 마일스톤 체크 및 축하
     */
    function checkMilestone() {
      const completed = appState.todayStats.completedToday;
      const dailyGoal = appState.settings.dailyGoal || 5;
      const streak = appState.todayStats.streak;

      // 일일 목표 달성
      if (completed === dailyGoal) {
        showCelebration('🎯');
        showAchievement('🏆', '일일 목표 달성!', `오늘 ${dailyGoal}개 작업을 완료했어요!`);
        showConfetti();
        return;
      }

      // 스트릭 마일스톤
      if (streak === 10) {
        showAchievement('🔥', '10연속 완료!', '멈출 수 없는 집중력!');
        showConfetti();
        return;
      }

      // 특정 개수 달성
      if (completed === 3) {
        showMotivation('좋아요! 3개 완료! 그 조자에요! 🔥');
      } else if (completed === 5) {
        showCelebration('⭐');
        showAchievement('⭐', '5개 돌파!', '반도 지나왔어요!');
      } else if (completed === 10) {
        showCelebration('🌟');
        showAchievement('🌟', '10개 달성!', '오늘 진짜 열일했네요!');
        showConfetti();
      } else if (completed === 20) {
        showAchievement('👑', '20개 마스터!', '당신은 오늘의 영웅입니다!');
        showConfetti();
      } else if (completed > 0 && completed % 5 === 0) {
        showMotivation(completed + '개 완료! 계속 가보자! 🚀');
      }
    }

    /**
     * 랜덤 동기부여 메시지
     */
    function getRandomMotivation() {
      const messages = [
        '지금 시작하면 5분 뒤엔 끝나있어요!',
        '완벽하지 않아도 괜찮아요, 시작만 하면 돼요!',
        '작은 한 걸음이 큰 변화를 만들어요',
        '할 수 있어요! 일단 시작해봐요 💪',
        '오늘 할 일은 오늘! 미루면 내일의 내가 힘들어요',
        '5분만 집중! 그게 시작이에요',
        '지금이 가장 좋은 타이밍이에요!'
      ];
      return messages[Math.floor(Math.random() * messages.length)];
    }

    /**
     * 반복 유형 라벨 반환
     */
    function getRepeatLabel(repeatType, task = null) {
      const labels = {
        'daily': '매일',
        'weekdays': '평일',
        'weekends': '주말',
        'weekly': '매주',
        'monthly': '매월'
      };

      if (repeatType === 'custom' && task && task.repeatDays && task.repeatDays.length > 0) {
        const dayNames = ['일', '월', '화', '수', '목', '금', '토'];
        const selectedDays = task.repeatDays.map(d => dayNames[d]).join(',');
        return `매주 ${selectedDays}`;
      }

      if (repeatType === 'monthly' && task && task.repeatMonthDay) {
        return `매월 ${task.repeatMonthDay}일`;
      }

      return labels[repeatType] || '';
    }

    /**
     * 다음 반복 작업 생성
     * 반복 작업은 항상 다음 날짜를 기준으로 생성됨 (오늘 목록에 즉시 나타나지 않음)
     */
    function createNextRepeatTask(task) {
      const now = new Date();
      let nextDeadline = null;

      // 마감일이 있으면 그 기준으로, 없으면 오늘 기준으로 다음 날짜 계산
      const baseDate = task.deadline ? new Date(task.deadline) : new Date();
      nextDeadline = new Date(baseDate);

      switch (task.repeatType) {
        case 'daily':
          nextDeadline.setDate(nextDeadline.getDate() + 1);
          break;
        case 'weekdays':
          // 평일만: 금요일이면 월요일로, 아니면 다음 날
          nextDeadline.setDate(nextDeadline.getDate() + 1);
          while (nextDeadline.getDay() === 0 || nextDeadline.getDay() === 6) {
            nextDeadline.setDate(nextDeadline.getDate() + 1);
          }
          break;
        case 'weekends':
          // 주말만: 토요일이면 일요일로, 일요일이면 토요일로
          nextDeadline.setDate(nextDeadline.getDate() + 1);
          while (nextDeadline.getDay() !== 0 && nextDeadline.getDay() !== 6) {
            nextDeadline.setDate(nextDeadline.getDate() + 1);
          }
          break;
        case 'weekly':
          nextDeadline.setDate(nextDeadline.getDate() + 7);
          break;
        case 'monthly':
          nextDeadline.setMonth(nextDeadline.getMonth() + 1);
          break;
        case 'custom':
          // 특정 요일 반복: 다음 해당 요일 찾기
          if (task.repeatDays && task.repeatDays.length > 0) {
            let found = false;
            for (let i = 1; i <= 7 && !found; i++) {
              nextDeadline.setDate(nextDeadline.getDate() + 1);
              if (task.repeatDays.includes(nextDeadline.getDay())) {
                found = true;
              }
            }
          } else {
            nextDeadline.setDate(nextDeadline.getDate() + 1);
          }
          break;
        default:
          nextDeadline.setDate(nextDeadline.getDate() + 1);
      }

      // 시간은 원래 작업과 동일하게 (없으면 자정)
      if (task.deadline) {
        const originalTime = new Date(task.deadline);
        nextDeadline.setHours(originalTime.getHours(), originalTime.getMinutes(), 0, 0);
      } else {
        nextDeadline.setHours(23, 59, 0, 0); // 마감일 없던 작업은 하루 끝으로
      }

      return {
        id: generateId(),
        title: task.title,
        category: task.category,
        deadline: getLocalDateTimeStr(nextDeadline),
        estimatedTime: task.estimatedTime,
        link: task.link,
        expectedRevenue: task.expectedRevenue,
        repeatType: task.repeatType,
        repeatDays: task.repeatDays, // 커스텀 요일 정보 유지
        completed: false,
        createdAt: now.toISOString(),
        updatedAt: now.toISOString()
      };
    }

    /**
     * 작업 완료 취소
     */
    function uncompleteTask(id) {
      const task = appState.tasks.find(t => t.id === id);
      if (!task) return;

      // 오늘 완료한 작업인지 확인
      const wasCompletedToday = task.completedAt &&
        new Date(task.completedAt).toDateString() === new Date().toDateString();

      // completionLog에서 해당 기록 제거
      if (task.completedAt) {
        const logDate = getLocalDateStr(new Date(task.completedAt));
        const logTime = new Date(task.completedAt).toTimeString().slice(0, 5);
        if (appState.completionLog[logDate]) {
          const idx = appState.completionLog[logDate].findIndex(
            e => e.t === task.title && e.at === logTime
          );
          if (idx !== -1) {
            appState.completionLog[logDate].splice(idx, 1);
            // 해당 날짜에 기록이 0개면 키 삭제
            if (appState.completionLog[logDate].length === 0) {
              delete appState.completionLog[logDate];
            }
            saveCompletionLog();
          }
        }
      }

      appState.tasks = appState.tasks.map(t =>
        t.id === id ? { ...t, completed: false, completedAt: null, updatedAt: new Date().toISOString() } : t
      );

      // 오늘 완료한 작업이었다면 통계 감소
      if (wasCompletedToday) {
        appState.todayStats.completedToday = Math.max(0, appState.todayStats.completedToday - 1);
        appState.todayStats.streak = Math.max(0, appState.todayStats.streak - 1);
      }

      // 반복 작업이었다면 자동 생성된 다음 회차 작업 제거
      if (task.repeatType && task.repeatType !== 'none') {
        // 같은 제목의 미완료 작업 중 방금 생성된 것 제거
        const recentTasks = appState.tasks.filter(t =>
          t.title === task.title &&
          !t.completed &&
          t.id !== id &&
          t.createdAt &&
          (new Date() - new Date(t.createdAt)) < 60000 // 1분 이내 생성된 것
        );
        if (recentTasks.length > 0) {
          const removeId = recentTasks[recentTasks.length - 1].id;
          appState.tasks = appState.tasks.filter(t => t.id !== removeId);
        }
      }

      saveState();

      // telegram-event-bot 연동: 연결된 이벤트 상태 업데이트
      if (task.source && task.source.type === 'telegram-event') {
        updateLinkedEventStatus(task, false);
      }

      renderStatic();
      showToast('완료 취소', 'success');
    }

    /**
     * 완료 날짜 수정
     */
    function editCompletedAt(id) {
      const task = appState.tasks.find(t => t.id === id);
      if (!task || !task.completedAt) return;

      const oldDate = new Date(task.completedAt);
      const oldDateStr = oldDate.toISOString().slice(0, 16); // datetime-local 형식

      // 모달 생성
      const modalHtml = `
        <div class="work-modal-overlay" id="edit-completed-modal" onclick="if(event.target===this) closeEditCompletedModal()">
          <div class="work-modal" onclick="event.stopPropagation()">
            <div class="work-modal-header">
              <h3>완료 날짜 수정</h3>
              <button class="work-modal-close" onclick="closeEditCompletedModal()">✕</button>
            </div>
            <div class="work-modal-body">
              <div class="work-modal-field">
                <label class="work-modal-label">완료 시각</label>
                <input type="datetime-local" class="work-modal-input" id="edit-completed-datetime" value="${oldDateStr}">
              </div>
              <div style="margin-top:8px;font-size:12px;color:var(--text-muted)">
                작업: ${escapeHtml(task.title)}
              </div>
            </div>
            <div class="work-modal-footer">
              <button class="work-modal-btn secondary" onclick="closeEditCompletedModal()">취소</button>
              <button class="work-modal-btn primary" onclick="saveCompletedAt(${id})">저장</button>
            </div>
          </div>
        </div>
      `;

      document.body.insertAdjacentHTML('beforeend', modalHtml);
      document.getElementById('edit-completed-datetime').focus();
    }
    window.editCompletedAt = editCompletedAt;

    function closeEditCompletedModal() {
      const modal = document.getElementById('edit-completed-modal');
      if (modal) modal.remove();
    }
    window.closeEditCompletedModal = closeEditCompletedModal;

    function saveCompletedAt(id) {
      const task = appState.tasks.find(t => t.id === id);
      if (!task) return;

      const input = document.getElementById('edit-completed-datetime');
      const newDateStr = input.value;
      if (!newDateStr) {
        showToast('날짜를 선택해주세요', 'error');
        return;
      }

      const newDate = new Date(newDateStr);
      const oldDate = task.completedAt ? new Date(task.completedAt) : null;

      // completionLog 업데이트
      if (oldDate) {
        const oldLogDate = getLocalDateStr(oldDate);
        const oldLogTime = oldDate.toTimeString().slice(0, 5);
        if (appState.completionLog[oldLogDate]) {
          const idx = appState.completionLog[oldLogDate].findIndex(
            e => e.t === task.title && e.at === oldLogTime
          );
          if (idx !== -1) {
            appState.completionLog[oldLogDate].splice(idx, 1);
            if (appState.completionLog[oldLogDate].length === 0) {
              delete appState.completionLog[oldLogDate];
            }
          }
        }
      }

      // 새 날짜로 completionLog 추가
      const newLogDate = getLocalDateStr(newDate);
      const newLogTime = newDate.toTimeString().slice(0, 5);
      if (!appState.completionLog[newLogDate]) {
        appState.completionLog[newLogDate] = [];
      }
      appState.completionLog[newLogDate].push({
        t: task.title,
        c: task.category,
        at: newLogTime,
        rv: task.expectedRevenue || 0
      });
      saveCompletionLog();

      // 태스크 업데이트
      appState.tasks = appState.tasks.map(t =>
        t.id === id ? { ...t, completedAt: newDate.toISOString(), updatedAt: new Date().toISOString() } : t
      );
      saveState();

      closeEditCompletedModal();
      renderStatic();
      showToast('완료 날짜 수정됨', 'success');
    }
    window.saveCompletedAt = saveCompletedAt;

    /**
     * 작업 수정 모드 진입 (빠른 수정 모달로 변경)
     */
    function editTask(id) {
      const task = appState.tasks.find(t => t.id === id);
      if (!task) return;

      // 빠른 수정 모달 열기 (탭 이동 없음)
      appState.quickEditTaskId = id;
      showQuickEditModal(task);
    }

    /**
     * 빠른 수정 모달 표시
     */
    function showQuickEditModal(task) {
      const modal = document.getElementById('quick-edit-modal');
      const body = document.getElementById('quick-edit-body');

      body.innerHTML = `
        <div class="work-modal-field">
          <label class="work-modal-label">제목</label>
          <input type="text" class="work-modal-input" id="quick-edit-title" value="${escapeHtml(task.title)}" autofocus>
        </div>
        <div class="work-modal-field">
          <label class="work-modal-label">설명 (선택)</label>
          <textarea class="work-modal-input" id="quick-edit-description" rows="2" placeholder="작업 내용, 메모 등">${escapeHtml(task.description || '')}</textarea>
        </div>
        <div class="work-modal-field">
          <label class="work-modal-label">카테고리</label>
          <select class="work-modal-input" id="quick-edit-category">
            <option value="본업" ${task.category === '본업' ? 'selected' : ''}>💼 본업</option>
            <option value="부업" ${task.category === '부업' ? 'selected' : ''}>💰 부업</option>
            <option value="일상" ${task.category === '일상' ? 'selected' : ''}>🌅 일상</option>
            <option value="가족" ${task.category === '가족' ? 'selected' : ''}>👨‍👩‍👧 가족</option>
          </select>
        </div>
        <div class="work-modal-field-row">
          <div class="work-modal-field half">
            <label class="work-modal-label">시작일</label>
            <input type="datetime-local" class="work-modal-input" id="quick-edit-startDate" value="${task.startDate || ''}">
          </div>
          <div class="work-modal-field half">
            <label class="work-modal-label">마감일</label>
            <input type="datetime-local" class="work-modal-input" id="quick-edit-deadline" value="${task.deadline || ''}">
          </div>
        </div>
        <div class="work-modal-field">
          <label class="work-modal-label">예상 시간 (분)</label>
          <input type="number" class="work-modal-input" id="quick-edit-time" value="${task.estimatedTime || ''}" min="1">
        </div>
        ${task.category === '부업' ? `
          <div class="work-modal-field">
            <label class="work-modal-label">예상 수익 (원)</label>
            <input type="number" class="work-modal-input" id="quick-edit-revenue" value="${task.expectedRevenue || ''}">
          </div>
        ` : ''}
      `;

      modal.classList.add('show');

      // 엔터키로 저장
      body.querySelector('#quick-edit-title').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') saveQuickEdit();
      });
    }

    /**
     * 빠른 수정 모달 닫기
     */
    function closeQuickEditModal() {
      const modal = document.getElementById('quick-edit-modal');
      modal.classList.remove('show');
      appState.quickEditTaskId = null;
    }
    window.closeQuickEditModal = closeQuickEditModal;

    /**
     * 빠른 수정 저장
     */
    function saveQuickEdit() {
      const id = appState.quickEditTaskId;
      if (!id) return;

      const title = document.getElementById('quick-edit-title').value.trim();
      if (!title) {
        showToast('제목을 입력하세요', 'error');
        return;
      }

      const description = document.getElementById('quick-edit-description').value.trim();
      const category = document.getElementById('quick-edit-category').value;
      const startDate = document.getElementById('quick-edit-startDate').value;
      const deadline = document.getElementById('quick-edit-deadline').value;
      const estimatedTime = parseInt(document.getElementById('quick-edit-time').value) || null;
      const revenueEl = document.getElementById('quick-edit-revenue');
      const expectedRevenue = revenueEl ? parseInt(revenueEl.value) || null : null;

      appState.tasks = appState.tasks.map(t => {
        if (t.id === id) {
          return {
            ...t,
            title,
            description,
            category,
            startDate,
            deadline,
            estimatedTime,
            expectedRevenue: expectedRevenue !== null ? expectedRevenue : t.expectedRevenue,
            updatedAt: new Date().toISOString()
          };
        }
        return t;
      });

      saveState();
      closeQuickEditModal();
      renderStatic();
      showToast('수정 완료', 'success');
    }
    window.saveQuickEdit = saveQuickEdit;

    /**
     * 상세 편집으로 이동
     */
    function openFullEdit() {
      const id = appState.quickEditTaskId;
      if (!id) return;

      const task = appState.tasks.find(t => t.id === id);
      if (!task) return;

      closeQuickEditModal();

      appState.detailedTask = { ...task };
      appState.showDetailedAdd = true;
      appState.editingTaskId = id;
      appState.currentTab = 'action';
      renderStatic();

      setTimeout(() => {
        const formEl = document.querySelector('.add-task-section');
        if (formEl) {
          formEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      }, 100);
    }
    window.openFullEdit = openFullEdit;

    /**
     * 수정 취소
     */
    function cancelEdit() {
      appState.detailedTask = {
        title: '',
        category: '부업',
        startDate: '',
        deadline: '',
        estimatedTime: 10,
        link: '',
        expectedRevenue: '',
        description: '',
        repeatType: 'none',
        repeatDays: [],
        repeatMonthDay: null,
        organizer: '',
        eventType: '',
        tags: [],
        subtasks: []
      };
      appState.showDetailedAdd = false;
      appState.editingTaskId = null;
      renderStatic();
    }

    /**
     * 작업 삭제
     */
    function deleteTask(id) {
      if (!confirm('정말 삭제하시겠습니까? (휴지통에서 복원 가능)')) return;

      const task = appState.tasks.find(t => t.id === id);
      if (task) {
        // 휴지통으로 이동 (30일 보관)
        appState.trash.push({ ...task, deletedAt: new Date().toISOString() });
      }
      // Soft-Delete: 삭제 기록 남기기 (동기화 시 부활 방지)
      appState.deletedIds.tasks[id] = new Date().toISOString();
      appState.tasks = appState.tasks.filter(t => t.id !== id);
      saveState();
      renderStatic();
      showToast('휴지통으로 이동했습니다 (30일 보관)', 'success');
    }

    /**
     * 이벤트 일괄 선택 모드 토글
     */
    function toggleEventBulkSelect() {
      _eventBulkSelectMode = !_eventBulkSelectMode;
      _eventBulkSelectedIds.clear();
      renderStatic();
    }

    /**
     * 이벤트 개별 선택 토글
     */
    function toggleEventSelection(id) {
      if (_eventBulkSelectedIds.has(id)) {
        _eventBulkSelectedIds.delete(id);
      } else {
        _eventBulkSelectedIds.add(id);
      }
      renderStatic();
    }

    /**
     * 이벤트 전체 선택/해제
     */
    function toggleEventSelectAll() {
      const eventTasks = appState.tasks.filter(t => t.category === '부업');
      if (_eventBulkSelectedIds.size === eventTasks.length) {
        // 전체 해제
        _eventBulkSelectedIds.clear();
      } else {
        // 전체 선택
        eventTasks.forEach(t => _eventBulkSelectedIds.add(t.id));
      }
      renderStatic();
    }

    /**
     * 선택된 이벤트 일괄 삭제 (soft-delete)
     */
    function bulkDeleteEvents() {
      const count = _eventBulkSelectedIds.size;
      if (count === 0) return;
      if (!confirm(count + '개 이벤트를 삭제하시겠습니까? (휴지통에서 복원 가능)')) return;

      const now = new Date().toISOString();
      _eventBulkSelectedIds.forEach(id => {
        const task = appState.tasks.find(t => t.id === id);
        if (task) {
          appState.trash.push({ ...task, deletedAt: now });
        }
        appState.deletedIds.tasks[id] = now;
      });
      appState.tasks = appState.tasks.filter(t => !_eventBulkSelectedIds.has(t.id));

      _eventBulkSelectedIds.clear();
      _eventBulkSelectMode = false;

      saveState();
      renderStatic();
      showToast(count + '개 이벤트가 삭제되었습니다', 'success');
    }

    /**
     * 이벤트 그룹 접기/펼치기
     */
    function toggleEventGroup(groupId) {
      if (_collapsedEventGroups.has(groupId)) {
        _collapsedEventGroups.delete(groupId);
      } else {
        _collapsedEventGroups.add(groupId);
      }
      renderStatic();
    }

    /**
     * 휴지통에서 태스크 복원
     */
    function restoreFromTrash(id) {
      const idx = appState.trash.findIndex(t => t.id === id);
      if (idx === -1) return;

      const task = { ...appState.trash[idx] };
      delete task.deletedAt;

      // deletedIds에서도 제거 (동기화 시 다시 삭제되지 않도록)
      delete appState.deletedIds.tasks[id];

      appState.tasks.push(task);
      appState.trash.splice(idx, 1);
      saveState();
      renderStatic();
      showToast('"' + (task.title || '작업') + '" 복원되었습니다', 'success');
    }

    /**
     * 휴지통에서 영구 삭제
     */
    function permanentDeleteFromTrash(id) {
      if (!confirm('영구 삭제하면 복원할 수 없습니다. 진행하시겠습니까?')) return;
      appState.trash = appState.trash.filter(t => t.id !== id);
      saveState();
      renderStatic();
      showToast('영구 삭제되었습니다', 'info');
    }

    /**
     * 휴지통 비우기
     */
    function emptyTrash() {
      if (appState.trash.length === 0) return;
      if (!confirm('휴지통을 비우면 ' + appState.trash.length + '개 항목이 영구 삭제됩니다. 진행하시겠습니까?')) return;
      appState.trash = [];
      saveState();
      renderStatic();
      showToast('휴지통을 비웠습니다', 'info');
    }

    /**
     * 30일 이상 된 휴지통 항목 자동 정리
     */
    function cleanupOldTrash() {
      const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString();
      const before = appState.trash.length;
      appState.trash = appState.trash.filter(t => t.deletedAt && t.deletedAt > thirtyDaysAgo);
      if (appState.trash.length < before) {
        console.log('[trash] ' + (before - appState.trash.length) + '개 만료 항목 정리');
      }
    }

    /**
     * 이벤트 그룹별 전체 선택
     */
    function toggleEventGroupSelect(taskIds) {
      // taskIds 배열의 모든 항목이 이미 선택되어 있으면 해제, 아니면 전체 선택
      const allSelected = taskIds.every(id => _eventBulkSelectedIds.has(id));
      if (allSelected) {
        taskIds.forEach(id => _eventBulkSelectedIds.delete(id));
      } else {
        taskIds.forEach(id => _eventBulkSelectedIds.add(id));
      }
      renderStatic();
    }

    /**
     * 작업 복사
     */
    function copyTask(id) {
      const task = appState.tasks.find(t => t.id === id);
      if (!task) return;

      const now = new Date().toISOString();
      const newTask = {
        ...task,
        id: generateId(),
        title: task.title + ' (복사)',
        completed: false,
        createdAt: now,
        updatedAt: now
      };

      appState.tasks.push(newTask);
      saveState();
      renderStatic();
      showToast('작업이 복사되었습니다', 'success');
    }

    /**
     * 드래그 앤 드롭 - 드래그 시작
     */
    function handleDragStart(e, taskId) {
      appState.draggedTaskId = taskId;
      e.target.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', taskId);
    }

    /**
     * 드래그 앤 드롭 - 드래그 종료
     */
    function handleDragEnd(e) {
      e.target.classList.remove('dragging');
      appState.draggedTaskId = null;

      // 모든 드롭 타겟 표시 제거
      document.querySelectorAll('.drag-over').forEach(el => {
        el.classList.remove('drag-over');
      });
    }

    /**
     * 드래그 앤 드롭 - 드래그 오버
     */
    function handleDragOver(e, taskId) {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';

      const targetEl = e.currentTarget;
      if (!targetEl.classList.contains('drag-over') && appState.draggedTaskId !== taskId) {
        document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
        targetEl.classList.add('drag-over');
      }
    }

    /**
     * 드래그 앤 드롭 - 드롭
     */
    function handleDrop(e, targetTaskId) {
      e.preventDefault();

      const draggedId = appState.draggedTaskId;
      if (!draggedId || draggedId === targetTaskId) return;

      const tasks = appState.tasks;
      const draggedIndex = tasks.findIndex(t => t.id === draggedId);
      const targetIndex = tasks.findIndex(t => t.id === targetTaskId);

      if (draggedIndex === -1 || targetIndex === -1) return;

      // 작업 순서 변경
      const [draggedTask] = tasks.splice(draggedIndex, 1);
      tasks.splice(targetIndex, 0, draggedTask);

      appState.tasks = tasks;
      saveState();
      renderStatic();
      showToast('순서가 변경되었습니다', 'success');
    }

    /**
     * 링크 열기
     */
    function handleGo(link) {
      if (link) {
        window.open(link, '_blank');
      }
    }

    /**
     * 작업 리스트 토글
     */
    function toggleTaskList() {
      appState.showTaskList = !appState.showTaskList;
      renderStatic();
    }

    /**
     * 완료된 작업 보기 토글
     */
    function toggleCompletedTasks() {
      appState.showCompletedTasks = !appState.showCompletedTasks;
      renderStatic();
    }

    /**
     * 상세 추가 폼 토글
     */
    function toggleDetailedAdd() {
      appState.showDetailedAdd = !appState.showDetailedAdd;
      
      // 수정 중이었으면 취소
      if (!appState.showDetailedAdd && appState.editingTaskId) {
        cancelEdit();
        return;
      }
      
      renderStatic();
    }

    /**
     * 전체 탭에서 카테고리별 완료 작업 토글
     */
    function toggleCompletedCategory(category) {
      if (!appState.showCompletedByCategory) {
        appState.showCompletedByCategory = {};
      }
      appState.showCompletedByCategory[category] = !appState.showCompletedByCategory[category];
      renderStatic();
    }

    /**
     * 카테고리 변경 시 호출
     */
    function updateDetailedTaskCategory(category) {
      appState.detailedTask.category = category;
      // 카테고리 변경 시 프로젝트 연결 초기화
      if (category !== '본업') {
        appState.detailedTask.workProjectId = null;
        appState.detailedTask.workStageIdx = null;
        appState.detailedTask.workSubcatIdx = null;
      }
      renderStatic();
    }

    /**
     * 본업 프로젝트 연결
     */
    function updateWorkProjectLink(projectId) {
      if (projectId) {
        appState.detailedTask.workProjectId = String(projectId);
        appState.detailedTask.workStageIdx = 0;
        // 첫 번째 중분류 선택
        const proj = appState.workProjects.find(p => p.id === String(projectId));
        if (proj?.stages[0]?.subcategories?.length > 0) {
          appState.detailedTask.workSubcatIdx = 0;
        } else {
          appState.detailedTask.workSubcatIdx = null;
        }
      } else {
        appState.detailedTask.workProjectId = null;
        appState.detailedTask.workStageIdx = null;
        appState.detailedTask.workSubcatIdx = null;
      }
      renderStatic();
    }
    window.updateWorkProjectLink = updateWorkProjectLink;

    /**
     * 본업 단계 연결
     */
    function updateWorkStageLink(stageIdx) {
      appState.detailedTask.workStageIdx = parseInt(stageIdx);
      // 해당 단계의 첫 번째 중분류 선택
      const proj = appState.workProjects.find(p => p.id === appState.detailedTask.workProjectId);
      if (proj?.stages[stageIdx]?.subcategories?.length > 0) {
        appState.detailedTask.workSubcatIdx = 0;
      } else {
        appState.detailedTask.workSubcatIdx = null;
      }
      renderStatic();
    }
    window.updateWorkStageLink = updateWorkStageLink;

    /**
     * 본업 중분류 연결
     */
    function updateWorkSubcatLink(subcatIdx) {
      appState.detailedTask.workSubcatIdx = parseInt(subcatIdx);
      renderStatic();
    }
    window.updateWorkSubcatLink = updateWorkSubcatLink;

    /**
     * 태그를 작업에 추가
     */
    function addTagToTask(tag) {
      if (!appState.detailedTask.tags) {
        appState.detailedTask.tags = [];
      }
      if (!appState.detailedTask.tags.includes(tag)) {
        appState.detailedTask.tags.push(tag);
        renderStatic();
      }
    }

    /**
     * 작업에서 태그 제거
     */
    function removeTagFromTask(tag) {
      if (appState.detailedTask.tags) {
        appState.detailedTask.tags = appState.detailedTask.tags.filter(t => t !== tag);
        renderStatic();
      }
    }

    /**
     * 새 태그 추가 (전역 목록에도 추가)
     */
    function addNewTag(tagName) {
      const tag = tagName.trim();
      if (!tag) return;

      // 전역 태그 목록에 추가
      if (!appState.availableTags.includes(tag)) {
        appState.availableTags.push(tag);
        saveState();
      }

      // 현재 작업에도 추가
      addTagToTask(tag);
    }

    /**
     * 서브태스크 추가
     */
    function addSubtask(text) {
      const subtaskText = text.trim();
      if (!subtaskText) return;

      if (!appState.detailedTask.subtasks) {
        appState.detailedTask.subtasks = [];
      }

      appState.detailedTask.subtasks.push({
        text: subtaskText,
        completed: false,
        completedAt: null
      });
      renderStatic();
    }

    /**
     * 서브태스크 제거
     */
    function removeSubtask(index) {
      if (appState.detailedTask.subtasks) {
        appState.detailedTask.subtasks.splice(index, 1);
        renderStatic();
      }
    }

    /**
     * 상세 입력 폼에서 서브태스크 완료 토글
     */
    function toggleDetailedSubtask(index) {
      if (appState.detailedTask.subtasks && appState.detailedTask.subtasks[index]) {
        appState.detailedTask.subtasks[index].completed = !appState.detailedTask.subtasks[index].completed;
        appState.detailedTask.subtasks[index].completedAt = appState.detailedTask.subtasks[index].completed
          ? new Date().toISOString()
          : null;

        // 수정 중인 작업이면 실제 작업에도 반영
        if (appState.editingTaskId) {
          const task = appState.tasks.find(t => t.id === appState.editingTaskId);
          if (task && task.subtasks) {
            task.subtasks = [...appState.detailedTask.subtasks];
            saveState();
          }
        }
        renderStatic();
      }
    }

    /**
     * 서브태스크 완료 토글 (작업 내에서)
     */
    function toggleSubtaskComplete(taskId, subtaskIndex) {
      const task = appState.tasks.find(t => t.id === taskId);
      if (task && task.subtasks && task.subtasks[subtaskIndex]) {
        task.subtasks[subtaskIndex].completed = !task.subtasks[subtaskIndex].completed;
        task.subtasks[subtaskIndex].completedAt = task.subtasks[subtaskIndex].completed
          ? new Date().toISOString()
          : null;
        saveState();
        renderStatic();
      }
    }

    /**
     * 서브태스크 목록 펼치기/접기
     */
    function toggleSubtaskExpand(taskId) {
      if (!appState.expandedSubtasks) {
        appState.expandedSubtasks = {};
      }
      appState.expandedSubtasks[taskId] = !appState.expandedSubtasks[taskId];
      renderStatic();
    }

    /**
     * 본업 일반 작업 세부작업 펼침/접힘
     */
    function toggleWorkGeneralSubtask(taskId) {
      if (!appState.expandedWorkGeneralSubtasks) {
        appState.expandedWorkGeneralSubtasks = {};
      }
      appState.expandedWorkGeneralSubtasks[taskId] = !appState.expandedWorkGeneralSubtasks[taskId];
      renderStatic();
    }
    window.toggleWorkGeneralSubtask = toggleWorkGeneralSubtask;

    /**
     * 반복 유형 변경 시 호출
     */
    function updateDetailedTaskRepeat(repeatType) {
      appState.detailedTask.repeatType = repeatType;
      // 타입 변경 시 관련 필드 초기화
      if (repeatType !== 'custom') {
        appState.detailedTask.repeatDays = [];
      }
      if (repeatType !== 'monthly') {
        appState.detailedTask.repeatMonthDay = null;
      }
      renderStatic();
    }

    /**
     * 특정 요일 토글
     */
    function toggleRepeatDay(dayIndex) {
      if (!appState.detailedTask.repeatDays) {
        appState.detailedTask.repeatDays = [];
      }
      const days = appState.detailedTask.repeatDays;
      const idx = days.indexOf(dayIndex);
      if (idx === -1) {
        days.push(dayIndex);
      } else {
        days.splice(idx, 1);
      }
      days.sort((a, b) => a - b);
      renderStatic();
    }

    /**
     * 매월 반복일 설정
     */
    function updateRepeatMonthDay(day) {
      const dayNum = parseInt(day);
      appState.detailedTask.repeatMonthDay = (dayNum >= 1 && dayNum <= 31) ? dayNum : null;
    }

    /**
     * 일정 필터 변경
     */
    function setScheduleFilter(filter) {
      appState.scheduleFilter = filter;
      renderStatic();
    }

    /**
     * 검색어 변경
     */
    function setSearchQuery(query) {
      appState.searchQuery = query;
      renderStatic();
    }

    /**
     * 검색어 클리어
     */
    function clearSearch() {
      appState.searchQuery = '';
      renderStatic();
    }

    /**
     * 카테고리 필터 변경
     */
    function setCategoryFilter(category) {
      appState.categoryFilter = category;
      renderStatic();
    }

    /**
     * 태그 필터 설정
     */
    function setTagFilter(tag) {
      appState.tagFilter = appState.tagFilter === tag ? null : tag;
      renderStatic();
    }

    // ============================================
    // 주간 리뷰 & 계획 시스템
    // ============================================

    /**
     * 주간 리뷰 필요 여부 체크 (일요일 저녁)
     */
    function checkWeeklyReview() {
      const now = new Date();
      const dayOfWeek = now.getDay(); // 0 = 일요일
      const hour = now.getHours();
      const today = now.toDateString();

      // 일요일 18시 이후이고, 오늘 리뷰 안 했으면
      if (dayOfWeek === 0 && hour >= 18 && appState.weeklyPlan.lastReviewDate !== today) {
        showWeeklyReview();
      }
    }

    /**
     * 월요일 리마인더 필요 여부 체크
     */
    function checkMondayReminder() {
      const now = new Date();
      const dayOfWeek = now.getDay(); // 1 = 월요일
      const today = now.toDateString();

      // 월요일이고, 오늘 리마인더 안 보여줬고, 닫지 않았으면
      if (dayOfWeek === 1 &&
          appState.weeklyPlan.lastReminderDate !== today &&
          !appState.weeklyPlan.dismissed &&
          appState.weeklyPlan.focusTasks.length > 0) {
        return true;
      }
      return false;
    }

    /**
     * 주간 리뷰 모달 표시
     */
    function showWeeklyReview() {
      const modal = document.getElementById('weekly-review-modal');
      const content = document.getElementById('weekly-review-content');

      if (!modal || !content) return;

      const report = getWeeklyReport();
      const pendingTasks = appState.tasks.filter(t => !t.completed);

      // 비교 텍스트
      let compareText = '';
      let compareClass = '';
      if (report.change > 0) {
        compareText = `▲ 지난주보다 ${report.change}개 더 완료!`;
        compareClass = 'up';
      } else if (report.change < 0) {
        compareText = `▼ 지난주보다 ${Math.abs(report.change)}개 적음`;
        compareClass = 'down';
      } else {
        compareText = '지난주와 동일';
        compareClass = '';
      }

      content.innerHTML = `
        <div class="review-summary">
          <div class="review-summary-value">${report.thisWeekCount}</div>
          <div class="review-summary-label">이번 주 완료한 작업</div>
          <div class="review-summary-compare ${compareClass}">${compareText}</div>
        </div>

        <div class="weekly-plan-section">
          <div class="weekly-plan-title">🎯 다음 주 집중할 작업 선택 (최대 3개)</div>
          <div class="weekly-plan-list" id="weekly-plan-list">
            ${pendingTasks.slice(0, 10).map(task => `
              <div class="weekly-plan-item ${appState.weeklyPlan.focusTasks.includes(task.id) ? 'selected' : ''}"
                   onclick="toggleFocusTask('${task.id}')">
                <div class="weekly-plan-check">
                  ${appState.weeklyPlan.focusTasks.includes(task.id) ? '✓' : ''}
                </div>
                <div class="weekly-plan-item-title">${escapeHtml(task.title)}</div>
                <div class="weekly-plan-item-category">${task.category}</div>
              </div>
            `).join('')}
            ${pendingTasks.length === 0 ? '<div style="text-align: center; color: var(--text-muted); padding: 20px;">진행 중인 작업이 없어요!</div>' : ''}
          </div>
        </div>

        <div style="margin-top: 16px; padding: 12px; background: rgba(102, 126, 234, 0.1); border-radius: 8px; font-size: 13px; color: var(--text-secondary);">
          💡 선택한 작업은 월요일에 "이번 주 집중" 알림으로 표시됩니다.
        </div>
      `;

      modal.style.display = 'flex';
    }

    /**
     * 집중 작업 토글
     */
    function toggleFocusTask(taskId) {
      const idx = appState.weeklyPlan.focusTasks.indexOf(taskId);

      if (idx === -1) {
        // 추가 (최대 3개)
        if (appState.weeklyPlan.focusTasks.length < 3) {
          appState.weeklyPlan.focusTasks.push(taskId);
        } else {
          showToast('최대 3개까지 선택할 수 있어요', 'warning');
          return;
        }
      } else {
        // 제거
        appState.weeklyPlan.focusTasks.splice(idx, 1);
      }

      // UI 업데이트
      const items = document.querySelectorAll('.weekly-plan-item');
      items.forEach(item => {
        const id = parseInt(item.getAttribute('onclick').match(/\d+/)[0]);
        if (appState.weeklyPlan.focusTasks.includes(id)) {
          item.classList.add('selected');
          item.querySelector('.weekly-plan-check').textContent = '✓';
        } else {
          item.classList.remove('selected');
          item.querySelector('.weekly-plan-check').textContent = '';
        }
      });
    }

    /**
     * 주간 계획 저장
     */
    function saveWeeklyPlan() {
      appState.weeklyPlan.lastReviewDate = new Date().toDateString();
      appState.weeklyPlan.dismissed = false;
      saveState();
      closeWeeklyReview();
      showToast('다음 주 계획이 저장되었어요! 💪', 'success');
    }

    /**
     * 주간 리뷰 모달 닫기
     */
    function closeWeeklyReview() {
      const modal = document.getElementById('weekly-review-modal');
      if (modal) {
        modal.style.display = 'none';
      }
    }

    /**
     * 월요일 리마인더 닫기
     */
    function dismissMondayReminder() {
      appState.weeklyPlan.lastReminderDate = new Date().toDateString();
      appState.weeklyPlan.dismissed = true;
      saveState();
      renderStatic();
    }

    // ============================================
    // 퀵 필터 & 추가 기능
    // ============================================

    /**
     * 퀵 필터 설정
     */
    function setQuickFilter(filter) {
      appState.quickFilter = appState.quickFilter === filter ? null : filter;
      renderStatic();
    }

    /**
     * 퀵 필터 적용된 작업 수 계산
     */
    function getQuickFilterCount(filter) {
      const pending = appState.tasks.filter(t => !t.completed);
      switch (filter) {
        case '2min':
          return pending.filter(t => t.estimatedTime && t.estimatedTime <= 2).length;
        case '5min':
          return pending.filter(t => t.estimatedTime && t.estimatedTime <= 5).length;
        case 'urgent':
          return pending.filter(t => {
            if (!t.deadline) return false;
            const hoursLeft = (new Date(t.deadline) - new Date()) / (1000 * 60 * 60);
            return hoursLeft <= 24 && hoursLeft > 0;
          }).length;
        default:
          return 0;
      }
    }

    /**
     * 작업 내일로 미루기
     */
    function postponeTask(taskId) {
      const task = appState.tasks.find(t => t.id === taskId);
      if (!task) return;

      // 미루기 횟수 증가
      task.postponeCount = (task.postponeCount || 0) + 1;
      task.lastPostponed = new Date().toISOString();

      // 마감이 있으면 하루 연장
      if (task.deadline) {
        const deadline = new Date(task.deadline);
        deadline.setDate(deadline.getDate() + 1);
        task.deadline = getLocalDateTimeStr(deadline);
      }

      saveState();

      if (task.postponeCount >= 3) {
        showToast(`⚠️ 이 작업을 ${task.postponeCount}번 미뤘어요. 오늘 해치워버리는 건 어때요?`, 'warning');
      } else {
        showToast('내일로 미뤘어요. 오늘은 쉬어도 돼요! 😌', 'success');
      }

      renderStatic();
    }

    /**
     * 실제 소요시간 입력 모달 표시
     */
    function showTimeInputModal(taskId) {
      // 이미 모달이 열려있으면 기존 것 닫고 새로 열기
      if (appState.pendingTimeInput) closeTimeInputModal();
      appState.pendingTimeInput = taskId;
      renderStatic();

      // 모달 표시
      setTimeout(() => {
        const modal = document.getElementById('time-input-modal');
        if (modal) modal.classList.add('show');
      }, 50);
    }

    /**
     * 실제 소요시간 저장
     */
    function saveActualTime(minutes) {
      const taskId = appState.pendingTimeInput;
      if (!taskId) return;

      const parsed = parseInt(minutes);
      if (isNaN(parsed) || parsed <= 0) {
        showToast('유효한 시간을 입력해주세요', 'error');
        return;
      }

      const task = appState.tasks.find(t => t.id === taskId);
      if (task) {
        task.actualTime = parsed;
        saveState();
      }

      closeTimeInputModal();
      renderStatic();
    }

    /**
     * 실제 소요시간 입력 모달 닫기
     */
    function closeTimeInputModal() {
      const modal = document.getElementById('time-input-modal');
      if (modal) modal.classList.remove('show');
      appState.pendingTimeInput = null;
    }

    /**
     * 시간 예측 정확도 계산
     */
    function getTimeAccuracy() {
      const tasksWithBoth = appState.tasks.filter(t =>
        t.completed && t.estimatedTime && t.actualTime
      );

      if (tasksWithBoth.length < 3) return null;

      const totalEstimated = tasksWithBoth.reduce((sum, t) => sum + t.estimatedTime, 0);
      const totalActual = tasksWithBoth.reduce((sum, t) => sum + t.actualTime, 0);
      const ratio = totalActual / totalEstimated;

      return {
        ratio: ratio.toFixed(2),
        message: ratio > 1.2 ? '예상보다 시간이 더 걸려요' :
                 ratio < 0.8 ? '예상보다 빨리 끝내요!' :
                 '시간 예측이 정확해요!',
        count: tasksWithBoth.length
      };
    }

    /**
     * 오늘의 명언 가져오기
     */
    function getDailyQuote() {
      const quotes = [
        { text: "완벽하게 하려고 하지 마세요. 그냥 시작하세요.", author: "ADHD 생존 가이드" },
        { text: "5분만 해보자. 5분 후에 그만둬도 돼.", author: "포모도로 철학" },
        { text: "큰 일도 작은 조각으로 나누면 할 수 있어요.", author: "작업 분해의 힘" },
        { text: "지금 안 하면 내일의 내가 힘들어해요.", author: "미래의 나에게" },
        { text: "실수해도 괜찮아요. 다시 시작하면 돼요.", author: "성장 마인드셋" },
        { text: "오늘 할 일을 내일로 미루면, 내일은 두 배가 돼요.", author: "벤자민 프랭클린" },
        { text: "시작이 반이다. 나머지 반은 그냥 계속하는 것.", author: "동기부여 101" },
        { text: "완료된 50%가 완벽한 0%보다 낫다.", author: "실용주의" },
        { text: "휴식도 생산성의 일부예요. 쉴 때 쉬세요.", author: "번아웃 예방" },
        { text: "작은 승리를 축하하세요. 그게 큰 승리가 됩니다.", author: "도파민 관리법" },
        { text: "지금 이 순간에 집중하세요. 과거와 미래는 잠시 내려놓고.", author: "마음챙김" },
        { text: "어제보다 1%만 나아지면 1년 후엔 37배가 돼요.", author: "복리의 힘" },
        { text: "못하는 게 아니라, 아직 안 한 것뿐이에요.", author: "성장 마인드셋" },
        { text: "에너지가 낮을 때는 쉬운 것부터. 높을 때 어려운 것.", author: "에너지 관리" }
      ];

      // 오늘 날짜 기반 고정 인덱스 (하루 동안 같은 명언)
      const today = new Date();
      const dayOfYear = Math.floor((today - new Date(today.getFullYear(), 0, 0)) / (1000 * 60 * 60 * 24));
      const index = dayOfYear % quotes.length;

      return quotes[index];
    }

    /**
     * 랜덤 휴식 활동 추천
     */
    function getRestActivity() {
      const activities = [
        { icon: '🚶', text: '5분 산책하기', desc: '햇빛과 신선한 공기!' },
        { icon: '🧘', text: '스트레칭하기', desc: '몸을 풀어주세요' },
        { icon: '☕', text: '따뜻한 음료 마시기', desc: '잠시 여유를 즐기세요' },
        { icon: '🎵', text: '좋아하는 노래 듣기', desc: '기분 전환!' },
        { icon: '👀', text: '창밖 바라보기', desc: '눈의 피로를 풀어주세요' },
        { icon: '💭', text: '5분 명상하기', desc: '마음을 비우세요' },
        { icon: '🤸', text: '간단한 운동하기', desc: '점핑잭 10개 어때요?' },
        { icon: '📱', text: '친구에게 안부 보내기', desc: '연결의 기쁨' }
      ];

      return activities[Math.floor(Math.random() * activities.length)];
    }

    /**
     * 검색 및 필터 적용된 작업 목록
     */
    function getSearchFilteredTasks(tasks) {
      let filtered = tasks;

      // 카테고리 필터
      if (appState.categoryFilter !== 'all') {
        filtered = filtered.filter(t => t.category === appState.categoryFilter);
      }

      // 태그 필터
      if (appState.tagFilter) {
        filtered = filtered.filter(t => t.tags && t.tags.includes(appState.tagFilter));
      }

      // 검색어 필터 (제목, 태그, 서브태스크 포함)
      if (appState.searchQuery.trim()) {
        const query = appState.searchQuery.toLowerCase().trim();
        filtered = filtered.filter(t => {
          // 제목 검색
          if (t.title.toLowerCase().includes(query)) return true;
          // 태그 검색
          if (t.tags && t.tags.some(tag => tag.toLowerCase().includes(query))) return true;
          // 서브태스크 검색
          if (t.subtasks && t.subtasks.some(st => st.text.toLowerCase().includes(query))) return true;
          return false;
        });
      }

      return filtered;
    }

    /**
     * 날짜가 주말인지 확인
     */
    function isWeekend(date) {
      const day = date.getDay();
      return day === 0 || day === 6;
    }

    /**
     * 일정 뷰용 작업 그룹화 (날짜별)
     */
    function getTasksByDate() {
      const now = new Date();
      const tasks = appState.tasks.filter(t => !t.completed && t.deadline);
      const grouped = {};

      // 오늘부터 7일간의 날짜 생성
      for (let i = 0; i < 7; i++) {
        const date = new Date(now);
        date.setDate(date.getDate() + i);
        const dateKey = getLocalDateStr(date);
        grouped[dateKey] = {
          date: date,
          dayName: getDayName(date),
          isToday: i === 0,
          isWeekend: isWeekend(date),
          tasks: []
        };
      }

      // 작업을 날짜별로 분류
      tasks.forEach(task => {
        const taskDate = getLocalDateStr(new Date(task.deadline));
        if (grouped[taskDate]) {
          grouped[taskDate].tasks.push(task);
        }
      });

      // 각 날짜의 작업을 시간순 정렬
      Object.values(grouped).forEach(day => {
        day.tasks.sort((a, b) => new Date(a.deadline) - new Date(b.deadline));
      });

      // 필터 적용
      let result = Object.values(grouped);

      if (appState.scheduleFilter === 'weekday') {
        result = result.filter(day => !day.isWeekend);
      } else if (appState.scheduleFilter === 'weekend') {
        result = result.filter(day => day.isWeekend);
      } else if (appState.scheduleFilter === 'today') {
        result = result.filter(day => day.isToday);
      }

      return result;
    }

    /**
     * 요일 이름 반환
     */
    function getDayName(date) {
      const days = ['일', '월', '화', '수', '목', '금', '토'];
      const day = days[date.getDay()];
      const month = date.getMonth() + 1;
      const dateNum = date.getDate();
      return `${month}/${dateNum} (${day})`;
    }

    /**
     * 시간만 포맷팅
     */
    function formatTime(deadline) {
      const d = new Date(deadline);
      return d.toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' });
    }

    // ============================================
    // 스와이프 제스처
    // ============================================
    
    function handleTouchStart(e, taskId) {
      appState.touchStart = {
        x: e.touches[0].clientX,
        y: e.touches[0].clientY,
        taskId: taskId
      };
      appState.touchingTaskId = taskId;
    }

    function handleTouchMove(e, taskId) {
      if (!appState.touchStart || appState.touchStart.taskId !== taskId) return;

      const deltaX = e.touches[0].clientX - appState.touchStart.x;
      const deltaY = e.touches[0].clientY - appState.touchStart.y;
      const taskEl = document.getElementById(`task-${taskId}`);

      // 수평 스와이프가 수직보다 클 때만 스와이프로 인식
      if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 20) {
        e.preventDefault(); // 스크롤 방지

        if (deltaX < -30) {
          taskEl.classList.add('swiping-left');
          taskEl.classList.remove('swiping-right');
        } else if (deltaX > 30) {
          taskEl.classList.add('swiping-right');
          taskEl.classList.remove('swiping-left');
        }
      }
    }

    function handleTouchEnd(e, taskId) {
      if (!appState.touchStart || appState.touchStart.taskId !== taskId) return;
      if (!e.changedTouches || !e.changedTouches[0]) { appState.touchStart = null; return; }

      const deltaX = e.changedTouches[0].clientX - appState.touchStart.x;
      const taskEl = document.getElementById(`task-${taskId}`);

      if (deltaX < -100) {
        completeTask(taskId);
        if (navigator.vibrate) navigator.vibrate(50);
      } else if (deltaX > 100) {
        deleteTask(taskId);
        if (navigator.vibrate) navigator.vibrate([30, 30, 30]);
      }

      if (taskEl) {
        taskEl.classList.remove('swiping-left', 'swiping-right');
      }
      appState.touchStart = null;
      appState.touchingTaskId = null;
    }

    // ============================================
    // 백업/복원
    // ============================================
    
    /**
     * JSON으로 데이터 내보내기
     */
    function exportData() {
      try {
        const data = {
          version: '2.2',
          exportDate: new Date().toISOString(),
          tasks: appState.tasks,
          shuttleSuccess: appState.shuttleSuccess,
          availableTags: appState.availableTags,
          streak: appState.streak,
          theme: appState.theme,
          settings: appState.settings,
          templates: appState.templates,
          workProjects: appState.workProjects,
          workTemplates: appState.workTemplates,
          lifeRhythm: appState.lifeRhythm,
          weeklyPlan: appState.weeklyPlan,
          completionLog: appState.completionLog,
          trash: appState.trash
        };

        const json = JSON.stringify(data, null, 2);
        const blob = new Blob(['\uFEFF' + json], { type: 'application/json;charset=utf-8' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = `navigator-backup-${getLocalDateStr()}.json`;
        a.click();

        URL.revokeObjectURL(url);

        // 백업 시간 기록
        localStorage.setItem('navigator-last-backup', new Date().toISOString());

        showToast('📦 백업 완료!', 'success');
      } catch (error) {
        console.error('내보내기 실패:', error);
        showToast('백업 생성 중 오류가 발생했습니다', 'error');
      }
    }

    /**
     * JSON에서 데이터 가져오기
     */
    function importData() {
      const input = document.getElementById('file-import');
      input.value = ''; // 같은 파일 재선택 가능하도록 초기화
      input.click();
    }

    /**
     * 파일 선택 시 처리
     */
    function handleFileImport(e) {
      const file = e.target.files[0];
      if (!file) return;

      // JSON 파일만 허용
      if (!file.name.endsWith('.json') && !file.type.includes('json') && !file.type.includes('text')) {
        showToast('JSON 파일만 가져올 수 있습니다', 'error');
        return;
      }

      const reader = new FileReader();
      reader.onload = function(event) {
        try {
          // BOM 제거 후 파싱
          let text = event.target.result;
          if (typeof text !== 'string') { showToast('파일을 읽을 수 없습니다', 'error'); return; }
          if (text.charCodeAt(0) === 0xFEFF) text = text.slice(1);
          const data = JSON.parse(text);

          // 데이터 유효성 검사
          if (!data.tasks || !Array.isArray(data.tasks)) {
            throw new Error('잘못된 파일 형식입니다');
          }

          const importedTasks = validateTasks(data.tasks);
          const choice = confirm(
            `${importedTasks.length}개의 태스크를 가져옵니다.\n\n` +
            `[확인] = 기존 데이터와 병합 (추천)\n` +
            `[취소] = 가져오기 취소`
          );

          if (choice) {
            // 병합 (태스크별 타임스탬프 기반)
            appState.tasks = mergeTasks(appState.tasks, importedTasks);
            if (data.shuttleSuccess !== undefined) {
              appState.shuttleSuccess = data.shuttleSuccess;
            }
            if (data.availableTags) {
              appState.availableTags = [...new Set([...(appState.availableTags || []), ...data.availableTags])];
            }
            if (data.streak) {
              appState.streak = {
                lastActiveDate: appState.streak.lastActiveDate > data.streak.lastActiveDate
                  ? appState.streak.lastActiveDate : data.streak.lastActiveDate,
                best: Math.max(appState.streak.best || 0, data.streak.best || 0),
                current: appState.streak.lastActiveDate > data.streak.lastActiveDate
                  ? appState.streak.current : data.streak.current
              };
            }
            // 본업 프로젝트/템플릿 병합
            if (data.workProjects && Array.isArray(data.workProjects)) {
              const localProjectIds = new Set((appState.workProjects || []).map(p => p.id));
              const newProjects = data.workProjects.filter(p => !localProjectIds.has(p.id));
              appState.workProjects = [...(appState.workProjects || []), ...newProjects];
            }
            if (data.workTemplates && Array.isArray(data.workTemplates)) {
              const localTemplateIds = new Set((appState.workTemplates || []).map(t => t.id));
              const newTemplates = data.workTemplates.filter(t => !localTemplateIds.has(t.id));
              appState.workTemplates = [...(appState.workTemplates || []), ...newTemplates];
            }
            if (data.templates && Array.isArray(data.templates)) {
              const localTplIds = new Set((appState.templates || []).map(t => t.id));
              const newTpls = data.templates.filter(t => !localTplIds.has(t.id));
              appState.templates = [...(appState.templates || []), ...newTpls];
            }
            if (data.settings) {
              appState.settings = { ...appState.settings, ...data.settings };
            }
            // 라이프 리듬 병합
            if (data.lifeRhythm) {
              const importRhythm = data.lifeRhythm;
              const localRhythm = appState.lifeRhythm;
              appState.lifeRhythm = {
                ...localRhythm,
                history: { ...(localRhythm.history || {}), ...(importRhythm.history || {}) },
                today: importRhythm.today || localRhythm.today,
                settings: { ...(localRhythm.settings || {}), ...(importRhythm.settings || {}) }
              };
              saveLifeRhythm();
            }
          // 통근 트래커 병합
          if (data.commuteTracker) {
            const cloud = data.commuteTracker;
            const local = appState.commuteTracker;
            const routeMap = {};
            (local.routes || []).forEach(r => { routeMap[r.id] = r; });
            (cloud.routes || []).forEach(r => { if (!routeMap[r.id]) routeMap[r.id] = r; });
            appState.commuteTracker.routes = Object.values(routeMap);
            const mergedTrips = { ...(cloud.trips || {}), ...(local.trips || {}) };
            appState.commuteTracker.trips = mergedTrips;
            appState.commuteTracker.settings = { ...(cloud.settings || {}), ...(local.settings || {}) };
            localStorage.setItem('navigator-commute-tracker', JSON.stringify(appState.commuteTracker));
          }
            // 완료 기록 로그 병합
            if (data.completionLog) {
              appState.completionLog = mergeCompletionLog(appState.completionLog, data.completionLog);
            }
            // 주간 계획 병합
            if (data.weeklyPlan) {
              appState.weeklyPlan = data.weeklyPlan;
            }
            // 휴지통 병합
            if (Array.isArray(data.trash)) {
              const trashMap = new Map();
              (appState.trash || []).forEach(t => trashMap.set(t.id, t));
              data.trash.forEach(t => {
                if (!trashMap.has(t.id)) trashMap.set(t.id, t);
              });
              appState.trash = Array.from(trashMap.values());
            }
            saveState();
            recomputeTodayStats();
            renderStatic();
            showToast(`${importedTasks.length}개 태스크를 병합했습니다`, 'success');
          }
        } catch (error) {
          console.error('가져오기 실패:', error);
          showToast('파일을 읽을 수 없습니다', 'error');
        }
      };
      reader.readAsText(file, 'UTF-8');

      // 인풋 초기화 (같은 파일 다시 선택 가능하게)
      e.target.value = '';
    }

    // ============================================
    // UI 헬퍼
    // ============================================
    
    /**
     * 토스트 알림 표시
     */
    function showToast(message, type = 'success') {
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.textContent = message;
      document.body.appendChild(toast);

      setTimeout(() => {
        toast.remove();
      }, 2000);
    }

    /**
     * 실행취소 토스트 표시 (완료 후 3초간)
     */
    let undoToastTimeout = null;
    function showUndoToast(taskId, taskTitle) {
      // 기존 토스트 제거
      const existingToast = document.querySelector('.toast-undo');
      if (existingToast) existingToast.remove();
      if (undoToastTimeout) clearTimeout(undoToastTimeout);

      const toast = document.createElement('div');
      toast.className = 'toast-undo';
      toast.innerHTML = `
        <span class="toast-undo-text">✓ "${escapeHtml(taskTitle.substring(0, 15))}${taskTitle.length > 15 ? '...' : ''}" 완료</span>
        <button class="toast-undo-btn" onclick="undoComplete('${taskId}')">↩ 실행취소</button>
        <span class="toast-undo-timer">5</span>
      `;
      document.body.appendChild(toast);

      // 카운트다운 (5초)
      let countdown = 5;
      const timerEl = toast.querySelector('.toast-undo-timer');
      const interval = setInterval(() => {
        countdown--;
        if (timerEl) timerEl.textContent = countdown;
      }, 1000);

      // 5초 후 자동 제거
      undoToastTimeout = setTimeout(() => {
        clearInterval(interval);
        toast.remove();
      }, 5000);
    }

    /**
     * 실행취소 (토스트에서 호출)
     */
    function undoComplete(taskId) {
      // 토스트 즉시 제거
      const toast = document.querySelector('.toast-undo');
      if (toast) toast.remove();
      if (undoToastTimeout) clearTimeout(undoToastTimeout);

      // 완료 취소 처리
      uncompleteTask(taskId);
    }
    window.undoComplete = undoComplete;

    // ============================================
    // 온보딩 & 스트릭 & 포커스 모드
    // ============================================

    /**
     * 온보딩 모달 표시
     */
    function showOnboarding() {
      appState.showOnboarding = true;
      renderStatic();
    }

    /**
     * 온보딩 완료 및 샘플 데이터 추가
     */
    function completeOnboarding(addSamples = true) {
      localStorage.setItem('navigator-visited', 'true');
      appState.showOnboarding = false;

      if (addSamples) {
        const now = new Date();
        const tomorrow = new Date(now.getTime() + 24 * 60 * 60 * 1000);
        const nextWeek = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);

        const sampleTasks = [
          {
            id: generateId(),
            title: '👋 Navigator 사용법 익히기',
            category: '일상',
            estimatedTime: 5,
            tags: ['긴급'],
            subtasks: [
              { text: '작업 추가해보기', completed: false },
              { text: '완료 체크해보기', completed: false },
              { text: '태그 사용해보기', completed: false }
            ],
            completed: false,
            createdAt: now.toISOString()
          },
          {
            id: generateId(),
            title: '오늘 할 일 정리하기',
            category: '일상',
            estimatedTime: 10,
            deadline: getLocalDateTimeStr(tomorrow),
            tags: [],
            subtasks: [],
            completed: false,
            createdAt: now.toISOString()
          },
          {
            id: generateId(),
            title: '주간 목표 세우기',
            category: '본업',
            estimatedTime: 15,
            deadline: getLocalDateTimeStr(nextWeek),
            tags: ['회의'],
            subtasks: [],
            completed: false,
            createdAt: now.toISOString()
          }
        ];

        appState.tasks = sampleTasks;
        saveState();
        showToast('🎉 샘플 작업이 추가되었습니다!', 'success');
      }

      renderStatic();
    }

    /**
     * 스트릭 업데이트
     */
    function updateStreak() {
      const today = new Date().toDateString();
      const lastActive = appState.streak.lastActiveDate;

      if (!lastActive) {
        // 첫 사용
        return;
      }

      const lastDate = new Date(lastActive);
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);

      if (lastDate.toDateString() === yesterday.toDateString()) {
        // 어제 활동함 → 스트릭 유지
      } else if (lastDate.toDateString() !== today) {
        // 어제 활동 안 함 → 스트릭 리셋
        appState.streak.current = 0;
      }
    }

    /**
     * 오늘 활동 기록 (작업 완료 시 호출)
     */
    function recordActivity() {
      const today = new Date().toDateString();

      if (appState.streak.lastActiveDate !== today) {
        appState.streak.current++;
        appState.streak.lastActiveDate = today;

        if (appState.streak.current > appState.streak.best) {
          appState.streak.best = appState.streak.current;
        }

        if (!appState.user) {
          localStorage.setItem('navigator-streak', JSON.stringify(appState.streak));
        }

        if (appState.streak.current > 1) {
          showToast(`🔥 ${appState.streak.current}일 연속 달성!`, 'success');
        }
      }
    }

    /**
     * completionLog localStorage 저장
     */
    function saveCompletionLog() {
      try {
        if (!appState.user) {
          localStorage.setItem('navigator-completion-log', JSON.stringify(appState.completionLog));
        }
        // 로그인 사용자는 syncToFirebase()로 Firestore에 저장됨 (_doSaveState 경유)
      } catch (e) {
        console.error('완료 로그 저장 실패:', e);
      }
    }

    /**
     * completionLog localStorage 로드 + 기존 데이터 마이그레이션
     */
    function loadCompletionLog() {
      const parsed = safeParseJSON('navigator-completion-log', null);
      if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {
        appState.completionLog = parsed;
      }

      // 기존 사용자 마이그레이션: appState.tasks에 남아있는 완료 태스크를 completionLog로 이전
      if (Object.keys(appState.completionLog).length === 0) {
        let migrated = 0;
        appState.tasks.forEach(t => {
          if (t.completed && t.completedAt) {
            const d = new Date(t.completedAt);
            const dateKey = getLocalDateStr(d);
            const timeStr = d.toTimeString().slice(0, 5);
            if (!appState.completionLog[dateKey]) appState.completionLog[dateKey] = [];
            const entry = { t: t.title, c: t.category || '기타', at: timeStr };
            if (t.repeatType && t.repeatType !== 'none') entry.r = t.repeatType;
            if (t.expectedRevenue) entry.rv = Number(t.expectedRevenue);
            appState.completionLog[dateKey].push(entry);
            migrated++;
          }
        });
        // 기존 completion-history도 마이그레이션
        const oldHistory = safeParseJSON('navigator-completion-history', []);
        oldHistory.forEach(h => {
          if (h.completedAt) {
            const d = new Date(h.completedAt);
            const dateKey = getLocalDateStr(d);
            const timeStr = d.toTimeString().slice(0, 5);
            if (!appState.completionLog[dateKey]) appState.completionLog[dateKey] = [];
            // 중복 방지 (title+time 기준)
            const exists = appState.completionLog[dateKey].some(e => e.t === h.title && e.at === timeStr);
            if (!exists) {
              appState.completionLog[dateKey].push({
                t: h.title, c: h.category || '기타', at: timeStr
              });
              migrated++;
            }
          }
        });
        if (migrated > 0) {
          saveCompletionLog();
          console.log(`[migration] completionLog에 ${migrated}건 마이그레이션 완료`);
        }
      }
    }

    /**
     * completionLog 병합 (Firebase 동기화용)
     * 날짜별 합집합, title+at 기준 중복 제거
     */
    function mergeCompletionLog(local, cloud) {
      const merged = {};
      // 로컬 데이터 먼저 복사
      for (const date of Object.keys(local || {})) {
        merged[date] = [...(local[date] || [])];
      }
      // 클라우드 데이터 병합
      for (const date of Object.keys(cloud || {})) {
        if (!merged[date]) {
          merged[date] = [...(cloud[date] || [])];
        } else {
          const existing = new Set(merged[date].map(e => e.t + '|' + e.at));
          for (const entry of (cloud[date] || [])) {
            if (!existing.has(entry.t + '|' + entry.at)) {
              merged[date].push(entry);
            }
          }
        }
      }
      return merged;
    }

    /**
     * completionLog 데이터 보존 정책:
     * - 최근 365일: 전체 상세 기록 유지
     * - 1년 이상: 일별 요약으로 압축 { count, categories: {본업:2}, totalRevenue: 150000 }
     * 앱 시작 시 1일 1회 자동 실행
     */
    function compactOldCompletionLog() {
      const lastCompact = localStorage.getItem('navigator-completion-log-compact-date');
      const todayStr = getLocalDateStr();
      if (lastCompact === todayStr) return; // 오늘 이미 실행

      const cutoff = new Date();
      cutoff.setFullYear(cutoff.getFullYear() - 1);
      const cutoffStr = getLocalDateStr(cutoff);

      let compacted = 0;
      for (const [dateKey, entries] of Object.entries(appState.completionLog || {})) {
        if (dateKey >= cutoffStr) continue; // 1년 이내는 유지
        if (!Array.isArray(entries)) continue;
        // 이미 압축된 형태인지 확인 (배열 길이 1 + _summary 플래그)
        if (entries.length === 1 && entries[0]._summary) continue;

        // 일별 요약으로 압축
        const cats = {};
        let totalRev = 0;
        entries.forEach(e => {
          cats[e.c || '기타'] = (cats[e.c || '기타'] || 0) + 1;
          if (e.rv) totalRev += e.rv;
        });

        appState.completionLog[dateKey] = [{
          _summary: true,
          count: entries.length,
          categories: cats,
          totalRevenue: totalRev
        }];
        compacted++;
      }

      if (compacted > 0) {
        saveCompletionLog();
        console.log(`[compact] completionLog ${compacted}일 압축 완료`);
      }

      localStorage.setItem('navigator-completion-log-compact-date', todayStr);
    }

    /**
     * completionLog에서 날짜 범위 내 엔트리 조회
     * @param {string} startDateStr - YYYY-MM-DD (포함)
     * @param {string} endDateStr - YYYY-MM-DD (미포함)
     * @returns {Array} [{t, c, at, r?, rv?, dateKey}, ...]
     */
    function getCompletionLogEntries(startDateStr, endDateStr) {
      const entries = [];
      for (const [dateKey, dayEntries] of Object.entries(appState.completionLog || {})) {
        if (dateKey >= startDateStr && dateKey < endDateStr) {
          (dayEntries || []).forEach(e => {
            if (e._summary) {
              // 압축된 데이터: 카테고리별 가상 엔트리 생성
              for (const [cat, cnt] of Object.entries(e.categories || {})) {
                for (let i = 0; i < cnt; i++) {
                  entries.push({ t: '(요약)', c: cat, at: '00:00', rv: 0, dateKey });
                }
              }
            } else {
              entries.push({ ...e, dateKey });
            }
          });
        }
      }
      return entries;
    }

    function getWeeklyReport() {
      const now = new Date();

      // 이번 주 시작 (일요일)
      const thisWeekStart = new Date(now);
      thisWeekStart.setDate(now.getDate() - now.getDay());
      thisWeekStart.setHours(0, 0, 0, 0);
      const thisWeekStartStr = getLocalDateStr(thisWeekStart);

      // 지난 주 시작/끝
      const lastWeekStart = new Date(thisWeekStart);
      lastWeekStart.setDate(lastWeekStart.getDate() - 7);
      const lastWeekStartStr = getLocalDateStr(lastWeekStart);

      // 내일 (이번 주 종료 기준)
      const tomorrow = new Date(now);
      tomorrow.setDate(tomorrow.getDate() + 1);
      const tomorrowStr = getLocalDateStr(tomorrow);

      // completionLog 기반 이번 주 / 지난 주 완료 작업 조회
      const thisWeekEntries = getCompletionLogEntries(thisWeekStartStr, tomorrowStr);
      const lastWeekEntries = getCompletionLogEntries(lastWeekStartStr, thisWeekStartStr);

      // 요일별 완료 수 계산
      const dayNames = ['일', '월', '화', '수', '목', '금', '토'];
      const dayData = [0, 0, 0, 0, 0, 0, 0];

      thisWeekEntries.forEach(e => {
        const day = new Date(e.dateKey).getDay();
        dayData[day]++;
      });

      // 가장 생산적인 요일
      const maxDayIdx = dayData.indexOf(Math.max(...dayData));
      const bestDay = dayData[maxDayIdx] > 0 ? dayNames[maxDayIdx] : '-';
      const bestDayCount = dayData[maxDayIdx];

      // 카테고리별 완료 수
      const categoryData = {};
      thisWeekEntries.forEach(e => {
        const cat = e.c || '기타';
        categoryData[cat] = (categoryData[cat] || 0) + 1;
      });

      // 가장 많이 완료한 카테고리
      let topCategory = '-';
      let topCategoryCount = 0;
      Object.keys(categoryData).forEach(cat => {
        if (categoryData[cat] > topCategoryCount) {
          topCategoryCount = categoryData[cat];
          topCategory = cat;
        }
      });

      // 변화량 계산
      const change = thisWeekEntries.length - lastWeekEntries.length;

      return {
        thisWeekCount: thisWeekEntries.length,
        lastWeekCount: lastWeekEntries.length,
        change: change,
        bestDay: bestDay,
        bestDayCount: bestDayCount,
        topCategory: topCategory,
        topCategoryCount: topCategoryCount,
        dayData: dayData.map((count, i) => ({ day: dayNames[i], count })),
        streak: appState.streak.current
      };
    }

    /**
     * 습관 트래커 데이터 생성 (최근 12주)
     */
    function getHabitTrackerData() {
      const now = new Date();
      const weeks = 12;
      const data = [];

      // 오늘 날짜 문자열
      const todayStr = getLocalDateStr(now);

      // 완료 맵 생성
      const completionMap = getCompletionMap();

      // 12주 전부터 시작
      for (let week = weeks - 1; week >= 0; week--) {
        const weekData = [];
        for (let day = 0; day < 7; day++) {
          const date = new Date(now);
          date.setDate(now.getDate() - (week * 7 + (6 - day)) - now.getDay());
          const dateStr = getLocalDateStr(date);
          const count = completionMap[dateStr] || 0;

          // 레벨 계산
          let level = 0;
          if (count >= 1) level = 1;
          if (count >= 3) level = 2;
          if (count >= 5) level = 3;
          if (count >= 7) level = 4;

          weekData.push({
            date: dateStr,
            count: count,
            level: level,
            isToday: dateStr === todayStr
          });
        }
        data.push(weekData);
      }

      return data;
    }

    /**
     * 백업 리마인더 체크
     */
    function checkBackupReminder() {
      const lastBackup = localStorage.getItem('navigator-last-backup');
      const now = new Date();

      if (!lastBackup) {
        // 첫 사용이거나 백업 기록 없음
        return;
      }

      const daysSinceBackup = (now - new Date(lastBackup)) / (1000 * 60 * 60 * 24);

      if (daysSinceBackup >= 7) {
        setTimeout(() => {
          if (confirm('📦 마지막 백업 후 7일이 지났습니다.\n\n지금 백업하시겠습니까?')) {
            exportData();
          }
        }, 2000);
      }
    }

    /**
     * 포커스 모드 토글
     */
    function toggleFocusMode() {
      appState.focusMode = !appState.focusMode;
      renderStatic();

      if (appState.focusMode) {
        showToast('🎯 포커스 모드: 가장 중요한 작업 1개만 표시', 'success');
      }
    }

    /**
     * 마감시간 포맷팅
     */
    function formatDeadline(deadline) {
      const now = new Date();
      const d = new Date(deadline);
      const hoursLeft = (d - now) / (1000 * 60 * 60);
      
      if (hoursLeft < 1) {
        return `${Math.round(hoursLeft * 60)}분 후`;
      } else if (hoursLeft < 24) {
        return `${Math.round(hoursLeft)}시간 후`;
      }
      
      return d.toLocaleString('ko-KR', {
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });
    }

    // ============================================
    // 렌더링
    // ============================================
    
    /**
     * 전체 화면 렌더링 (상태 변경 시 호출)
     */
    function renderStatic() {
      // 스크롤/포커스 보존
      const _scrollY = window.scrollY;
      const _activeId = document.activeElement?.id || '';
      const _activeClass = document.activeElement?.className || '';

      const now = new Date();
      const hour = now.getHours();
      const filteredTasks = getFilteredTasks();
      const nextAction = filteredTasks[0] || null;
      const mode = getCurrentMode();
      const categoryStats = getCategoryStats();
      const urgentTasks = getUrgentTasks();
      
      const stats = {
        total: appState.tasks.length,
        completed: getTodayCompletedTasks(appState.tasks).length,
        remaining: appState.tasks.filter(t => !t.completed).length
      };

      const completedTasks = getTodayCompletedTasks(appState.tasks);
      const hiddenCount = appState.tasks.filter(t => !t.completed).length - filteredTasks.length;
      
      const bedtime = new Date(now);
      bedtime.setHours(24, 0, 0, 0);
      const minutesUntilBed = Math.floor((bedtime - now) / (1000 * 60));
      
      const urgencyClass = nextAction ? nextAction.urgency : 'normal';
      const urgencyLabel = {
        'urgent': '🚨 긴급!',
        'warning': '⚠️ 주의',
        'normal': '▶ 지금 할 것',
        'expired': '❌ 마감 지남'
      };

      // 반복 옵션 공통 필드
      const repeatField = `
        <div class="form-group">
          <label class="form-label">반복 설정</label>
          <select class="form-select" id="detailed-repeat" onchange="updateDetailedTaskRepeat(this.value)">
            <option value="none" ${appState.detailedTask.repeatType === 'none' ? 'selected' : ''}>반복 안 함</option>
            <option value="daily" ${appState.detailedTask.repeatType === 'daily' ? 'selected' : ''}>매일</option>
            <option value="weekdays" ${appState.detailedTask.repeatType === 'weekdays' ? 'selected' : ''}>평일만 (월~금)</option>
            <option value="weekends" ${appState.detailedTask.repeatType === 'weekends' ? 'selected' : ''}>주말만 (토~일)</option>
            <option value="weekly" ${appState.detailedTask.repeatType === 'weekly' ? 'selected' : ''}>매주</option>
            <option value="custom" ${appState.detailedTask.repeatType === 'custom' ? 'selected' : ''}>특정 요일</option>
            <option value="monthly" ${appState.detailedTask.repeatType === 'monthly' ? 'selected' : ''}>매월</option>
          </select>
          ${appState.detailedTask.repeatType === 'custom' ? `
            <div class="repeat-days">
              ${['일', '월', '화', '수', '목', '금', '토'].map((day, index) => `
                <label class="repeat-day-option">
                  <input type="checkbox"
                    ${(appState.detailedTask.repeatDays || []).includes(index) ? 'checked' : ''}
                    onchange="toggleRepeatDay(${index})">
                  <span>${day}</span>
                </label>
              `).join('')}
            </div>
          ` : ''}
          ${appState.detailedTask.repeatType === 'monthly' ? `
            <div class="repeat-monthly">
              <label class="form-label" style="margin-top: 10px;">매월 반복일</label>
              <input type="number" class="form-input" id="detailed-repeat-day"
                min="1" max="31"
                placeholder="1~31"
                value="${appState.detailedTask.repeatMonthDay || ''}"
                onchange="updateRepeatMonthDay(this.value)">
            </div>
          ` : ''}
          <div class="form-note">* 완료 시 다음 주기 작업이 자동 생성됩니다</div>
        </div>
      `;

      // 카테고리별 입력 필드
      const categoryFields = {
        '본업': `
          <div class="form-row">
            <div class="form-group half">
              <label class="form-label">시작일</label>
              <input type="datetime-local" class="form-input" id="detailed-startDate" value="${appState.detailedTask.startDate || ''}">
            </div>
            <div class="form-group half">
              <label class="form-label">마감일</label>
              <input type="datetime-local" class="form-input" id="detailed-deadline" value="${appState.detailedTask.deadline}">
            </div>
          </div>
          <div class="form-group">
            <label class="form-label">예상 소요시간 (분)</label>
            <input type="number" class="form-input" id="detailed-time" value="${appState.detailedTask.estimatedTime}">
          </div>
          ${repeatField}
          <div class="form-group">
            <label class="form-label">링크</label>
            <input type="url" class="form-input" id="detailed-link" placeholder="https://" value="${appState.detailedTask.link}">
          </div>
        `,
        '부업': `
          <div class="form-group">
            <label class="form-label">주최자</label>
            <select class="form-select" id="detailed-organizer">
              <option value="" ${!appState.detailedTask.organizer ? 'selected' : ''}>선택하세요</option>
              <option value="불개미" ${appState.detailedTask.organizer === '불개미' ? 'selected' : ''}>불개미</option>
              <option value="코같투" ${appState.detailedTask.organizer === '코같투' ? 'selected' : ''}>코같투</option>
              <option value="맨틀" ${appState.detailedTask.organizer === '맨틀' ? 'selected' : ''}>맨틀</option>
              <option value="xmaquina" ${appState.detailedTask.organizer === 'xmaquina' ? 'selected' : ''}>xmaquina</option>
              <option value="기타" ${appState.detailedTask.organizer === '기타' ? 'selected' : ''}>기타</option>
            </select>
          </div>
          <div class="form-group">
            <label class="form-label">이벤트 종류</label>
            <select class="form-select" id="detailed-eventType">
              <option value="" ${!appState.detailedTask.eventType ? 'selected' : ''}>선택하세요</option>
              <option value="의견작성" ${appState.detailedTask.eventType === '의견작성' ? 'selected' : ''}>의견작성</option>
              <option value="리캡작성" ${appState.detailedTask.eventType === '리캡작성' ? 'selected' : ''}>리캡작성</option>
              <option value="AMA참여" ${appState.detailedTask.eventType === 'AMA참여' ? 'selected' : ''}>AMA참여</option>
              <option value="아티클작성" ${appState.detailedTask.eventType === '아티클작성' ? 'selected' : ''}>아티클작성</option>
              <option value="영상제작" ${appState.detailedTask.eventType === '영상제작' ? 'selected' : ''}>영상제작</option>
              <option value="커뮤니티" ${appState.detailedTask.eventType === '커뮤니티' ? 'selected' : ''}>커뮤니티</option>
              <option value="기타" ${appState.detailedTask.eventType === '기타' ? 'selected' : ''}>기타</option>
            </select>
          </div>
          <div class="form-row">
            <div class="form-group half">
              <label class="form-label">시작일</label>
              <input type="datetime-local" class="form-input" id="detailed-startDate" value="${appState.detailedTask.startDate || ''}">
            </div>
            <div class="form-group half">
              <label class="form-label">마감일</label>
              <input type="datetime-local" class="form-input" id="detailed-deadline" value="${appState.detailedTask.deadline}">
            </div>
          </div>
          <div class="form-group">
            <label class="form-label">링크</label>
            <input type="url" class="form-input" id="detailed-link" placeholder="https://t.me/..." value="${appState.detailedTask.link}">
          </div>
        `,
        '일상': `
          <div class="form-row">
            <div class="form-group half">
              <label class="form-label">시작일 (선택)</label>
              <input type="datetime-local" class="form-input" id="detailed-startDate" value="${appState.detailedTask.startDate || ''}">
            </div>
            <div class="form-group half">
              <label class="form-label">마감일 (선택)</label>
              <input type="datetime-local" class="form-input" id="detailed-deadline" value="${appState.detailedTask.deadline}">
            </div>
          </div>
          <div class="form-group">
            <label class="form-label">예상 소요시간 (분)</label>
            <input type="number" class="form-input" id="detailed-time" value="${appState.detailedTask.estimatedTime}">
          </div>
          ${repeatField}
        `,
        '가족': `
          <div class="form-row">
            <div class="form-group half">
              <label class="form-label">시작일 (선택)</label>
              <input type="datetime-local" class="form-input" id="detailed-startDate" value="${appState.detailedTask.startDate || ''}">
            </div>
            <div class="form-group half">
              <label class="form-label">마감일 (선택)</label>
              <input type="datetime-local" class="form-input" id="detailed-deadline" value="${appState.detailedTask.deadline}">
            </div>
          </div>
          <div class="form-group">
            <label class="form-label">예상 소요시간 (분)</label>
            <input type="number" class="form-input" id="detailed-time" value="${appState.detailedTask.estimatedTime}">
          </div>
          ${repeatField}
          <div class="form-group">
            <label class="form-label">메모/링크 (선택)</label>
            <input type="text" class="form-input" id="detailed-link" placeholder="메모 또는 URL" value="${appState.detailedTask.link}">
          </div>
        `
      };

      document.getElementById('root').innerHTML = `
        <div class="app">
          <div class="header">
            <div class="header-left">
              <h1>⚡ Navigator</h1>
              <p class="header-date">${now.getMonth() + 1}월 ${now.getDate()}일 ${['일', '월', '화', '수', '목', '금', '토'][now.getDay()]}요일 ${appState.streak.current > 0 ? `<span class="header-streak">🔥${appState.streak.current}</span>` : ''}</p>
            </div>
            <div class="header-actions">
              <button class="header-btn shuttle-toggle ${appState.shuttleSuccess ? 'on' : 'off'}" onclick="toggleShuttle()" title="${appState.shuttleSuccess ? '셔틀 탑승 성공 ✓' : '셔틀 놓침 ✗ (클릭하여 변경)'}" aria-label="셔틀 상태 토글">
                ${appState.shuttleSuccess ? '🚌 ON' : '😴 OFF'}
              </button>
              <button class="header-btn" onclick="toggleTheme()" title="테마 전환" aria-label="테마 전환">
                ${appState.theme === 'dark' ? '☀️' : '🌙'}
              </button>
              ${appState.user ? `
                <button class="header-btn" onclick="openSettings()" title="동기화: ${appState.syncStatus}" aria-label="동기화 상태" style="position: relative;">
                  ${appState.syncStatus === 'syncing' ? '🔄' : appState.syncStatus === 'synced' ? '☁️' : appState.syncStatus === 'error' ? '⚠️' : '☁️'}
                  <span style="position: absolute; bottom: 2px; right: 2px; width: 8px; height: 8px; background: ${appState.syncStatus === 'synced' ? '#48bb78' : appState.syncStatus === 'error' ? '#f5576c' : '#667eea'}; border-radius: 50%; border: 1px solid var(--bg-primary);"></span>
                </button>
              ` : `
                <button class="header-btn" onclick="openSettings()" title="로그인하여 동기화" aria-label="로그인하여 동기화">
                  ☁️
                </button>
              `}
              <div class="notification-dropdown-wrapper">
                <button class="header-btn" onclick="toggleNotificationDropdown(event)" title="마감 알림" aria-label="마감 알림" style="position: relative;">
                  🔔
                  ${appState.notificationPermission === 'granted' ? '<span class="notif-dot" style="background: #48bb78;"></span>' : appState.notificationPermission === 'denied' ? '<span class="notif-dot" style="background: #f5576c;"></span>' : ''}
                </button>
                <div id="notification-dropdown" class="notification-dropdown">
                  <div class="notification-title">🔔 마감 알림</div>
                  <div class="notification-status">
                    ${appState.notificationPermission === 'granted' ? `
                      <span class="notification-text granted">✓ 활성화됨</span>
                      <button class="notification-btn granted" disabled>ON</button>
                    ` : appState.notificationPermission === 'denied' ? `
                      <span class="notification-text denied">✕ 차단됨</span>
                      <button class="notification-btn denied" onclick="showToast('브라우저 설정에서 알림을 허용해주세요 (주소창 왼쪽 🔒 클릭)', 'info')">설정</button>
                    ` : `
                      <span class="notification-text">알림 받기</span>
                      <button class="notification-btn" onclick="requestNotificationPermission()">켜기</button>
                    `}
                  </div>
                  ${appState.notificationPermission === 'denied' ? `
                    <div class="notification-help">
                      💡 주소창 왼쪽의 🔒를 클릭하여 알림을 허용으로 변경하세요
                    </div>
                  ` : ''}
                </div>
              </div>
              <button class="header-btn" onclick="openSettings()" title="설정" aria-label="설정">
                ⚙️
              </button>
            </div>
          </div>

          <!-- 탭 네비게이션 (5개 + 더보기) -->
          <div class="tab-nav">
            <button class="tab-btn ${appState.currentTab === 'action' ? 'active' : ''}" onclick="switchTab('action')" aria-label="오늘 탭">
              🎯 오늘
            </button>
            <button class="tab-btn ${appState.currentTab === 'work' ? 'active' : ''}" onclick="switchTab('work')" aria-label="본업 탭">
              💼 본업
            </button>
            <button class="tab-btn ${appState.currentTab === 'events' ? 'active' : ''}" onclick="switchTab('events')" aria-label="이벤트 탭">
              💰 이벤트
            </button>
            <button class="tab-btn ${appState.currentTab === 'life' ? 'active' : ''}" onclick="switchTab('life')" aria-label="일상 탭">
              🏠 일상
            </button>
            <div class="tab-more-dropdown">
              <button class="tab-btn ${['commute', 'dashboard', 'all', 'history'].includes(appState.currentTab) ? 'active' : ''}" onclick="toggleMoreMenu(event)" aria-label="더보기 메뉴" aria-expanded="${appState.moreMenuOpen}" aria-haspopup="true">
                📋 더보기 ▾
              </button>
              <div id="more-menu" class="more-menu ${appState.moreMenuOpen ? 'show' : ''}" role="menu">
              <button class="more-menu-item ${appState.currentTab === 'commute' ? 'active' : ''}" onclick="appState.moreMenuOpen = false; switchTab('commute');" role="menuitem" aria-label="통근 탭">
                🚌 통근
              </button>
                <button class="more-menu-item ${appState.currentTab === 'dashboard' ? 'active' : ''}" onclick="appState.moreMenuOpen = false; switchTab('dashboard');" role="menuitem" aria-label="통계 탭">
                  📊 통계
                </button>
                <button class="more-menu-item ${appState.currentTab === 'all' ? 'active' : ''}" onclick="appState.moreMenuOpen = false; switchTab('all');" role="menuitem" aria-label="전체 탭">
                  📋 전체
                </button>
                <button class="more-menu-item ${appState.currentTab === 'history' ? 'active' : ''}" onclick="appState.moreMenuOpen = false; switchTab('history');" role="menuitem" aria-label="히스토리 탭">
                  📅 히스토리
                </button>
              </div>
            </div>
          </div>

          <!-- 실행 탭 -->
          <div class="tab-content ${appState.currentTab === 'action' ? 'active' : ''}">
            ${appState.currentTab === 'action' ? `
            <!-- PC 3단 레이아웃 / 모바일 1단 -->
            <div class="pc-layout">
              <!-- 왼쪽 컬럼: 상태 + Next Action -->
              <div class="pc-column-left">
                <!-- 현재 시간 & 남은 시간 -->
                <div class="current-time-section">
                  <div class="current-time-left">
                    <div class="current-time-clock" id="current-clock">${now.toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' })}</div>
                    <div class="current-time-mode">
                      <span class="current-time-mode-label">현재 모드</span>
                      <span class="current-time-mode-value ${mode}">${mode}</span>
                    </div>
                  </div>
                  <div class="current-time-right">
                    <div class="time-remaining-label">${getModeTimeLabel(mode, hour)}</div>
                    <div class="time-remaining-value ${minutesUntilBed < 60 && hour >= 22 ? 'urgent' : ''}" id="mode-time-remaining">
                      ${getModeTimeRemaining(mode, hour, now)}
                    </div>
                  </div>
                </div>

                <!-- 🔥 완료 스트릭 -->
                ${(() => {
                  const { streak, hasTodayCompletion } = calculateCompletionStreak();
                  const badge = getStreakBadge(streak);
                  if (streak === 0 && !hasTodayCompletion) return '';
                  return `
                    <div style="display: flex; align-items: center; gap: 10px; padding: 10px 14px; background: var(--bg-secondary); border-radius: var(--radius-md); border: 1px solid var(--border-color); margin-bottom: 12px;">
                      <span style="font-size: 22px;">🔥</span>
                      <div style="flex: 1;">
                        <div style="font-size: 15px; font-weight: 600; color: var(--text-primary);">${streak}일 연속 완료${hasTodayCompletion ? '' : ' <span style="font-size: 12px; color: var(--text-muted);">(오늘 아직)</span>'}</div>
                        ${badge ? `<div style="font-size: 12px; color: var(--accent-warning); margin-top: 2px;">${badge}</div>` : ''}
                      </div>
                      <span style="font-size: 20px; font-weight: 700; color: ${streak >= 7 ? 'var(--accent-warning)' : 'var(--text-secondary)'};">${streak}</span>
                    </div>
                  `;
                })()}

                <!-- 📊 라이프 리듬 트래커 -->
                ${(() => {
                  const today = getLocalDateStr();
                  const rhythm = appState.lifeRhythm.today.date === today ? appState.lifeRhythm.today : { wakeUp: null, homeDepart: null, workArrive: null, workDepart: null, homeArrive: null, sleep: null, medications: {} };
                  const yesterday = getLocalDateStr(new Date(Date.now() - 86400000));
                  const yesterdayData = appState.lifeRhythm.history[yesterday] || {};

                  const toMins = (t) => t ? parseInt(t.split(':')[0]) * 60 + parseInt(t.split(':')[1]) : null;
                  const formatDur = (mins) => {
                    if (!mins || mins <= 0) return null;
                    const h = Math.floor(mins / 60);
                    const m = mins % 60;
                    return h + 'h ' + m + 'm';
                  };

                  let sleepDuration = null;
                  if (yesterdayData.sleep && rhythm.wakeUp) {
                    const sleepTime = toMins(yesterdayData.sleep);
                    const wakeTime = toMins(rhythm.wakeUp);
                    let duration = wakeTime - sleepTime;
                    if (duration < 0) duration += 24 * 60;
                    if (sleepTime > 12 * 60) duration = wakeTime + (24 * 60 - sleepTime);
                    sleepDuration = formatDur(duration);
                  }

                  let commuteToWork = null;
                  if (rhythm.homeDepart && rhythm.workArrive) {
                    const dur = toMins(rhythm.workArrive) - toMins(rhythm.homeDepart);
                    commuteToWork = formatDur(dur);
                  }

                  let commuteToHome = null;
                  if (rhythm.workDepart && rhythm.homeArrive) {
                    const dur = toMins(rhythm.homeArrive) - toMins(rhythm.workDepart);
                    commuteToHome = formatDur(dur);
                  }

                  let workDuration = null;
                  if (rhythm.workArrive && rhythm.workDepart) {
                    const dur = toMins(rhythm.workDepart) - toMins(rhythm.workArrive);
                    workDuration = formatDur(dur);
                  }

                  let totalOutTime = null;
                  if (rhythm.homeDepart && rhythm.homeArrive) {
                    const dur = toMins(rhythm.homeArrive) - toMins(rhythm.homeDepart);
                    totalOutTime = formatDur(dur);
                  }

                  return `
                    <div class="life-rhythm-tracker">
                      <div class="life-rhythm-header">
                        <span class="life-rhythm-title">📊 오늘의 리듬</span>
                        ${sleepDuration ? '<span class="life-rhythm-sleep">💤 수면 ' + sleepDuration + '</span>' : ''}
                      </div>
                      <div class="life-rhythm-buttons six-items">
                        <button class="life-rhythm-btn ${rhythm.wakeUp ? 'recorded' : ''}"
                                onclick="handleLifeRhythmClick('wakeUp', ${rhythm.wakeUp ? 'true' : 'false'}, event)"
                                title="${rhythm.wakeUp ? '클릭: 수정/삭제' : '클릭: 현재시간 기록'}">
                          <span class="life-rhythm-icon">☀️</span>
                          <span class="life-rhythm-label">기상</span>
                          <span class="life-rhythm-time">${rhythm.wakeUp || '--:--'}</span>
                        </button>
                        <button class="life-rhythm-btn ${rhythm.homeDepart ? 'recorded' : ''}"
                                onclick="handleLifeRhythmClick('homeDepart', ${rhythm.homeDepart ? 'true' : 'false'}, event)"
                                title="${rhythm.homeDepart ? '클릭: 수정/삭제' : '클릭: 현재시간 기록'}">
                          <span class="life-rhythm-icon">🚶</span>
                          <span class="life-rhythm-label">집출발</span>
                          <span class="life-rhythm-time">${rhythm.homeDepart || '--:--'}</span>
                        </button>
                        <button class="life-rhythm-btn ${rhythm.workArrive ? 'recorded' : ''}"
                                onclick="handleLifeRhythmClick('workArrive', ${rhythm.workArrive ? 'true' : 'false'}, event)"
                                title="${rhythm.workArrive ? '클릭: 수정/삭제' : '클릭: 현재시간 기록'}">
                          <span class="life-rhythm-icon">🏢</span>
                          <span class="life-rhythm-label">회사도착</span>
                          <span class="life-rhythm-time">${rhythm.workArrive || '--:--'}</span>
                        </button>
                        <button class="life-rhythm-btn ${rhythm.workDepart ? 'recorded' : ''}"
                                onclick="handleLifeRhythmClick('workDepart', ${rhythm.workDepart ? 'true' : 'false'}, event)"
                                title="${rhythm.workDepart ? '클릭: 수정/삭제' : '클릭: 현재시간 기록'}">
                          <span class="life-rhythm-icon">🚀</span>
                          <span class="life-rhythm-label">회사출발</span>
                          <span class="life-rhythm-time">${rhythm.workDepart || '--:--'}</span>
                        </button>
                        <button class="life-rhythm-btn ${rhythm.homeArrive ? 'recorded' : ''}"
                                onclick="handleLifeRhythmClick('homeArrive', ${rhythm.homeArrive ? 'true' : 'false'}, event)"
                                title="${rhythm.homeArrive ? '클릭: 수정/삭제' : '클릭: 현재시간 기록'}">
                          <span class="life-rhythm-icon">🏠</span>
                          <span class="life-rhythm-label">집도착</span>
                          <span class="life-rhythm-time">${rhythm.homeArrive || '--:--'}</span>
                        </button>
                        <button class="life-rhythm-btn ${rhythm.sleep ? 'recorded' : ''}"
                                onclick="handleLifeRhythmClick('sleep', ${rhythm.sleep ? 'true' : 'false'}, event)"
                                title="${rhythm.sleep ? '클릭: 수정/삭제' : '클릭: 현재시간 기록'}">
                          <span class="life-rhythm-icon">🌙</span>
                          <span class="life-rhythm-label">취침</span>
                          <span class="life-rhythm-time">${rhythm.sleep || '--:--'}</span>
                        </button>
                      </div>
                      <div class="life-rhythm-stats">
                        ${commuteToWork ? '<span class="rhythm-stat">🚌 출근 ' + commuteToWork + '</span>' : ''}
                        ${workDuration ? '<span class="rhythm-stat">💼 근무 ' + workDuration + '</span>' : ''}
                        ${commuteToHome ? '<span class="rhythm-stat">🏠 퇴근 ' + commuteToHome + '</span>' : ''}
                        ${totalOutTime ? '<span class="rhythm-stat total">📍 총 외출 ' + totalOutTime + '</span>' : ''}
                      </div>
                    </div>
                  `;
                })()}

                <!-- 💊 복약 트래커 -->
                ${(() => {
                  const medSlots = getMedicationSlots();
                  if (!medSlots || medSlots.length === 0) return '';

                  const todayStr = getLocalDateStr();
                  const todayRhythm = appState.lifeRhythm.today.date === todayStr ? appState.lifeRhythm.today : {};
                  const todayMeds = (todayRhythm.medications) || {};
                  const takenCount = medSlots.filter(s => todayMeds[s.id]).length;
                  const totalCount = medSlots.length;
                  const streak = getMedicationStreak();
                  const requiredSlots = medSlots.filter(s => s.required);
                  const allRequiredTaken = requiredSlots.every(s => todayMeds[s.id]);

                  return `
                    <div class="medication-tracker">
                      <div class="medication-header">
                        <span class="medication-title">💊 오늘의 복약</span>
                        <span class="medication-progress">${takenCount}/${totalCount} 완료</span>
                      </div>
                      <div class="medication-slots">
                        ${medSlots.map(slot => {
                          const taken = !!todayMeds[slot.id];
                          const timeVal = todayMeds[slot.id] || '--:--';
                          return `
                            <button class="medication-btn ${taken ? 'taken' : ''} ${slot.required ? 'required' : ''}"
                                    onclick="handleMedicationClick('${escapeHtml(slot.id)}', ${taken}, event)"
                                    title="${taken ? '클릭: 수정/삭제' : '클릭: 현재시간 기록'}">
                              <span class="med-icon">${slot.icon}</span>
                              <span class="med-label">${escapeHtml(slot.label)}</span>
                              <span class="med-time">${timeVal}</span>
                            </button>
                          `;
                        }).join('')}
                      </div>
                      ${streak > 0 ? '<div class="medication-streak">❤️ 필수 복약 연속 <span class="streak-good">' + streak + '일째</span></div>' : ''}
                      ${!allRequiredTaken && requiredSlots.length > 0 ? '<div class="medication-streak">⚠️ 필수 복약을 잊지 마세요!</div>' : ''}
                    </div>
                  `;
                })()}

                <!-- 🎯 일일 목표 진행률 -->
                ${(() => {
                  const dailyGoal = appState.settings.dailyGoal || 5;
                  const completed = appState.todayStats.completedToday;
                  const percentage = Math.min((completed / dailyGoal) * 100, 100);
                  const isComplete = completed >= dailyGoal;
                  const remaining = dailyGoal - completed;

                  let message = '';
                  let messageClass = '';
                  if (isComplete) {
                    message = '목표 달성! 오늘 정말 잘했어요! 🏆';
                    messageClass = 'positive';
                  } else if (percentage >= 80) {
                    message = '거의 다 왔어요! 조금만 더! 💪';
                    messageClass = 'encourage';
                  } else if (percentage >= 50) {
                    message = '반 이상 완료! 잘하고 있어요! ⭐';
                    messageClass = 'encourage';
                  } else if (percentage >= 20) {
                    message = '좋은 시작이에요! 계속 가보자! 🚀';
                    messageClass = '';
                  } else if (completed > 0) {
                    message = '첫 발을 뗐어요! 그게 제일 어려운 거예요! 👏';
                    messageClass = '';
                  } else {
                    message = '오늘 하나 해볼까요? 시작이 반이에요! ✨';
                    messageClass = '';
                  }

                  const runner = isComplete ? '🏅' : (percentage >= 50 ? '🏃' : '🚶');

                  return `
                    <div class="daily-goal-compact">
                      <div class="daily-goal-header">
                        <div class="daily-goal-info">
                          <span class="daily-goal-emoji">${isComplete ? '🎉' : '🎯'}</span>
                          <span class="daily-goal-text">오늘 <strong>${completed}</strong>/${dailyGoal}개</span>
                        </div>
                        <span class="daily-goal-percentage ${isComplete ? 'complete' : ''}">${Math.round(percentage)}%</span>
                      </div>
                      <div class="daily-goal-track">
                        <div class="daily-goal-bar" style="width: 100%">
                          <div class="daily-goal-bar-fill ${isComplete ? 'complete' : ''}" style="width: ${percentage}%">
                            <span class="daily-goal-runner">${runner}</span>
                          </div>
                        </div>
                        <span class="daily-goal-finish">🏁</span>
                      </div>
                      <div class="daily-goal-message ${messageClass}">${message}</div>
                    </div>
                  `;
                })()}

                <!-- 💬 오늘의 명언 -->
                ${(() => {
                  const quote = getDailyQuote();
                  return `
                    <div class="daily-quote">
                      <div class="daily-quote-text">"${quote.text}"</div>
                      <div class="daily-quote-author">— ${quote.author}</div>
                    </div>
                  `;
                })()}

              </div>

              <!-- 중간 컬럼: 할 일 -->
              <div class="pc-column-center">
                <!-- 🚨 마감 임박 -->
                ${urgentTasks.length > 0 ? `
                  <div class="dashboard-section">
                    <div class="dashboard-title">🚨 마감 임박</div>
                    <div class="urgent-list">
                      ${urgentTasks.slice(0, 3).map(task => `
                        <div class="urgent-item">
                          <div class="urgent-item-title">${escapeHtml(task.title)}</div>
                          <div class="urgent-item-time">⏰ ${formatDeadline(task.deadline)}</div>
                        </div>
                      `).join('')}
                    </div>
                  </div>
                ` : ''}

                <!-- 빠른 추가 -->
                <div class="quick-add-simple">
                  <input
                    type="text"
                    id="quick-add-input"
                    class="quick-add-input"
                    placeholder="+ 새 작업 (#부업 #본업 #일상)"
                    value="${appState.quickAddValue}"
                    onkeypress="if(event.key==='Enter') quickAdd()"
                  >
                  <button class="quick-add-btn" onclick="quickAdd()" aria-label="빠른 작업 추가">+</button>
                </div>

                <!-- 빠른 추가 버튼 -->
                <div class="quick-templates">
                  <button class="quick-template-btn" onclick="addFromTemplate('writing')" title="아티클/트윗 작성용 템플릿으로 빠르게 추가" aria-label="글쓰기 템플릿으로 추가">
                    ✍️ 글쓰기
                  </button>
                  <button class="quick-template-btn secondary" onclick="toggleDetailedAdd()" title="카테고리, 마감일, 예상수익 등 상세 정보 입력" aria-label="상세 작업 추가">
                    📝 상세 추가
                  </button>
                  <button class="quick-template-btn secondary" onclick="showBrainDumpModal()" title="한 줄에 하나씩, 여러 작업을 한 번에 추가" aria-label="브레인 덤프">
                    🧠 덤프
                  </button>
                </div>

                <!-- 퀵 필터 섹션 -->
                <div class="quick-filter-section">
                  <div class="quick-filter-header">
                    <span class="quick-filter-title">⏱️ 소요시간·마감 필터</span>
                  </div>
                  <div class="quick-filters">
                    <button class="quick-filter-btn ${appState.quickFilter === '2min' ? 'active' : ''}" onclick="setQuickFilter('2min')" title="예상 소요시간 2분 이내인 작업만 표시">
                      ⚡ 2분 이내
                      <span class="filter-count">${getQuickFilterCount('2min')}</span>
                    </button>
                    <button class="quick-filter-btn ${appState.quickFilter === '5min' ? 'active' : ''}" onclick="setQuickFilter('5min')" title="예상 소요시간 5분 이내인 작업만 표시">
                      🚀 5분 이내
                      <span class="filter-count">${getQuickFilterCount('5min')}</span>
                    </button>
                    <button class="quick-filter-btn ${appState.quickFilter === 'urgent' ? 'active' : ''}" onclick="setQuickFilter('urgent')" title="마감이 24시간 내로 다가온 긴급 작업">
                      🔥 마감 임박
                      <span class="filter-count">${getQuickFilterCount('urgent')}</span>
                    </button>
                  </div>
                </div>

                <!-- 다른 작업 목록 (접기/펼치기) -->
                <div class="other-tasks-section">
                  <div class="other-tasks-header" onclick="toggleTaskList()">
                    <span>📋 다른 작업 ${filteredTasks.filter(t => !t.completed).length - (nextAction ? 1 : 0)}개</span>
                    <span class="other-tasks-toggle">${appState.showTaskList ? '▲' : '▼'}</span>
                  </div>

                  ${appState.showTaskList ? `
                    <!-- 검색 (펼쳐졌을 때만) -->
                    <div class="search-simple">
                      <input
                        type="text"
                        class="search-input"
                        placeholder="🔍 검색..."
                        value="${appState.searchQuery}"
                        oninput="setSearchQuery(this.value)"
                      >
                      ${appState.searchQuery ? `<button class="search-clear" onclick="clearSearch()">×</button>` : ''}
                    </div>

                    <!-- 작업 목록 (펼쳐졌을 때만) -->
                    <div class="task-list-inner">
                      ${filteredTasks
                        .filter(t => !t.completed && t.id !== (nextAction ? nextAction.id : null))
                        .slice(0, 10)
                        .map(task => `
                          <div class="task-item-mini" onclick="editTask('${task.id}')" style="--task-cat-color: var(--cat-${task.category})">
                            <div class="task-item-mini-left">
                              <button class="task-check-btn" onclick="event.stopPropagation(); completeTask('${task.id}')" aria-label="작업 완료">○</button>
                              <span class="task-item-mini-title">${escapeHtml(task.title)}</span>
                            </div>
                            <span class="task-item-mini-category ${task.category}">${task.category}</span>
                          </div>
                        `).join('')}
                      ${filteredTasks.filter(t => !t.completed && t.id !== (nextAction ? nextAction.id : null)).length > 10 ? `
                        <div class="task-list-more">+ ${filteredTasks.filter(t => !t.completed).length - 10}개 더...</div>
                      ` : ''}
                    </div>
                  ` : ''}
                </div>

                ${appState.showDetailedAdd ? `
                  <div class="add-task-section">
                    <h3>${appState.editingTaskId ? '✏️ 작업 수정' : '📝 상세 추가'}</h3>
                    <div class="form-group">
                      <label class="form-label">카테고리</label>
                      <select class="form-select" id="detailed-category" onchange="updateDetailedTaskCategory(this.value)">
                        <option value="본업" ${appState.detailedTask.category === '본업' ? 'selected' : ''}>본업</option>
                        <option value="부업" ${appState.detailedTask.category === '부업' ? 'selected' : ''}>부업</option>
                        <option value="일상" ${appState.detailedTask.category === '일상' ? 'selected' : ''}>일상</option>
                        <option value="가족" ${appState.detailedTask.category === '가족' ? 'selected' : ''}>가족</option>
                      </select>
                    </div>

                    ${appState.detailedTask.category === '본업' && appState.workProjects.filter(p => !p.archived).length > 0 ? `
                      <div class="work-project-link-section" style="background: var(--bg-tertiary); padding: 12px; border-radius: 8px; margin-bottom: 12px;">
                        <div class="form-group" style="margin-bottom: 8px;">
                          <label class="form-label">📁 프로젝트 연결 (선택)</label>
                          <select class="form-select" id="detailed-work-project" onchange="updateWorkProjectLink(this.value)">
                            <option value="">연결 안함 (일반 할일)</option>
                            ${appState.workProjects.filter(p => !p.archived).map(p => `
                              <option value="${p.id}" ${appState.detailedTask.workProjectId === p.id ? 'selected' : ''}>${escapeHtml(p.name)}</option>
                            `).join('')}
                          </select>
                        </div>
                        ${appState.detailedTask.workProjectId ? `
                          <div class="form-group" style="margin-bottom: 8px;">
                            <label class="form-label">📋 단계</label>
                            <select class="form-select" id="detailed-work-stage" onchange="updateWorkStageLink(this.value)">
                              ${appState.workProjectStages.map((stage, idx) => `
                                <option value="${idx}" ${appState.detailedTask.workStageIdx === idx ? 'selected' : ''}>${idx + 1}. ${stage}</option>
                              `).join('')}
                            </select>
                          </div>
                          ${(() => {
                            const proj = appState.workProjects.find(p => p.id === appState.detailedTask.workProjectId);
                            const stageIdx = appState.detailedTask.workStageIdx || 0;
                            const subcats = proj?.stages[stageIdx]?.subcategories || [];
                            if (subcats.length > 0) {
                              return `
                                <div class="form-group" style="margin-bottom: 0;">
                                  <label class="form-label">📂 중분류</label>
                                  <select class="form-select" id="detailed-work-subcat" onchange="updateWorkSubcatLink(this.value)">
                                    ${subcats.map((sub, idx) => `
                                      <option value="${idx}" ${appState.detailedTask.workSubcatIdx === idx ? 'selected' : ''}>${escapeHtml(sub.name)}</option>
                                    `).join('')}
                                  </select>
                                </div>
                              `;
                            } else {
                              return '<div style="color: var(--text-muted); font-size: 12px;">이 단계에 중분류가 없습니다. 본업 탭에서 먼저 추가하세요.</div>';
                            }
                          })()}
                        ` : ''}
                      </div>
                    ` : ''}

                    <div class="form-group">
                      <label class="form-label">제목</label>
                      <input type="text" class="form-input" id="detailed-title" placeholder="작업 제목" value="${appState.detailedTask.title}">
                    </div>
                    <div class="form-group">
                      <label class="form-label">설명 (선택)</label>
                      <textarea class="form-input form-textarea" id="detailed-description" placeholder="작업 내용, 요구사항, 메모 등" rows="2">${escapeHtml(appState.detailedTask.description || '')}</textarea>
                    </div>
                    ${categoryFields[appState.detailedTask.category]}

                    <!-- 태그 입력 -->
                    <div class="form-group">
                      <label class="form-label">태그</label>
                      <div class="tags-input-container">
                        <div class="selected-tags">
                          ${(appState.detailedTask.tags || []).map(tag => `
                            <span class="tag selected" onclick="removeTagFromTask('${tag}')">${escapeHtml(tag)} ×</span>
                          `).join('')}
                        </div>
                        <div class="available-tags">
                          ${appState.availableTags.filter(tag => !(appState.detailedTask.tags || []).includes(tag)).map(tag => `
                            <span class="tag" onclick="addTagToTask('${tag}')">${escapeHtml(tag)}</span>
                          `).join('')}
                        </div>
                        <div class="new-tag-input">
                          <input type="text" class="form-input tag-input" id="new-tag-input" placeholder="새 태그 입력 후 Enter">
                        </div>
                      </div>
                    </div>

                    <!-- 서브태스크 입력 -->
                    <div class="form-group">
                      <label class="form-label">서브태스크 (단계별 할일)</label>
                      <div class="subtasks-container">
                        ${(appState.detailedTask.subtasks || []).map((subtask, index) => `
                          <div class="subtask-item ${subtask.completed ? 'completed' : ''}">
                            <span class="subtask-list-check" onclick="toggleDetailedSubtask(${index})" style="cursor:pointer">${subtask.completed ? '✓' : index + 1}</span>
                            <span class="subtask-text ${subtask.completed ? 'completed' : ''}" style="${subtask.completed ? 'text-decoration: line-through; color: var(--text-muted);' : ''}">${escapeHtml(subtask.text)}</span>
                            <button class="subtask-remove" onclick="removeSubtask(${index})">×</button>
                          </div>
                        `).join('')}
                        <div class="subtask-add">
                          <input type="text" class="form-input subtask-input" id="new-subtask-input" placeholder="서브태스크 추가 후 Enter">
                        </div>
                        ${(() => {
                          const subtasks = appState.detailedTask.subtasks || [];
                          const completedCount = subtasks.filter(s => s.completed).length;
                          const totalCount = subtasks.length;
                          if (totalCount > 0 && completedCount === totalCount && appState.editingTaskId) {
                            return `
                              <button class="complete-all-subtasks-btn" onclick="completeTask(${appState.editingTaskId}); cancelEdit();">
                                🎉 모든 서브태스크 완료! 작업 완료하기
                              </button>
                            `;
                          }
                          return '';
                        })()}
                      </div>
                    </div>

                    ${appState.editingTaskId ? `
                      <button class="btn btn-primary" onclick="detailedAdd()">✓ 수정 완료</button>
                      <button class="btn btn-secondary" onclick="cancelEdit()">✕ 취소</button>
                    ` : `
                      <button class="btn btn-primary" onclick="detailedAdd()">추가하기</button>
                    `}
                  </div>
                ` : ''}

                ${filteredTasks.length > 0 && !appState.focusMode ? `
                  <!-- 스와이프 힌트 -->
                  ${!localStorage.getItem('navigator-hide-swipe-hint') ? `
                    <div class="swipe-hint">
                      <span class="swipe-hint-icon">👆</span>
                      <span class="swipe-hint-text">
                        작업을 <strong>왼쪽으로 밀면 완료</strong>, <strong>오른쪽으로 밀면 삭제</strong>
                      </span>
                      <button class="swipe-hint-close" onclick="dismissSwipeHint()">✕</button>
                    </div>
                  ` : ''}
                  <div class="task-list-section">
                    <div class="task-list-header" onclick="toggleTaskList()">
                      <div class="task-list-title">📋 전체 목록</div>
                      <div class="task-list-count">${filteredTasks.length}개 ${appState.showTaskList ? '▼' : '▶'}</div>
                    </div>
                    <div class="task-list ${appState.showTaskList ? 'show' : ''}">
                      ${filteredTasks.map((task, index) => `
                        <div
                          id="task-${task.id}"
                          class="task-item ${task.urgency === 'urgent' ? 'urgent' : ''} ${task.urgency === 'warning' ? 'warning' : ''}"
                          style="--task-cat-color: var(--cat-${task.category})"
                          draggable="true"
                          ondragstart="handleDragStart(event, '${task.id}')"
                          ondragend="handleDragEnd(event)"
                          ondragover="handleDragOver(event, '${task.id}')"
                          ondrop="handleDrop(event, '${task.id}')"
                          ontouchstart="handleTouchStart(event, '${task.id}')"
                          ontouchmove="handleTouchMove(event, '${task.id}')"
                          ontouchend="handleTouchEnd(event, '${task.id}')"
                        >
                          <div class="swipe-actions left">✓ 완료</div>
                          <div class="swipe-actions right">× 삭제</div>

                          <div class="task-item-header">
                            <div class="task-item-title">
                              ${index + 1}. ${escapeHtml(task.title)}
                              <span class="task-item-inline-cat ${task.category}">${task.category}</span>
                              ${task.subtasks && task.subtasks.length > 0 ? `
                                <span class="subtask-badge" onclick="event.stopPropagation(); toggleSubtaskExpand('${task.id}')">
                                  📋${task.subtasks.filter(s => s.completed).length}/${task.subtasks.length}
                                </span>
                              ` : ''}
                            </div>
                          </div>
                          <div class="task-item-meta">
                            <span class="category ${task.category}">${task.category}</span>
                            ${task.repeatType && task.repeatType !== 'none' ? ` · 🔄 ${getRepeatLabel(task.repeatType, task)}` : ''}
                            ${task.estimatedTime ? ` · ${task.estimatedTime}분` : ''}
                            ${task.deadline ? ` · ${formatDeadline(task.deadline)}` : ''}
                            ${task.postponeCount && task.postponeCount > 0 ? `
                              <span class="postpone-badge ${task.postponeCount >= 3 ? 'warning' : ''}">
                                ⏰ ${task.postponeCount}번 미룸
                              </span>
                            ` : ''}
                          </div>
                          ${task.tags && task.tags.length > 0 ? `
                            <div class="task-tags">
                              ${task.tags.map(tag => `<span class="task-tag">#${escapeHtml(tag)}</span>`).join('')}
                            </div>
                          ` : ''}
                          ${task.subtasks && task.subtasks.length > 0 ? `
                            ${(() => {
                              const completedCount = task.subtasks.filter(s => s.completed).length;
                              const totalCount = task.subtasks.length;
                              const percentage = Math.round((completedCount / totalCount) * 100);
                              const isExpanded = appState.expandedSubtasks && appState.expandedSubtasks[task.id];
                              const nextSubtask = task.subtasks.find(s => !s.completed);
                              const previewText = nextSubtask ? nextSubtask.text : '모두 완료!';
                              return `
                                <div class="subtask-progress-bar" onclick="event.stopPropagation(); toggleSubtaskExpand('${task.id}')">
                                  <div class="subtask-progress-bar-fill-container">
                                    <div class="subtask-progress-bar-fill ${percentage === 100 ? 'complete' : ''}" style="width: ${percentage}%"></div>
                                  </div>
                                  <span class="subtask-progress-bar-text">${completedCount}/${totalCount} 완료</span>
                                  <span class="subtask-progress-toggle ${isExpanded ? 'expanded' : ''}">▼</span>
                                </div>
                                ${!isExpanded ? `
                                  <div class="subtask-preview" onclick="event.stopPropagation(); toggleSubtaskExpand('${task.id}')">
                                    ${nextSubtask ? '▸ 다음: ' : '🎉 '}${previewText.length > 30 ? previewText.substring(0, 30) + '...' : previewText}
                                  </div>
                                ` : ''}
                                ${isExpanded ? `
                                  <div class="subtask-list-expanded">
                                    ${task.subtasks.map((subtask, idx) => `
                                      <div class="subtask-list-item ${subtask.completed ? 'completed' : ''}" onclick="event.stopPropagation(); toggleSubtaskComplete('${task.id}', ${idx})">
                                        <span class="subtask-list-check">${subtask.completed ? '✓' : ''}</span>
                                        <span class="subtask-list-text">${escapeHtml(subtask.text)}</span>
                                      </div>
                                    `).join('')}
                                    ${completedCount === totalCount && totalCount > 0 ? `
                                      <button class="complete-all-subtasks-btn" onclick="event.stopPropagation(); completeTask('${task.id}')">
                                        🎉 작업 완료하기
                                      </button>
                                    ` : ''}
                                  </div>
                                ` : ''}
                              `;
                            })()}
                          ` : ''}
                          <div class="task-item-actions">
                            ${task.link ? `<button class="btn-small go" onclick="handleGo('${task.link}')">GO</button>` : ''}
                            <button class="btn-small complete" onclick="completeTask('${task.id}')" aria-label="작업 완료">✓</button>
                            <button class="btn-small" onclick="startPomodoro('${task.id}')" title="이 작업에 포모도로 집중" aria-label="포모도로 시작" style="background: rgba(245, 87, 108, 0.1); color: #f5576c;">🍅</button>
                            <button class="btn-small" onclick="postponeTask('${task.id}')" title="내일로 미루기" aria-label="내일로 미루기" style="background: rgba(255, 149, 0, 0.1); color: #ff9500;">⏰</button>
                            <button class="btn-small edit" onclick="editTask('${task.id}')" aria-label="작업 수정">✏️</button>
                            <button class="btn-small delete" onclick="deleteTask('${task.id}')" aria-label="작업 삭제">×</button>
                          </div>
                        </div>
                      `).join('')}
                    </div>
                  </div>
                ` : ''}

                ${appState.showCompletedTasks && completedTasks.length > 0 ? `
                  <div class="task-list-section">
                    <div class="task-list-header" onclick="toggleCompletedTasks()">
                      <div class="task-list-title">✓ 완료한 작업</div>
                      <div class="task-list-count">${completedTasks.length}개 ${appState.showCompletedTasks ? '▼' : '▶'}</div>
                    </div>
                    <div class="task-list show">
                      ${completedTasks.map((task, index) => `
                        <div id="task-completed-${task.id}" class="task-item completed" style="--task-cat-color: var(--cat-${task.category})">
                          <div class="task-item-header">
                            <div class="task-item-title completed">${index + 1}. ${escapeHtml(task.title)}</div>
                          </div>
                          <div class="task-item-meta">
                            <span class="category ${task.category}">${task.category}</span>
                            ${task.estimatedTime ? ` · ${task.estimatedTime}분` : ''}
                          </div>
                          <div class="task-item-actions">
                            <button class="btn-small uncomplete" onclick="uncompleteTask('${task.id}')" aria-label="완료 되돌리기">↩️ 되돌리기</button>
                            <button class="btn-small delete" onclick="deleteTask('${task.id}')">× 삭제</button>
                          </div>
                        </div>
                      `).join('')}
                    </div>
                  </div>
                ` : ''}

                ${appState.tasks.length === 0 ? `
                  <div class="empty-state">
                    <div class="empty-state-icon">📋</div>
                    <div>작업이 없습니다</div>
                    <div style="font-size: 14px; margin-top: 10px">새 작업을 추가해보세요</div>
                  </div>
                ` : ''}
              </div>

              <!-- 오른쪽 컬럼: 지금 집중 -->
              <div class="pc-column-right">
                <!-- ▶ 지금 할 것 -->
                ${nextAction ? `
                  <div class="next-action ${urgencyClass}">
                    <div class="next-action-label">${urgencyLabel[urgencyClass]}</div>
                    <div class="task-title">${nextAction.title}</div>
                    <div class="task-meta">
                      <span class="category ${nextAction.category}">${nextAction.category}</span>
                      ${nextAction.repeatType && nextAction.repeatType !== 'none' ? `<span class="meta-item">🔄 ${getRepeatLabel(nextAction.repeatType)}</span>` : ''}
                      ${nextAction.estimatedTime ? `<span class="meta-item">⏱ ${nextAction.estimatedTime}분</span>` : ''}
                      ${nextAction.deadline ? `<span class="meta-item">⏰ ${formatDeadline(nextAction.deadline)}</span>` : ''}
                      ${nextAction.expectedRevenue ? `<span class="meta-item">💰 ${parseInt(nextAction.expectedRevenue).toLocaleString()}원</span>` : ''}
                    </div>
                    <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-top: 15px;">
                      <button class="btn btn-primary" onclick="handleGo('${nextAction.link || ''}')">
                        ${nextAction.link ? '🚀 GO' : '시작하기'}
                      </button>
                      <button class="quick-timer-btn ${appState.quickTimer.isRunning ? 'running' : ''}" onclick="startQuickTimer('${nextAction.id}')" aria-label="${appState.quickTimer.isRunning ? '타이머 정지' : '5분 집중 타이머 시작'}">
                        ⏱ <span id="quick-timer-display" class="quick-timer-display">${appState.quickTimer.isRunning ?
                          Math.floor(appState.quickTimer.timeLeft / 60) + ':' + String(appState.quickTimer.timeLeft % 60).padStart(2, '0') :
                          '5분 집중'}</span>
                      </button>
                      <button class="btn btn-success" onclick="completeTask('${nextAction.id}')">
                        ✓ 완료
                      </button>
                    </div>
                  </div>
                ` : `
                  ${(() => {
                    const rest = getRestActivity();
                    const completedToday = appState.todayStats.completedToday;
                    const streak = appState.streak.current;
                    return `
                      <div class="empty-state-enhanced">
                        <div class="empty-state-icon-large">🎉</div>
                        <div class="empty-state-title">모든 작업 완료!</div>
                        <div class="empty-state-subtitle">
                          오늘 <strong>${completedToday}개</strong> 완료했어요!
                          ${streak > 1 ? `<br>🔥 ${streak}일 연속 달성 중!` : ''}
                        </div>
                        <div class="empty-state-actions">
                          <button class="empty-state-btn primary" onclick="toggleDetailedAdd()">
                            ➕ 새 작업 추가
                          </button>
                          <button class="empty-state-btn" onclick="showToast('${rest.icon} ${rest.text}: ${rest.desc}', 'success')">
                            ${rest.icon} ${rest.text}
                          </button>
                        </div>
                      </div>
                    `;
                  })()}
                `}

                ${hiddenCount > 0 ? `
                  <div class="hidden-tasks">
                    오늘 못 할 것 ${hiddenCount}개 숨김<br>
                    <span style="font-size: 12px">내일 하면 됩니다</span>
                  </div>
                ` : ''}

                <!-- 🍅 포모도로 타이머 -->
                ${(() => {
                  const pomo = appState.pomodoro;
                  const currentTask = pomo.currentTaskId ? appState.tasks.find(t => t.id === pomo.currentTaskId) : null;
                  if (!pomo.isRunning && !pomo.isBreak && pomo.completedPomodoros === 0) {
                    return `
                      <div class="pomodoro-section" style="margin-bottom: 12px;">
                        <button class="btn btn-secondary" onclick="startPomodoro()" style="width: 100%; padding: 10px;" aria-label="포모도로 시작">
                          🍅 포모도로 25분 집중 시작
                        </button>
                      </div>
                    `;
                  }
                  return `
                    <div class="pomodoro-section ${pomo.isRunning ? 'active' : ''} ${pomo.isBreak ? 'break' : ''}" style="margin-bottom: 12px;">
                      <div class="pomodoro-title">${pomo.isBreak ? '☕ 휴식 중' : '🍅 포모도로'}</div>
                      <div class="pomodoro-time" id="pomodoro-time">${formatPomodoroTime(pomo.timeLeft)}</div>
                      ${currentTask ? `<div class="pomodoro-task" style="font-size: 13px; color: var(--text-secondary); margin-top: 4px; text-align: center;">🎯 ${escapeHtml(currentTask.title)}${currentTask.actualTime ? ` (누적 ${currentTask.actualTime}분)` : ''}</div>` : ''}
                      <div class="pomodoro-controls">
                        ${pomo.isRunning ? `
                          <button class="pomodoro-btn pause" onclick="pausePomodoro()" aria-label="일시정지">⏸ 일시정지</button>
                        ` : `
                          <button class="pomodoro-btn start" onclick="resumePomodoro()" aria-label="재개">▶ 재개</button>
                        `}
                        <button class="pomodoro-btn stop" onclick="stopPomodoro()" aria-label="중지">⏹ 중지</button>
                        ${pomo.isBreak ? `<button class="pomodoro-btn skip" onclick="skipBreak()" aria-label="휴식 건너뛰기">⏭ 건너뛰기</button>` : ''}
                      </div>
                      <div class="pomodoro-stats">
                        <div class="pomodoro-stat">
                          <div class="pomodoro-stat-value">${pomo.completedPomodoros}</div>
                          <div>완료</div>
                        </div>
                      </div>
                    </div>
                  `;
                })()}

                <!-- 🎯 포커스 모드 -->
                ${appState.focusMode && filteredTasks.length > 0 ? `
                  <div class="focus-mode-container">
                    <div class="focus-mode-header">
                      <span>🎯 포커스 모드</span>
                      <span class="focus-mode-hint">가장 중요한 작업에 집중하세요</span>
                    </div>
                    <div class="focus-task">
                      <div class="focus-task-title">${filteredTasks[0].title}</div>
                      <div class="focus-task-meta">
                        <span class="category ${filteredTasks[0].category}">${filteredTasks[0].category}</span>
                        ${filteredTasks[0].estimatedTime ? ` · ${filteredTasks[0].estimatedTime}분` : ''}
                        ${filteredTasks[0].deadline ? ` · ${formatDeadline(filteredTasks[0].deadline)}` : ''}
                      </div>
                      ${filteredTasks[0].subtasks && filteredTasks[0].subtasks.length > 0 ? `
                        <div class="focus-subtasks">
                          ${filteredTasks[0].subtasks.map((st, idx) => `
                            <div class="focus-subtask ${st.completed ? 'completed' : ''}" onclick="toggleSubtaskComplete('${filteredTasks[0].id}', ${idx})">
                              <span class="focus-subtask-check">${st.completed ? '✓' : '○'}</span>
                              <span>${st.text}</span>
                            </div>
                          `).join('')}
                        </div>
                      ` : ''}
                      <div class="focus-actions">
                        <button class="btn btn-primary btn-large" onclick="completeTask('${filteredTasks[0].id}')">
                          ✓ 완료!
                        </button>
                        ${filteredTasks[0].link ? `
                          <button class="btn btn-secondary" onclick="handleGo('${filteredTasks[0].link}')">
                            🔗 열기
                          </button>
                        ` : ''}
                      </div>
                    </div>
                    <div class="focus-remaining">
                      나머지 ${filteredTasks.length - 1}개 작업 대기 중
                    </div>
                  </div>
                ` : ''}

                <!-- 📅 월요일 리마인더 -->
                ${(() => {
                  if (!checkMondayReminder()) return '';
                  const focusTasks = appState.weeklyPlan.focusTasks
                    .map(id => appState.tasks.find(t => t.id === id))
                    .filter(t => t && !t.completed);
                  if (focusTasks.length === 0) return '';
                  return `
                    <div class="monday-reminder">
                      <div class="monday-reminder-header">
                        <div class="monday-reminder-title">🎯 이번 주 집중할 작업</div>
                        <button class="monday-reminder-close" onclick="dismissMondayReminder()">×</button>
                      </div>
                      <div class="monday-reminder-tasks">
                        ${focusTasks.map((task, idx) => `
                          <div class="monday-reminder-task" onclick="editTask('${task.id}')">
                            <span class="monday-reminder-task-num">${idx + 1}</span>
                            <span>${escapeHtml(task.title)}</span>
                          </div>
                        `).join('')}
                      </div>
                    </div>
                  `;
                })()}

                <!-- PWA 설치 배너 -->
                <div id="install-banner" class="install-banner">
                  <div class="install-banner-content">
                    <div class="install-banner-text">
                      📱 홈 화면에 추가하면 더 빠르게!
                    </div>
                    <button class="install-banner-btn" onclick="installPWA()">설치</button>
                    <button class="install-banner-close" onclick="closeInstallBanner()">×</button>
                  </div>
                </div>

              </div>

              <!-- 4K 전용: 전체 작업 목록 (4번째 컬럼) -->
              <div class="pc-column-tasklist">
                <div class="tasklist-4k-header">📋 전체 작업 (${filteredTasks.filter(t => !t.completed).length})</div>
                <div class="search-simple">
                  <input
                    type="text"
                    class="search-input"
                    placeholder="🔍 검색..."
                    value="${appState.searchQuery}"
                    oninput="setSearchQuery(this.value)"
                  >
                  ${appState.searchQuery ? `<button class="search-clear" onclick="clearSearch()">×</button>` : ''}
                </div>
                <div class="task-list-inner">
                  ${filteredTasks
                    .filter(t => !t.completed)
                    .map(task => `
                      <div class="task-item-mini" onclick="editTask('${task.id}')" style="--task-cat-color: var(--cat-${task.category})">
                        <div class="task-item-mini-left">
                          <button class="task-check-btn" onclick="event.stopPropagation(); completeTask('${task.id}')" aria-label="작업 완료">○</button>
                          <span class="task-item-mini-title">${escapeHtml(task.title)}</span>
                        </div>
                        <span class="task-item-mini-category ${task.category}">${task.category}</span>
                      </div>
                    `).join('')}
                </div>
                ${filteredTasks.filter(t => t.completed).length > 0 ? `
                  <details class="completed-tasks-4k" style="margin-top: 8px;">
                    <summary style="cursor: pointer; font-size: 14px; color: var(--text-secondary); padding: 8px 0;">
                      ✅ 완료 ${filteredTasks.filter(t => t.completed).length}개
                    </summary>
                    <div class="task-list-inner" style="opacity: 0.6;">
                      ${filteredTasks
                        .filter(t => t.completed)
                        .slice(0, 20)
                        .map(task => `
                          <div class="task-item-mini" onclick="editTask('${task.id}')" style="text-decoration: line-through; --task-cat-color: var(--cat-${task.category})">
                            <div class="task-item-mini-left">
                              <button class="task-check-btn" onclick="event.stopPropagation(); completeTask('${task.id}')" style="border-color: #48bb78; color: #48bb78;">✓</button>
                              <span class="task-item-mini-title">${escapeHtml(task.title)}</span>
                            </div>
                            <span class="task-item-mini-category ${task.category}">${task.category}</span>
                          </div>
                        `).join('')}
                    </div>
                  </details>
                ` : ''}
              </div>
            </div>
            ` : ''}
          </div>

          <!-- 일정 탭 -->
          <div class="tab-content ${appState.currentTab === 'schedule' ? 'active' : ''}">
            ${appState.currentTab === 'schedule' ? `
            <div class="schedule-filter">
              <button class="schedule-filter-btn ${appState.scheduleFilter === 'all' ? 'active' : ''}" onclick="setScheduleFilter('all')">
                전체
              </button>
              <button class="schedule-filter-btn ${appState.scheduleFilter === 'today' ? 'active' : ''}" onclick="setScheduleFilter('today')">
                오늘
              </button>
              <button class="schedule-filter-btn ${appState.scheduleFilter === 'weekday' ? 'active' : ''}" onclick="setScheduleFilter('weekday')">
                평일
              </button>
              <button class="schedule-filter-btn ${appState.scheduleFilter === 'weekend' ? 'active' : ''}" onclick="setScheduleFilter('weekend')">
                주말
              </button>
            </div>

            <div class="schedule-week-grid">
              ${getTasksByDate().map(day => `
                <div class="schedule-day">
                  <div class="schedule-day-header ${day.isToday ? 'today' : ''} ${day.isWeekend ? 'weekend' : ''}">
                    <span>${day.dayName}</span>
                    <span class="schedule-day-count">${day.tasks.length}개</span>
                  </div>
                  <div class="schedule-day-tasks">
                    ${day.tasks.length > 0 ? day.tasks.map(task => `
                      <div class="schedule-task">
                        <span class="schedule-task-time">${formatTime(task.deadline)}</span>
                        <span class="schedule-task-title">${escapeHtml(task.title)}</span>
                        <span class="schedule-task-category category ${task.category}">${task.category}</span>
                      </div>
                    `).join('') : `
                      <div class="schedule-empty">
                        ${day.isToday ? '오늘은 여유로운 날!' : '일정 없음'}
                      </div>
                    `}
                  </div>
                </div>
              `).join('')}
            </div>

            ${appState.tasks.filter(t => !t.completed && !t.deadline).length > 0 ? `
              <div class="dashboard-section" style="margin-top: 20px;">
                <div class="dashboard-title">📌 마감 없는 작업 (${appState.tasks.filter(t => !t.completed && !t.deadline).length}개)</div>
                <div class="task-list show">
                  ${appState.tasks.filter(t => !t.completed && !t.deadline).map((task, index) => `
                    <div class="task-item" style="--task-cat-color: var(--cat-${task.category})">
                      <div class="task-item-header">
                        <div class="task-item-title">${index + 1}. ${escapeHtml(task.title)}</div>
                      </div>
                      <div class="task-item-meta">
                        <span class="category ${task.category}">${task.category}</span>
                        ${task.estimatedTime ? ` · ${task.estimatedTime}분` : ''}
                      </div>
                      <div class="task-item-actions">
                        <button class="btn-small edit" onclick="editTask('${task.id}')">✏️ 마감 추가</button>
                        <button class="btn-small complete" onclick="completeTask('${task.id}')" aria-label="작업 완료">✓</button>
                      </div>
                    </div>
                  `).join('')}
                </div>
              </div>
            ` : ''}
            ` : ''}
          </div>

          <!-- 본업 프로젝트 탭 -->
          <div class="tab-content ${appState.currentTab === 'work' ? 'active' : ''}">
            ${appState.currentTab === 'work' ? renderWorkProjects() : ''}
          </div>

          <!-- 부업 이벤트 탭 -->
          <div class="tab-content ${appState.currentTab === 'events' ? 'active' : ''}">
            ${appState.currentTab === 'events' ? (() => {
              const eventTasks = appState.tasks.filter(t => t.category === '부업');
              const pendingEvents = eventTasks.filter(t => !t.completed).sort((a, b) => {
                if (!a.deadline) return 1;
                if (!b.deadline) return -1;
                return new Date(a.deadline) - new Date(b.deadline);
              });
              const submittedEvents = eventTasks.filter(t => t.completed).sort((a, b) => {
                return new Date(b.deadline || 0) - new Date(a.deadline || 0);
              });

              const getDaysLeft = (deadline) => {
                if (!deadline) return null;
                const now = new Date();
                const d = new Date(deadline);
                const diff = Math.ceil((d - now) / (1000 * 60 * 60 * 24));
                return diff;
              };

              const formatDday = (days) => {
                if (days === null) return '';
                if (days < 0) return '<span style="color:#f5576c">D+' + Math.abs(days) + '</span>';
                if (days === 0) return '<span style="color:#f5576c">D-Day</span>';
                if (days <= 3) return '<span style="color:#ff9500">D-' + days + '</span>';
                return 'D-' + days;
              };

              const urgentCount = pendingEvents.filter(t => {
                const d = getDaysLeft(t.deadline);
                return d !== null && d <= 1;
              }).length;

              // 텔레그램 연동 작업 수 확인
              const telegramLinkedCount = eventTasks.filter(t => t.source && t.source.type === 'telegram-event').length;

              return `
                <div class="events-header">
                  <div class="events-title">💰 이벤트</div>
                  <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
                    <button class="event-bulk-select-btn ${_eventBulkSelectMode ? 'active' : ''}" onclick="toggleEventBulkSelect()" aria-label="이벤트 일괄 선택 모드 ${_eventBulkSelectMode ? '해제' : '진입'}">☑ 선택</button>
                    <button class="telegram-status ${telegramLinkedCount > 0 ? 'connected' : ''}" onclick="showTelegramEvents()" aria-label="텔레그램 이벤트 목록 보기" title="클릭하여 텔레그램 이벤트 확인">
                      <span class="telegram-icon">🤖</span>
                      <span class="telegram-text">${telegramLinkedCount > 0 ? '텔레그램 연동 ' + telegramLinkedCount + '개' : '텔레그램 미연동'}</span>
                    </button>
                  </div>
                </div>

                ${_eventBulkSelectMode ? `
                <div class="event-bulk-actions">
                  <button onclick="toggleEventSelectAll()" aria-label="전체 선택/해제">전체</button>
                  <button class="bulk-delete-btn" onclick="bulkDeleteEvents()" ${_eventBulkSelectedIds.size === 0 ? 'disabled' : ''} aria-label="${_eventBulkSelectedIds.size}개 삭제">🗑 삭제 (${_eventBulkSelectedIds.size})</button>
                  <button class="bulk-cancel-btn" onclick="toggleEventBulkSelect()" aria-label="선택 모드 취소">취소</button>
                  <span class="event-bulk-count">${_eventBulkSelectedIds.size}개 선택</span>
                </div>
                ` : ''}

                <!-- 이벤트 빠른 추가 -->
                <div class="events-quick-add">
                  <input
                    type="text"
                    class="events-quick-input"
                    placeholder="이벤트명 입력 후 Enter (예: 불개미 AMA)"
                    id="event-quick-input"
                    onkeypress="if(event.key==='Enter') quickAddEvent()"
                  >
                  <button class="events-quick-btn" onclick="quickAddEvent()">+</button>
                  <button class="events-detail-btn" onclick="addNewEvent()" title="상세 입력">📝</button>
                </div>

                <div class="events-summary">
                  <div class="events-summary-item">
                    <div class="events-summary-value" style="color: ${urgentCount > 0 ? '#f5576c' : '#48bb78'}">${pendingEvents.length}</div>
                    <div class="events-summary-label">미제출</div>
                  </div>
                  <div class="events-summary-item">
                    <div class="events-summary-value" style="color: #ff9500">${urgentCount}</div>
                    <div class="events-summary-label">긴급 (D-1)</div>
                  </div>
                  <div class="events-summary-item">
                    <div class="events-summary-value" style="color: #48bb78">${submittedEvents.length}</div>
                    <div class="events-summary-label">제출완료</div>
                  </div>
                </div>

                ${(() => {
                  if (pendingEvents.length === 0) {
                    return `
                      <div class="events-empty">
                        <div class="events-empty-icon">🎉</div>
                        <div class="events-empty-text">미제출 이벤트가 없습니다!</div>
                      </div>
                    `;
                  }

                  // 기한별 그룹화: 긴급(D-1 이하) / 마감 전(D-2~D-5) / 미제출(나머지)
                  const urgent = pendingEvents.filter(t => { const d = getDaysLeft(t.deadline); return d !== null && d <= 1; });
                  const approaching = pendingEvents.filter(t => { const d = getDaysLeft(t.deadline); return d !== null && d >= 2 && d <= 5; });
                  const pending = pendingEvents.filter(t => { const d = getDaysLeft(t.deadline); return d === null || d > 5; });

                  const renderEventCard = (task) => {
                    const days = getDaysLeft(task.deadline);
                    const startDateStr = task.startDate ? new Date(task.startDate).toLocaleDateString('ko-KR', {month:'short', day:'numeric'}) : '';
                    const deadlineStr = task.deadline ? new Date(task.deadline).toLocaleDateString('ko-KR', {month:'short', day:'numeric'}) : '';
                    let dateDisplay = '';
                    if (startDateStr && deadlineStr) {
                      dateDisplay = startDateStr + '~' + deadlineStr;
                    } else if (deadlineStr) {
                      dateDisplay = '~' + deadlineStr;
                    } else if (startDateStr) {
                      dateDisplay = startDateStr + '~';
                    }
                    const metaItems = [];
                    // 텔레그램 source에서 project/organizer 우선 표시
                    const srcProject = task.source?.project;
                    const srcOrganizer = task.source?.organizer;
                    if (srcProject) metaItems.push(srcProject);
                    if (srcOrganizer || task.organizer) metaItems.push(srcOrganizer || task.organizer);
                    if (task.eventType) metaItems.push(task.eventType);
                    if (task.expectedRevenue) metaItems.push('₩' + Number(task.expectedRevenue).toLocaleString());
                    const metaStr = metaItems.join(' · ');
                    const telegramBadge = task.source && task.source.type === 'telegram-event' ? '<span class="event-tg-badge" title="텔레그램 연동">📱</span>' : '';
                    return `
                      <div class="event-card ${days !== null && days <= 1 ? 'urgent' : (days !== null && days <= 3 ? 'warning' : '')}" style="${_eventBulkSelectMode ? 'display:flex;align-items:center' : ''}">
                        ${_eventBulkSelectMode ? '<div class="event-check-col"><input type="checkbox" ' + (_eventBulkSelectedIds.has(task.id) ? 'checked' : '') + ' onchange="toggleEventSelection(' + task.id + ')" aria-label="' + escapeHtml(task.title) + ' 선택"></div>' : ''}
                        <div style="flex:1;min-width:0">
                          <div class="event-card-main">
                            <div class="event-title">${telegramBadge}${escapeHtml(task.title)}</div>
                            ${metaStr ? '<div class="event-meta-info">' + escapeHtml(metaStr) + '</div>' : ''}
                            ${task.description ? '<div class="event-description">' + escapeHtml(task.description.slice(0, 60)) + (task.description.length > 60 ? '...' : '') + '</div>' : ''}
                          </div>
                          ${dateDisplay ? '<span class="event-compact-date">' + dateDisplay + '</span>' : ''}
                          ${_eventBulkSelectMode ? '' : `<div class="event-actions">
                            ${task.link ? '<a href="' + task.link + '" target="_blank" class="btn btn-small btn-link">🔗</a>' : ''}
                            <button class="btn btn-small btn-submit" onclick="completeTask('${task.id}')" aria-label="작업 완료">✓</button>
                            <button class="btn btn-small btn-edit" onclick="editTask('${task.id}')" aria-label="작업 수정">✏️</button>
                            <button class="btn btn-small btn-delete" onclick="deleteTask('${task.id}')" aria-label="작업 삭제">🗑️</button>
                          </div>`}
                          <div class="event-dday">${days !== null ? (days < 0 ? 'D+' + Math.abs(days) : (days === 0 ? 'D-Day' : 'D-' + days)) : ''}</div>
                        </div>
                      </div>
                    `;
                  };

                  const renderGroup = (groupId, title, icon, events) => {
                    if (events.length === 0) return '';
                    const isCollapsed = _collapsedEventGroups.has(groupId);
                    const groupIds = events.map(e => e.id);
                    const allChecked = _eventBulkSelectMode && groupIds.every(id => _eventBulkSelectedIds.has(id));
                    return `
                      <div class="events-group">
                        <div class="events-group-header" onclick="toggleEventGroup('${groupId}')">
                          <span>
                            ${_eventBulkSelectMode ? '<input type="checkbox" ' + (allChecked ? 'checked' : '') + ' onclick="event.stopPropagation(); toggleEventGroupSelect([' + groupIds.join(',') + '])" style="width:18px;height:18px;margin-right:6px;vertical-align:middle;cursor:pointer;min-width:44px;min-height:44px;accent-color:var(--accent-primary)">' : ''}
                            ${icon} ${title} (${events.length})
                          </span>
                          <span class="toggle-icon">${isCollapsed ? '▶' : '▼'}</span>
                        </div>
                        <div class="events-list ${isCollapsed ? 'collapsed' : ''}">
                          ${events.map(renderEventCard).join('')}
                        </div>
                      </div>
                    `;
                  };

                  return `
                    ${renderGroup('urgent', '긴급', '🚨', urgent)}
                    ${renderGroup('approaching', '마감 전', '⚡', approaching)}
                    ${renderGroup('pending', '미제출', '📅', pending)}
                  `;
                })()}

                ${submittedEvents.length > 0 ? (() => {
                  const submittedIds = submittedEvents.map(t => t.id);
                  const allSubmittedChecked = _eventBulkSelectMode && submittedIds.every(id => _eventBulkSelectedIds.has(id));
                  return `
                  <div class="events-group">
                    <div class="events-group-header" onclick="toggleEventGroup('submitted')">
                      <span>
                        ${_eventBulkSelectMode ? '<input type="checkbox" ' + (allSubmittedChecked ? 'checked' : '') + ' onclick="event.stopPropagation(); toggleEventGroupSelect([' + submittedIds.join(',') + '])" style="width:18px;height:18px;margin-right:6px;vertical-align:middle;cursor:pointer;min-width:44px;min-height:44px;accent-color:var(--accent-primary)">' : ''}
                        ✅ 제출완료 (${submittedEvents.length})
                      </span>
                      <span class="toggle-icon">${_collapsedEventGroups.has('submitted') ? '▶' : '▼'}</span>
                    </div>`;
                })() + `
                    <div class="events-list ${_collapsedEventGroups.has('submitted') ? 'collapsed' : ''}">
                      ${submittedEvents.map(task => {
                        const completedDate = task.completedAt ? new Date(task.completedAt) : null;
                        const completedStr = completedDate ? completedDate.toLocaleDateString('ko-KR', {month:'short', day:'numeric'}) + ' ' + completedDate.toTimeString().slice(0,5) : '';
                        const isTelegram = task.source && task.source.type === 'telegram-event';
                        return `
                        <div class="event-card completed" style="${_eventBulkSelectMode ? 'display:flex;align-items:center' : ''}">
                          ${_eventBulkSelectMode ? '<div class="event-check-col"><input type="checkbox" ' + (_eventBulkSelectedIds.has(task.id) ? 'checked' : '') + ' onchange="toggleEventSelection(' + task.id + ')" aria-label="' + escapeHtml(task.title) + ' 선택"></div>' : ''}
                          <div style="flex:1;min-width:0">
                            <div class="event-title">${isTelegram ? '<span class="event-tg-badge">📱</span>' : ''}${escapeHtml(task.title)}</div>
                            ${completedStr ? `<span class="event-completed-date" onclick="editCompletedAt('${task.id}')" title="클릭하여 수정">✓ ${completedStr}</span>` : ''}
                            ${isTelegram ? '<span class="event-tg-synced" title="텔레그램 동기화됨">✓ 동기화</span>' : ''}
                            ${_eventBulkSelectMode ? '' : `<div class="event-actions">
                              <button class="btn btn-small btn-undo" onclick="uncompleteTask('${task.id}')" aria-label="완료 되돌리기">↩</button>
                              <button class="btn btn-small btn-delete" onclick="deleteTask('${task.id}')" aria-label="작업 삭제">🗑</button>
                            </div>`}
                          </div>
                        </div>
                      `}).join('')}
                    </div>
                  </div>
                ` : ''}

                ${(() => {
                  const eventTrash = appState.trash.filter(t => t.category === '부업');
                  if (eventTrash.length === 0) return '';
                  const isCollapsed = _collapsedEventGroups.has('trash');
                  return `
                    <div class="events-group" style="margin-top:16px">
                      <div class="events-group-header" onclick="toggleEventGroup('trash')" style="color:var(--text-muted)">
                        <span>🗑 휴지통 (${eventTrash.length})</span>
                        <span style="display:flex;align-items:center;gap:8px">
                          <button onclick="event.stopPropagation(); emptyTrash()" style="font-size:11px;padding:3px 8px;border-radius:6px;border:1px solid var(--border-color);background:transparent;color:var(--text-muted);cursor:pointer;min-height:44px" aria-label="휴지통 비우기">비우기</button>
                          <span class="toggle-icon">${isCollapsed ? '▶' : '▼'}</span>
                        </span>
                      </div>
                      <div class="events-list ${isCollapsed ? 'collapsed' : ''}">
                        ${eventTrash.sort((a, b) => (b.deletedAt || '').localeCompare(a.deletedAt || '')).map(task => {
                          const deletedDate = task.deletedAt ? new Date(task.deletedAt) : null;
                          const deletedStr = deletedDate ? deletedDate.toLocaleDateString('ko-KR', {month:'short', day:'numeric'}) + ' 삭제' : '';
                          const daysLeft = task.deletedAt ? Math.max(0, 30 - Math.floor((Date.now() - new Date(task.deletedAt).getTime()) / (1000*60*60*24))) : 30;
                          return '<div class="event-card" style="opacity:0.7">' +
                            '<div class="event-card-main">' +
                              '<div class="event-title">' + escapeHtml(task.title) + '</div>' +
                              '<div class="event-meta-info" style="font-size:11px;color:var(--text-muted)">' + deletedStr + ' · ' + daysLeft + '일 후 영구삭제</div>' +
                            '</div>' +
                            '<div class="event-actions">' +
                              '<button class="btn btn-small btn-undo" onclick="restoreFromTrash(' + task.id + ')" aria-label="복원" title="복원">↩</button>' +
                              '<button class="btn btn-small btn-delete" onclick="permanentDeleteFromTrash(' + task.id + ')" aria-label="영구삭제" title="영구삭제">✕</button>' +
                            '</div>' +
                          '</div>';
                        }).join('')}
                      </div>
                    </div>
                  `;
                })()}
              `;
            })() : ''}
          </div>

          <!-- 일상/가족 탭 -->
          <div class="tab-content ${appState.currentTab === 'life' ? 'active' : ''}">
            ${appState.currentTab === 'life' ? (() => {
              const now = new Date();
              const todayEnd = new Date(now);
              todayEnd.setHours(23, 59, 59, 999);

              const lifeTasks = appState.tasks.filter(t => t.category === '일상' || t.category === '가족');
              const pendingTasks = lifeTasks.filter(t => {
                if (t.completed) return false;
                // 반복 작업 중 미래 마감일(내일 이후)인 작업 제외
                if (t.deadline && t.repeatType && t.repeatType !== 'none') {
                  const deadline = new Date(t.deadline);
                  if (deadline > todayEnd) return false;
                }
                return true;
              }).sort((a, b) => {
                if (!a.deadline) return 1;
                if (!b.deadline) return -1;
                return new Date(a.deadline) - new Date(b.deadline);
              });
              // 모든 완료 태스크 표시
              const completedTasks = lifeTasks.filter(t => t.completed);
              // 일상을 반복/일회성으로 분리
              const isRepeat = (t) => t.repeatType && t.repeatType !== 'none';
              const repeatTasks = pendingTasks.filter(t => t.category === '일상' && isRepeat(t));
              const onceTasks = pendingTasks.filter(t => t.category === '일상' && !isRepeat(t));
              const familyTasks = pendingTasks.filter(t => t.category === '가족');
              // 완료된 반복 작업 (리셋 대상)
              const completedRepeatTasks = completedTasks.filter(t => t.category === '일상' && isRepeat(t));

              return `
                <div class="life-header">
                  <div class="life-title">🏠 일상 & 가족</div>
                </div>

                <!-- 빠른 추가 -->
                <div class="life-quick-add">
                  <input
                    type="text"
                    class="life-quick-input"
                    placeholder="일상/가족 작업 추가 (#가족 붙이면 가족으로)"
                    id="life-quick-input"
                    onkeypress="if(event.key==='Enter') quickAddLifeTask()"
                  >
                  <button class="life-quick-btn" onclick="quickAddLifeTask()">+</button>
                </div>

                <div class="life-summary">
                  <div class="life-summary-item">
                    <div class="life-summary-value">${repeatTasks.length}</div>
                    <div class="life-summary-label">🔁 반복</div>
                  </div>
                  <div class="life-summary-item">
                    <div class="life-summary-value">${onceTasks.length}</div>
                    <div class="life-summary-label">📌 일회성</div>
                  </div>
                  <div class="life-summary-item">
                    <div class="life-summary-value">${familyTasks.length}</div>
                    <div class="life-summary-label">👨‍👩‍👧 가족</div>
                  </div>
                  <div class="life-summary-item">
                    <div class="life-summary-value" style="color: #48bb78">${completedTasks.length}</div>
                    <div class="life-summary-label">✓ 완료</div>
                  </div>
                </div>

                ${repeatTasks.length > 0 || completedRepeatTasks.length > 0 ? `
                  <div class="life-section">
                    <div class="life-section-header">
                      <div class="life-section-title">🔁 일상 (반복) ${repeatTasks.length > 0 ? `(${repeatTasks.length})` : ''}</div>
                      ${completedRepeatTasks.length > 0 ? `
                        <button class="life-reset-btn" onclick="resetCompletedRepeatTasks()" title="완료된 반복 작업 리셋">
                          ↺ 리셋 (${completedRepeatTasks.length})
                        </button>
                      ` : ''}
                    </div>
                    ${repeatTasks.length > 0 ? `
                      <div class="life-list">
                        ${repeatTasks.map(task => `
                          <div class="life-item" style="--task-cat-color: var(--cat-${task.category})">
                            <button class="task-check-btn" onclick="completeTask('${task.id}')" aria-label="작업 완료">○</button>
                            <div class="life-item-content">
                              <div class="life-item-title">${escapeHtml(task.title)}</div>
                              <div class="life-item-meta">
                                ${task.repeatType === 'daily' ? '매일' : task.repeatType === 'weekdays' ? '평일' : '반복'}
                              </div>
                            </div>
                            <div class="life-item-actions">
                              <button class="life-action-btn" onclick="editTask('${task.id}')" title="수정" aria-label="작업 수정">✏️</button>
                              <button class="life-action-btn delete" onclick="deleteTask('${task.id}')" title="삭제" aria-label="작업 삭제">🗑️</button>
                            </div>
                          </div>
                        `).join('')}
                      </div>
                    ` : `<div class="life-all-done">✓ 오늘 반복 작업 모두 완료!</div>`}
                  </div>
                ` : ''}

                ${onceTasks.length > 0 ? `
                  <div class="life-section">
                    <div class="life-section-title">📌 일상 (일회성) (${onceTasks.length})</div>
                    <div class="life-list">
                      ${onceTasks.map(task => `
                        <div class="life-item" style="--task-cat-color: var(--cat-${task.category})">
                          <button class="task-check-btn" onclick="completeTask('${task.id}')" aria-label="작업 완료">○</button>
                          <div class="life-item-content">
                            <div class="life-item-title">${escapeHtml(task.title)}</div>
                            <div class="life-item-meta">
                              ${task.deadline ? new Date(task.deadline).toLocaleDateString('ko-KR', {month:'short', day:'numeric'}) : ''}
                            </div>
                          </div>
                          <div class="life-item-actions">
                            <button class="life-action-btn" onclick="editTask('${task.id}')" title="수정" aria-label="작업 수정">✏️</button>
                            <button class="life-action-btn delete" onclick="deleteTask('${task.id}')" title="삭제" aria-label="작업 삭제">🗑️</button>
                          </div>
                        </div>
                      `).join('')}
                    </div>
                  </div>
                ` : ''}

                ${familyTasks.length > 0 ? `
                  <div class="life-section">
                    <div class="life-section-title">👨‍👩‍👧 가족 (${familyTasks.length})</div>
                    <div class="life-list">
                      ${familyTasks.map(task => `
                        <div class="life-item" style="--task-cat-color: var(--cat-${task.category})">
                          <button class="task-check-btn" onclick="completeTask('${task.id}')" aria-label="작업 완료">○</button>
                          <div class="life-item-content">
                            <div class="life-item-title">${escapeHtml(task.title)}</div>
                            <div class="life-item-meta">
                              ${task.deadline ? new Date(task.deadline).toLocaleDateString('ko-KR', {month:'short', day:'numeric'}) : ''}
                              ${task.repeatType && task.repeatType !== 'none' ? ' 🔁' : ''}
                            </div>
                          </div>
                          <div class="life-item-actions">
                            <button class="life-action-btn" onclick="editTask('${task.id}')" title="수정" aria-label="작업 수정">✏️</button>
                            <button class="life-action-btn delete" onclick="deleteTask('${task.id}')" title="삭제" aria-label="작업 삭제">🗑️</button>
                          </div>
                        </div>
                      `).join('')}
                    </div>
                  </div>
                ` : ''}

                ${pendingTasks.length === 0 ? `
                  <div class="life-empty">
                    <div class="life-empty-icon">🏡</div>
                    <div class="life-empty-text">일상/가족 작업이 없습니다</div>
                  </div>
                ` : ''}

                ${completedTasks.length > 0 ? `
                  <div class="life-section" style="margin-top: 24px; opacity: 0.7;">
                    <div class="life-section-title">✓ 완료됨 (${completedTasks.length})</div>
                    <div class="life-list">
                      ${completedTasks.slice(0, 5).map(task => `
                        <div class="life-item completed" style="opacity: 0.6; --task-cat-color: var(--cat-${task.category})">
                          <div class="task-check-btn checked" style="color: #48bb78;">✓</div>
                          <div class="life-item-content" style="text-decoration: line-through;">
                            <div class="life-item-title">${escapeHtml(task.title)}</div>
                          </div>
                          <div class="life-item-actions" style="opacity: 1;">
                            <button class="life-action-btn" onclick="uncompleteTask('${task.id}')" title="되돌리기" aria-label="완료 되돌리기">↩️</button>
                            <button class="life-action-btn delete" onclick="deleteTask('${task.id}')" title="삭제" aria-label="작업 삭제">🗑️</button>
                          </div>
                        </div>
                      `).join('')}
                      ${completedTasks.length > 5 ? `<div style="text-align: center; color: var(--text-muted); font-size: 12px; padding: 8px;">+ ${completedTasks.length - 5}개 더</div>` : ''}
                    </div>
                  </div>
                ` : ''}
              `;
            })() : ''}
          </div>



          <!-- 통근 트래커 탭 -->
          <div class="tab-content ${appState.currentTab === 'commute' ? 'active' : ''}">
            ${appState.currentTab === 'commute' ? renderCommuteTab() : ''}
          </div>

          <!-- 대시보드 탭 -->
          <div class="tab-content ${appState.currentTab === 'dashboard' ? 'active' : ''}">
            ${appState.currentTab === 'dashboard' ? `
            <div class="dashboard-section">
              <div class="dashboard-title">📈 오늘 요약</div>
              <div class="stats">
                <div class="stat-card">
                  <div class="stat-value">${stats.total}</div>
                  <div class="stat-label">전체 작업</div>
                </div>
                <div class="stat-card">
                  <div class="stat-value" style="color: #48bb78">${stats.completed}</div>
                  <div class="stat-label">완료</div>
                </div>
                <div class="stat-card">
                  <div class="stat-value">${stats.total > 0 ? Math.round((stats.completed / stats.total) * 100) : 0}%</div>
                  <div class="stat-label">완료율</div>
                </div>
                <div class="stat-card streak">
                  <div class="stat-value">🔥 ${appState.streak.current}</div>
                  <div class="stat-label">연속 달성</div>
                  ${appState.streak.best > 0 ? `<div class="stat-best">최고: ${appState.streak.best}일</div>` : ''}
                </div>
              </div>
            </div>

            ${(() => {
              const revenueStats = getRevenueStats();
              if (revenueStats.totalRevenue === 0) return '';

              const formatRevenue = (amount) => {
                if (amount >= 10000) return Math.round(amount / 10000) + '만';
                if (amount >= 1000) return Math.round(amount / 1000) + '천';
                return amount.toLocaleString();
              };

              return `
                <div class="dashboard-section revenue-dashboard">
                  <div class="dashboard-header">
                    <div class="dashboard-title">💰 수익 대시보드</div>
                    <button class="btn-export-asset" onclick="exportToAssetManager()" title="자산관리로 내보내기">
                      📤 자산관리
                    </button>
                  </div>
                  <div class="revenue-summary">
                    <div class="revenue-card total">
                      <div class="revenue-card-label">총 수익</div>
                      <div class="revenue-card-value">${revenueStats.totalRevenue.toLocaleString()}원</div>
                      <div class="revenue-card-sub">${revenueStats.taskCount}개 완료</div>
                    </div>
                    <div class="revenue-card month">
                      <div class="revenue-card-label">이번 달</div>
                      <div class="revenue-card-value">${revenueStats.thisMonthRevenue.toLocaleString()}원</div>
                    </div>
                  </div>

                  <div class="revenue-chart-section">
                    <div class="revenue-chart-title">📊 월별 수익 추이</div>
                    <div class="revenue-bar-chart">
                      ${revenueStats.monthlyData.map(m => `
                        <div class="revenue-bar-item">
                          <div class="revenue-bar-wrapper">
                            <div class="revenue-bar" style="height: ${Math.max((m.revenue / revenueStats.maxMonthlyRevenue) * 100, 5)}%">
                              ${m.revenue > 0 ? `<span class="revenue-bar-value">${formatRevenue(m.revenue)}</span>` : ''}
                            </div>
                          </div>
                          <div class="revenue-bar-label">${m.label}</div>
                        </div>
                      `).join('')}
                    </div>
                  </div>

                  ${revenueStats.categoryData.length > 0 ? `
                    <div class="revenue-category-section">
                      <div class="revenue-chart-title">📂 카테고리별 수익</div>
                      <div class="revenue-category-list">
                        ${revenueStats.categoryData.map(c => `
                          <div class="revenue-category-item">
                            <div class="revenue-category-header">
                              <span class="category ${c.category}">${c.category}</span>
                              <span class="revenue-category-amount">${c.revenue.toLocaleString()}원</span>
                            </div>
                            <div class="revenue-category-bar">
                              <div class="revenue-category-bar-fill ${c.category}" style="width: ${c.percentage}%"></div>
                            </div>
                            <div class="revenue-category-percent">${c.percentage}%</div>
                          </div>
                        `).join('')}
                      </div>
                    </div>
                  ` : ''}
                </div>
              `;
            })()}

            ${(() => {
              const rhythmStats = getLifeRhythmStats();
              if (!rhythmStats.hasData) return '';

              return `
                <div class="dashboard-section life-rhythm-stats">
                  <div class="dashboard-title">😴 라이프 리듬 (최근 7일)</div>

                  <!-- 수면 패턴 차트 -->
                  <div class="rhythm-chart-section">
                    <div class="rhythm-chart-title">💤 수면 패턴</div>
                    <div class="rhythm-bar-chart">
                      ${rhythmStats.sleepData.map(d => `
                        <div class="rhythm-bar-item">
                          <div class="rhythm-bar-wrapper">
                            <div class="rhythm-bar ${d.hours >= 7 ? 'good' : d.hours >= 6 ? 'ok' : 'bad'}"
                                 style="height: ${d.hours ? Math.max((d.hours / 10) * 100, 10) : 0}%"
                                 title="${d.date}: ${d.hours ? d.hours.toFixed(1) + '시간' : '기록없음'}">
                              ${d.hours ? '<span class="rhythm-bar-value">' + d.hours.toFixed(1) + 'h</span>' : ''}
                            </div>
                          </div>
                          <div class="rhythm-bar-label ${d.isToday ? 'today' : ''}">${d.dayLabel}</div>
                        </div>
                      `).join('')}
                    </div>
                    <div class="rhythm-summary-row">
                      <span>평균 수면: <strong>${rhythmStats.avgSleep.toFixed(1)}시간</strong></span>
                      <span>목표 대비: <strong class="${rhythmStats.avgSleep >= rhythmStats.targetSleepHours ? 'good' : 'bad'}">${rhythmStats.avgSleep >= rhythmStats.targetSleepHours ? '+' : ''}${(rhythmStats.avgSleep - rhythmStats.targetSleepHours).toFixed(1)}시간</strong></span>
                    </div>
                    ${rhythmStats.avgWakeUp || rhythmStats.avgBedtime ? `
                    <div class="rhythm-summary-row">
                      ${rhythmStats.avgWakeUp ? `<span>평균 기상: <strong>${rhythmStats.avgWakeUp}</strong> ${rhythmStats.wakeTimeDiff !== null ? '<strong class="' + (Math.abs(rhythmStats.wakeTimeDiff) <= 15 ? 'good' : 'bad') + '">' + (rhythmStats.wakeTimeDiff > 0 ? '+' : '') + rhythmStats.wakeTimeDiff + '분</strong>' : ''}</span>` : ''}
                      ${rhythmStats.avgBedtime ? `<span>평균 취침: <strong>${rhythmStats.avgBedtime}</strong> ${rhythmStats.bedtimeDiff !== null ? '<strong class="' + (Math.abs(rhythmStats.bedtimeDiff) <= 15 ? 'good' : 'bad') + '">' + (rhythmStats.bedtimeDiff > 0 ? '+' : '') + rhythmStats.bedtimeDiff + '분</strong>' : ''}</span>` : ''}
                    </div>
                    ` : ''}
                  </div>

                  <!-- 근무 패턴 -->
                  <div class="rhythm-work-section">
                    <div class="rhythm-chart-title">💼 근무 패턴</div>
                    <div class="rhythm-work-stats">
                      <div class="rhythm-work-stat">
                        <span class="rhythm-work-label">평균 출근</span>
                        <span class="rhythm-work-value">${rhythmStats.avgWorkArrive || '--:--'}</span>
                      </div>
                      <div class="rhythm-work-stat">
                        <span class="rhythm-work-label">평균 퇴근</span>
                        <span class="rhythm-work-value">${rhythmStats.avgWorkDepart || '--:--'}</span>
                      </div>
                      <div class="rhythm-work-stat">
                        <span class="rhythm-work-label">평균 근무</span>
                        <span class="rhythm-work-value">${rhythmStats.avgWorkHours ? rhythmStats.avgWorkHours.toFixed(1) + 'h' : '--'}</span>
                      </div>
                      <div class="rhythm-work-stat">
                        <span class="rhythm-work-label">출근 편차</span>
                        <span class="rhythm-work-value ${rhythmStats.homeDepartDeviation <= 30 ? 'good' : ''}">${rhythmStats.homeDepartDeviation ? '±' + rhythmStats.homeDepartDeviation + '분' : '--'}</span>
                      </div>
                    </div>
                  </div>

                  <!-- 인사이트 -->
                  ${rhythmStats.insights.length > 0 ? `
                    <div class="rhythm-insights">
                      <div class="rhythm-chart-title">💡 인사이트</div>
                      ${rhythmStats.insights.map(insight => `
                        <div class="rhythm-insight-item ${insight.type}">
                          <span class="rhythm-insight-icon">${insight.icon}</span>
                          <span class="rhythm-insight-text">${insight.text}</span>
                        </div>
                      `).join('')}
                    </div>
                  ` : ''}

                  <!-- 복약 통계 (7일/30일) -->
                  ${(() => {
                    const medSlots = getMedicationSlots();
                    if (!medSlots || medSlots.length === 0) return '';

                    const today = new Date();
                    // 7일 / 30일 통계 함수
                    function calcMedStats(days) {
                      let tReq = 0, takenReq = 0, tOpt = 0, takenOpt = 0;
                      for (let i = 0; i < days; i++) {
                        const d = new Date(today);
                        d.setDate(today.getDate() - i);
                        const ds = getLocalDateStr(d);
                        let dayMeds;
                        if (i === 0 && appState.lifeRhythm.today.date === ds) {
                          dayMeds = appState.lifeRhythm.today.medications || {};
                        } else {
                          const hist = appState.lifeRhythm.history[ds];
                          dayMeds = hist ? (hist.medications || {}) : {};
                        }
                        medSlots.forEach(s => {
                          if (s.required) { tReq++; if (dayMeds[s.id]) takenReq++; }
                          else { tOpt++; if (dayMeds[s.id]) takenOpt++; }
                        });
                      }
                      return {
                        reqRate: tReq > 0 ? Math.round((takenReq / tReq) * 100) : 0,
                        optRate: tOpt > 0 ? Math.round((takenOpt / tOpt) * 100) : 0
                      };
                    }

                    const w7 = calcMedStats(7);
                    const w30 = calcMedStats(30);
                    const streak = getMedicationStreak();

                    return `
                      <div class="rhythm-work-section" style="margin-top: 16px;">
                        <div class="rhythm-chart-title">💊 복약 통계</div>
                        <div class="rhythm-work-stats">
                          <div class="rhythm-work-stat">
                            <span class="rhythm-work-label">필수 7일</span>
                            <span class="rhythm-work-value ${w7.reqRate >= 80 ? 'good' : ''}">${w7.reqRate}%</span>
                          </div>
                          <div class="rhythm-work-stat">
                            <span class="rhythm-work-label">필수 30일</span>
                            <span class="rhythm-work-value ${w30.reqRate >= 80 ? 'good' : ''}">${w30.reqRate}%</span>
                          </div>
                          <div class="rhythm-work-stat">
                            <span class="rhythm-work-label">선택 7일</span>
                            <span class="rhythm-work-value">${w7.optRate}%</span>
                          </div>
                          <div class="rhythm-work-stat">
                            <span class="rhythm-work-label">연속일</span>
                            <span class="rhythm-work-value ${streak >= 7 ? 'good' : ''}">${streak}일</span>
                          </div>
                        </div>
                      </div>
                    `;
                  })()}
                </div>
              `;
            })()}

            ${(() => {
              const report = getWeeklyReport();
              const now = new Date();
              const weekStart = new Date(now);
              weekStart.setDate(now.getDate() - now.getDay());
              const weekEnd = new Date(weekStart);
              weekEnd.setDate(weekStart.getDate() + 6);
              const formatDate = (d) => (d.getMonth() + 1) + '/' + d.getDate();

              return `
                <div class="dashboard-section weekly-report">
                  <div class="weekly-report-header">
                    <div class="weekly-report-title">📅 이번 주 요약</div>
                    <div class="weekly-report-period">${formatDate(weekStart)} - ${formatDate(weekEnd)}</div>
                  </div>
                  <div class="weekly-report-stats">
                    <div class="weekly-stat">
                      <div class="weekly-stat-value">${report.thisWeekCount}</div>
                      <div class="weekly-stat-label">완료한 작업</div>
                      ${report.change !== 0 ? `
                        <div class="weekly-stat-change ${report.change > 0 ? 'positive' : 'negative'}">
                          ${report.change > 0 ? '▲' : '▼'} ${Math.abs(report.change)} vs 지난주
                        </div>
                      ` : ''}
                    </div>
                    <div class="weekly-stat">
                      <div class="weekly-stat-value positive">${report.bestDay}요일</div>
                      <div class="weekly-stat-label">가장 생산적인 요일</div>
                      ${report.bestDayCount > 0 ? `
                        <div class="weekly-stat-change">${report.bestDayCount}개 완료</div>
                      ` : ''}
                    </div>
                    <div class="weekly-stat">
                      <div class="weekly-stat-value">${report.topCategory}</div>
                      <div class="weekly-stat-label">많이 한 카테고리</div>
                      ${report.topCategoryCount > 0 ? `
                        <div class="weekly-stat-change">${report.topCategoryCount}개</div>
                      ` : ''}
                    </div>
                    <div class="weekly-stat">
                      <div class="weekly-stat-value positive">🔥 ${report.streak}일</div>
                      <div class="weekly-stat-label">연속 달성 스트릭</div>
                    </div>
                  </div>
                </div>
              `;
            })()}

            ${(() => {
              const habitData = getHabitTrackerData();
              const dayLabels = ['일', '월', '화', '수', '목', '금', '토'];

              return `
                <div class="dashboard-section habit-tracker">
                  <div class="habit-tracker-title">🌱 습관 트래커 (최근 12주)</div>
                  <div class="habit-grid">
                    ${dayLabels.map((day, dayIdx) => `
                      <div class="habit-day-label">${day}</div>
                      ${habitData.map(week => {
                        const cell = week[dayIdx];
                        return `<div class="habit-cell ${cell.level > 0 ? 'level-' + cell.level : ''} ${cell.isToday ? 'today' : ''}"
                          title="${cell.date}: ${cell.count}개 완료"></div>`;
                      }).join('')}
                    `).join('')}
                  </div>
                  <div class="habit-legend">
                    <span>적음</span>
                    <div class="habit-legend-item"><div class="habit-legend-cell" style="background: var(--bg-tertiary)"></div></div>
                    <div class="habit-legend-item"><div class="habit-legend-cell level-1" style="background: rgba(72, 187, 120, 0.3)"></div></div>
                    <div class="habit-legend-item"><div class="habit-legend-cell level-2" style="background: rgba(72, 187, 120, 0.5)"></div></div>
                    <div class="habit-legend-item"><div class="habit-legend-cell level-3" style="background: rgba(72, 187, 120, 0.7)"></div></div>
                    <div class="habit-legend-item"><div class="habit-legend-cell level-4" style="background: #48bb78"></div></div>
                    <span>많음</span>
                  </div>
                </div>
              `;
            })()}

            <div class="dashboard-section">
              <div class="dashboard-title">📊 카테고리별 현황</div>
              <div class="category-stats">
                ${categoryStats.map(stat => `
                  <div class="category-stat">
                    <div class="category-stat-header">
                      <span class="category ${stat.category}">${stat.category}</span>
                      <span class="category-progress">${stat.completed}/${stat.total + stat.completed} 완료</span>
                    </div>
                    <div class="progress-bar">
                      <div class="progress-fill ${stat.category}" style="width: ${stat.percentage}%"></div>
                    </div>
                  </div>
                `).join('')}
              </div>
            </div>

            ${urgentTasks.length > 0 ? `
              <div class="dashboard-section">
                <div class="dashboard-title">🚨 마감 임박</div>
                <div class="urgent-list">
                  ${urgentTasks.slice(0, 5).map(task => `
                    <div class="urgent-item">
                      <div class="urgent-item-title">${escapeHtml(task.title)}</div>
                      <div class="urgent-item-time">⏰ ${formatDeadline(task.deadline)}</div>
                    </div>
                  `).join('')}
                </div>
              </div>
            ` : ''}

            ${(() => {
              const hourlyProd = getHourlyProductivity();
              const catDist = getCategoryDistribution();
              const dayProd = getDayOfWeekProductivity();

              if (hourlyProd.totalCompleted < 3) return '';

              // 시간대별 바 차트 데이터 (주요 시간대만)
              const timeSlots = [
                { label: '아침', count: hourlyProd.periods.morning.count },
                { label: '점심', count: hourlyProd.periods.lunch.count },
                { label: '오후', count: hourlyProd.periods.afternoon.count },
                { label: '저녁', count: hourlyProd.periods.evening.count },
                { label: '밤', count: hourlyProd.periods.night.count }
              ];
              const maxSlot = Math.max(...timeSlots.map(s => s.count), 1);

              // 파이 차트 그라디언트 계산
              const colors = {
                '본업': '#667eea',
                '부업': '#f093fb',
                '일상': '#4ecdc4',
                '가족': '#ffd93d',
                '기타': '#888'
              };
              let gradientParts = [];
              let currentDeg = 0;
              catDist.distribution.forEach(item => {
                const deg = (item.percentage / 100) * 360;
                const color = colors[item.category] || '#888';
                gradientParts.push(color + ' ' + currentDeg + 'deg ' + (currentDeg + deg) + 'deg');
                currentDeg += deg;
              });
              const pieGradient = gradientParts.length > 0
                ? 'conic-gradient(' + gradientParts.join(', ') + ')'
                : 'var(--bg-secondary)';

              // 시간대 바 HTML 생성
              const timeBarsHtml = timeSlots.map(slot =>
                '<div class="insight-bar ' + (slot.count === maxSlot ? 'peak' : '') + '" ' +
                'style="height: ' + Math.max((slot.count / maxSlot) * 100, 8) + '%" ' +
                'title="' + slot.label + ': ' + slot.count + '개"></div>'
              ).join('');

              const timeLabelsHtml = timeSlots.map(slot =>
                '<div class="insight-bar-label">' + slot.label + '</div>'
              ).join('');

              // 요일 바 HTML 생성
              const maxD = Math.max(...dayProd.data.map(x => x.count), 1);
              const dayBarsHtml = dayProd.data.map(d =>
                '<div class="insight-bar ' + (d.count === maxD && d.count > 0 ? 'peak' : '') + '" ' +
                'style="height: ' + Math.max((d.count / maxD) * 100, 8) + '%" ' +
                'title="' + d.name + ': ' + d.count + '개"></div>'
              ).join('');

              const dayLabelsHtml = dayProd.data.map(d =>
                '<div class="insight-bar-label">' + d.name + '</div>'
              ).join('');

              // 카테고리 레전드 HTML 생성
              const legendHtml = catDist.distribution.map(item =>
                '<div class="pie-legend-item">' +
                '<div class="pie-legend-color ' + item.category + '"></div>' +
                '<span>' + item.category + '</span>' +
                '<span class="pie-legend-value">' + item.count + '개 (' + item.percentage + '%)</span>' +
                '</div>'
              ).join('');

              return '<div class="dashboard-section insights-section">' +
                '<div class="insights-title">🔍 나의 생산성 패턴</div>' +

                '<div class="insight-card">' +
                '<div class="insight-header">' +
                '<span class="insight-label">가장 생산적인 시간대</span>' +
                '<span class="insight-value">' + hourlyProd.bestPeriod.name + '</span>' +
                '</div>' +
                '<div class="insight-bar-container">' + timeBarsHtml + '</div>' +
                '<div class="insight-bar-labels">' + timeLabelsHtml + '</div>' +
                '</div>' +

                '<div class="insight-card">' +
                '<div class="insight-header">' +
                '<span class="insight-label">가장 활발한 요일</span>' +
                '<span class="insight-value">' + dayProd.bestDay + '요일 (' + dayProd.bestDayCount + '개)</span>' +
                '</div>' +
                '<div class="insight-bar-container">' + dayBarsHtml + '</div>' +
                '<div class="insight-bar-labels">' + dayLabelsHtml + '</div>' +
                '</div>' +

                (catDist.total > 0 ?
                  '<div class="insight-card">' +
                  '<div class="insight-header">' +
                  '<span class="insight-label">카테고리 분배</span>' +
                  '<span class="insight-value">총 ' + catDist.total + '개 완료</span>' +
                  '</div>' +
                  '<div class="pie-chart-container">' +
                  '<div class="pie-chart" style="background: ' + pieGradient + '"></div>' +
                  '<div class="pie-legend">' + legendHtml + '</div>' +
                  '</div>' +
                  '</div>'
                : '') +

                '</div>';
            })()}

            <div class="dashboard-section">
              <div class="dashboard-title">📋 전체 작업 목록</div>
              ${appState.tasks.filter(t => !t.completed).length > 0 ? `
                <div class="task-list show">
                  ${appState.tasks.filter(t => !t.completed).map((task, index) => {
                    const urgency = getUrgencyLevel(task);
                    return `
                    <div
                      id="task-dash-${task.id}"
                      class="task-item ${urgency === 'urgent' ? 'urgent' : ''} ${urgency === 'warning' ? 'warning' : ''}"
                      style="--task-cat-color: var(--cat-${task.category})"
                    >
                      <div class="task-item-header">
                        <div class="task-item-title">${index + 1}. ${escapeHtml(task.title)}</div>
                      </div>
                      <div class="task-item-meta">
                        <span class="category ${task.category}">${task.category}</span>
                        ${task.estimatedTime ? ` · ${task.estimatedTime}분` : ''}
                        ${task.deadline ? ` · ${formatDeadline(task.deadline)}` : ''}
                      </div>
                      <div class="task-item-actions">
                        ${task.link ? `<button class="btn-small go" onclick="handleGo('${task.link}')">GO</button>` : ''}
                        <button class="btn-small complete" onclick="completeTask('${task.id}')" aria-label="작업 완료">✓</button>
                        <button class="btn-small edit" onclick="editTask('${task.id}')" aria-label="작업 수정">✏️</button>
                        <button class="btn-small copy" onclick="copyTask('${task.id}')">📋</button>
                        <button class="btn-small delete" onclick="deleteTask('${task.id}')" aria-label="작업 삭제">×</button>
                      </div>
                    </div>
                  `}).join('')}
                </div>
              ` : `
                <div class="empty-state">
                  <div class="empty-state-icon">✨</div>
                  <div>모든 작업 완료!</div>
                </div>
              `}
            </div>

            ${completedTasks.length > 0 ? `
              <div class="dashboard-section">
                <div class="dashboard-title">✅ 완료한 작업 (${completedTasks.length}개)</div>
                <div class="task-list show">
                  ${completedTasks.slice(0, 10).map((task, index) => `
                    <div class="task-item completed" style="--task-cat-color: var(--cat-${task.category})">
                      <div class="task-item-header">
                        <div class="task-item-title completed">${index + 1}. ${escapeHtml(task.title)}</div>
                      </div>
                      <div class="task-item-meta">
                        <span class="category ${task.category}">${task.category}</span>
                      </div>
                      <div class="task-item-actions">
                        <button class="btn-small uncomplete" onclick="uncompleteTask('${task.id}')" aria-label="완료 되돌리기">↩️</button>
                        <button class="btn-small delete" onclick="deleteTask('${task.id}')" aria-label="작업 삭제">×</button>
                      </div>
                    </div>
                  `).join('')}
                </div>
                ${completedTasks.length > 10 ? `
                  <div style="text-align: center; margin-top: 10px; color: var(--text-secondary); font-size: 14px;">
                    최근 10개만 표시 (전체 ${completedTasks.length}개)
                  </div>
                ` : ''}
              </div>
            ` : ''}

            ${(() => {
              // 주간/월간/90일 리포트 (completionLog 기반)
              const today = new Date();
              const todayStr = getLocalDateStr(today);
              const weekAgo = new Date(today); weekAgo.setDate(weekAgo.getDate() - 7);
              const weekAgoStr = getLocalDateStr(weekAgo);
              const monthAgo = new Date(today); monthAgo.setDate(monthAgo.getDate() - 30);
              const monthAgoStr = getLocalDateStr(monthAgo);
              const q90Ago = new Date(today); q90Ago.setDate(q90Ago.getDate() - 90);
              const q90AgoStr = getLocalDateStr(q90Ago);
              const tomorrowStr = getLocalDateStr(new Date(today.getTime() + 86400000));

              const weekEntries = getCompletionLogEntries(weekAgoStr, tomorrowStr);
              const monthEntries = getCompletionLogEntries(monthAgoStr, tomorrowStr);
              const q90Entries = getCompletionLogEntries(q90AgoStr, tomorrowStr);

              const weekRevenue = weekEntries.reduce((sum, e) => sum + (e.rv || 0), 0);
              const monthRevenue = monthEntries.reduce((sum, e) => sum + (e.rv || 0), 0);

              // 카테고리별 분포
              const weekCats = {};
              weekEntries.forEach(e => { weekCats[e.c || '기타'] = (weekCats[e.c || '기타'] || 0) + 1; });

              const formatKRW = (n) => n >= 10000 ? Math.round(n/10000) + '만원' : n.toLocaleString() + '원';

              // 월별 트렌드 (최근 3개월)
              const monthlyTrend = [];
              for (let m = 2; m >= 0; m--) {
                const mStart = new Date(today.getFullYear(), today.getMonth() - m, 1);
                const mEnd = new Date(today.getFullYear(), today.getMonth() - m + 1, 1);
                const mEntries = getCompletionLogEntries(getLocalDateStr(mStart), getLocalDateStr(mEnd));
                const mName = `${mStart.getMonth() + 1}월`;
                monthlyTrend.push({ name: mName, count: mEntries.length, revenue: mEntries.reduce((s, e) => s + (e.rv || 0), 0) });
              }
              const maxMonthCount = Math.max(...monthlyTrend.map(m => m.count), 1);

              return `
                <div class="dashboard-section">
                  <div class="dashboard-title">📋 주간/월간 리포트</div>
                  <div class="stats" style="margin-bottom: 12px;">
                    <div class="stat-card">
                      <div class="stat-value" style="color: #667eea">${weekEntries.length}</div>
                      <div class="stat-label">주간 완료</div>
                    </div>
                    <div class="stat-card">
                      <div class="stat-value" style="color: #48bb78">${monthEntries.length}</div>
                      <div class="stat-label">월간 완료</div>
                    </div>
                    <div class="stat-card">
                      <div class="stat-value" style="color: #f093fb">${weekRevenue > 0 ? formatKRW(weekRevenue) : '-'}</div>
                      <div class="stat-label">주간 수익</div>
                    </div>
                    <div class="stat-card">
                      <div class="stat-value" style="color: #f5576c">${monthRevenue > 0 ? formatKRW(monthRevenue) : '-'}</div>
                      <div class="stat-label">월간 수익</div>
                    </div>
                  </div>
                  ${Object.keys(weekCats).length > 0 ? `
                    <div style="font-size: 13px; color: var(--text-secondary); margin-top: 8px;">
                      <strong>주간 카테고리:</strong>
                      ${Object.entries(weekCats).map(([cat, cnt]) => `<span class="category ${cat}" style="margin-left:6px;">${cat} ${cnt}건</span>`).join('')}
                    </div>
                  ` : ''}
                  <div style="font-size: 12px; color: var(--text-muted); margin-top: 6px;">
                    일평균: ${(weekEntries.length / 7).toFixed(1)}건/일 (주간) · ${(monthEntries.length / 30).toFixed(1)}건/일 (월간)${q90Entries.length > 0 ? ` · ${(q90Entries.length / 90).toFixed(1)}건/일 (90일)` : ''}
                  </div>

                  <!-- 월별 트렌드 바 차트 -->
                  <div style="margin-top: 12px;">
                    <div style="font-size: 13px; font-weight: 600; margin-bottom: 8px;">📊 월별 완료 트렌드</div>
                    ${monthlyTrend.map(m => `
                      <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                        <span style="width: 30px; font-size: 12px; color: var(--text-secondary);">${m.name}</span>
                        <div style="flex: 1; height: 16px; background: var(--bg-tertiary); border-radius: 4px; overflow: hidden;">
                          <div style="width: ${Math.round((m.count / maxMonthCount) * 100)}%; height: 100%; background: linear-gradient(90deg, #667eea, #764ba2); border-radius: 4px; transition: width 0.3s;"></div>
                        </div>
                        <span style="width: 50px; font-size: 12px; text-align: right; color: var(--text-secondary);">${m.count}건</span>
                      </div>
                    `).join('')}
                  </div>
                </div>
              `;
            })()}
            ` : ''}
          </div>

          <!-- 전체 목록 탭 -->
          <div class="tab-content ${appState.currentTab === 'all' ? 'active' : ''}">
            ${appState.currentTab === 'all' ? `
            <div class="all-tasks-header">
              <h2>📋 전체 작업 목록</h2>
              <div class="all-tasks-summary">
                총 ${appState.tasks.length}개 · 진행 중 ${appState.tasks.filter(t => !t.completed).length}개 · 오늘 완료 ${getTodayCompletedTasks(appState.tasks).length}개
              </div>
            </div>

            ${['본업', '부업', '일상', '가족'].map(category => {
              const categoryTasks = appState.tasks.filter(t => t.category === category);
              const pendingTasks = categoryTasks.filter(t => !t.completed);
              // 모든 완료 태스크 표시 (오늘만 필터링하면 어제 완료 태스크가 사라짐)
              const completedTasks = categoryTasks.filter(t => t.completed);

              if (categoryTasks.length === 0) return '';

              return `
                <div class="all-category-section">
                  <div class="all-category-header ${category}">
                    <span class="all-category-title">${category}</span>
                    <span class="all-category-count">${pendingTasks.length}개 진행 중 / ${completedTasks.length}개 완료</span>
                  </div>

                  ${pendingTasks.length > 0 ? `
                    <div class="all-task-list">
                      ${pendingTasks.map(task => {
                        const urgency = getUrgencyLevel(task);
                        return `
                          <div class="all-task-item ${urgency === 'urgent' ? 'urgent' : ''} ${urgency === 'warning' ? 'warning' : ''}" style="--task-cat-color: var(--cat-${task.category})">
                            <div class="all-task-content">
                              <div class="all-task-title">${escapeHtml(task.title)}</div>
                              <div class="all-task-meta">
                                ${task.estimatedTime ? `⏱️ ${task.estimatedTime}분` : ''}
                                ${task.deadline ? ` · ${formatDeadline(task.deadline)}` : ''}
                                ${task.organizer ? ` · 👤 ${task.organizer}` : ''}
                                ${task.eventType ? ` · 🏷️ ${task.eventType}` : ''}
                              </div>
                            </div>
                            <div class="all-task-actions">
                              ${task.link ? `<button class="btn-small go" onclick="handleGo('${task.link}')">GO</button>` : ''}
                              <button class="btn-small complete" onclick="completeTask('${task.id}')" aria-label="작업 완료">✓</button>
                              <button class="btn-small edit" onclick="editTask('${task.id}')" aria-label="작업 수정">✏️</button>
                              <button class="btn-small copy" onclick="copyTask('${task.id}')">📋</button>
                              <button class="btn-small delete" onclick="deleteTask('${task.id}')" aria-label="작업 삭제">×</button>
                            </div>
                          </div>
                        `;
                      }).join('')}
                    </div>
                  ` : ''}

                  ${completedTasks.length > 0 ? `
                    <div class="all-completed-section">
                      <div class="all-completed-toggle" onclick="toggleCompletedCategory('${category}')">
                        ✅ 완료 (${completedTasks.length}개) ${appState.showCompletedByCategory && appState.showCompletedByCategory[category] ? '▲' : '▼'}
                      </div>
                      <div class="all-task-list completed-list ${appState.showCompletedByCategory && appState.showCompletedByCategory[category] ? 'show' : ''}">
                        ${completedTasks.slice(0, 5).map(task => `
                          <div class="all-task-item completed" style="--task-cat-color: var(--cat-${task.category})">
                            <div class="all-task-content">
                              <div class="all-task-title completed">${escapeHtml(task.title)}</div>
                            </div>
                            <div class="all-task-actions">
                              <button class="btn-small uncomplete" onclick="uncompleteTask('${task.id}')" aria-label="완료 되돌리기">↩️</button>
                              <button class="btn-small delete" onclick="deleteTask('${task.id}')" aria-label="작업 삭제">×</button>
                            </div>
                          </div>
                        `).join('')}
                        ${completedTasks.length > 5 ? `
                          <div class="all-task-more">+${completedTasks.length - 5}개 더</div>
                        ` : ''}
                      </div>
                    </div>
                  ` : ''}
                </div>
              `;
            }).join('')}

            ${appState.tasks.length === 0 ? `
              <div class="empty-state">
                <div class="empty-state-icon">📝</div>
                <div>등록된 작업이 없습니다</div>
                <div style="margin-top: 10px; font-size: 14px; color: var(--text-secondary);">
                  🎯 오늘 탭에서 새 작업을 추가해보세요
                </div>
              </div>
            ` : ''}
            ` : ''}
          </div>

          <!-- 히스토리 탭 -->
          <div class="tab-content ${appState.currentTab === 'history' ? 'active' : ''}">
            ${appState.currentTab === 'history' ? (() => {
              const weeklyStats = getWeeklyStats();
              const totalCompleted = appState.tasks.filter(t => t.completed).length;

              return `
                <div class="history-header">
                  <h2>📅 활동 히스토리</h2>
                  <div class="history-summary">총 ${totalCompleted}개 완료</div>
                </div>

                <!-- 뷰 전환 탭 -->
                <div class="history-view-tabs">
                  <button class="history-view-tab ${appState.historyView !== 'rhythm' ? 'active' : ''}" onclick="setHistoryView('tasks')">
                    📋 작업 기록
                  </button>
                  <button class="history-view-tab ${appState.historyView === 'rhythm' ? 'active' : ''}" onclick="setHistoryView('rhythm')">
                    😴 라이프 리듬
                  </button>
                </div>

                ${appState.historyView === 'rhythm' ? renderLifeRhythmHistory() : `
                <!-- 주간 요약 -->
                <div class="week-summary">
                  <div class="week-summary-title">📊 이번 주 요약</div>
                  <div class="week-summary-stats">
                    <div class="week-stat">
                      <div class="week-stat-value">${weeklyStats.total}</div>
                      <div class="week-stat-label">완료</div>
                    </div>
                    <div class="week-stat">
                      <div class="week-stat-value">${weeklyStats.avgPerDay}</div>
                      <div class="week-stat-label">일 평균</div>
                    </div>
                    <div class="week-stat">
                      <div class="week-stat-value">${weeklyStats.activeDays}/7</div>
                      <div class="week-stat-label">활동일</div>
                    </div>
                  </div>

                  <!-- 주간 바 차트 -->
                  ${(() => {
                    const dayLabels = ['일', '월', '화', '수', '목', '금', '토'];
                    const todayIndex = new Date().getDay();
                    const maxCount = Math.max(...weeklyStats.dailyCounts, 1);

                    return `
                      <div class="weekly-chart">
                        ${weeklyStats.dailyCounts.map((count, i) => {
                          const height = (count / maxCount) * 80;
                          const isToday = i === todayIndex;
                          return `
                            <div class="weekly-chart-bar">
                              <div class="weekly-chart-value">${count > 0 ? count : ''}</div>
                              <div class="weekly-chart-fill ${isToday ? 'today' : ''} ${count === 0 ? 'empty' : ''}" style="height: ${height}px"></div>
                              <div class="weekly-chart-label ${isToday ? 'today' : ''}">${dayLabels[i]}</div>
                            </div>
                          `;
                        }).join('')}
                      </div>
                    `;
                  })()}
                </div>

                <!-- 캘린더 -->
                ${renderCalendar()}

                <!-- 선택된 날짜 상세 -->
                ${renderDayDetail()}

                <!-- 최근 기록 -->
                <div class="dashboard-section">
                  <div class="dashboard-title">📜 최근 기록</div>
                  ${renderRecentHistory()}
                </div>
                `}
              `;
            })() : ''}
          </div>

          <!-- 온보딩 모달 -->
          ${appState.showOnboarding ? `
            <div class="modal-overlay" onclick="completeOnboarding(false)">
              <div class="modal onboarding-modal" onclick="event.stopPropagation()">
                <div class="modal-header">
                  <h2>👋 Navigator에 오신 것을 환영합니다!</h2>
                </div>
                <div class="modal-body">
                  <div class="onboarding-feature">
                    <span class="onboarding-icon">🎯</span>
                    <div>
                      <strong>자동 우선순위</strong>
                      <p>마감일, 카테고리를 기반으로 가장 중요한 작업을 자동 정렬</p>
                    </div>
                  </div>
                  <div class="onboarding-feature">
                    <span class="onboarding-icon">🏷️</span>
                    <div>
                      <strong>태그 & 서브태스크</strong>
                      <p>유연한 분류와 큰 작업의 단계별 분해</p>
                    </div>
                  </div>
                  <div class="onboarding-feature">
                    <span class="onboarding-icon">🔥</span>
                    <div>
                      <strong>연속 달성 스트릭</strong>
                      <p>매일 작업 완료 시 스트릭 증가! 동기부여 UP</p>
                    </div>
                  </div>
                  <div class="onboarding-feature">
                    <span class="onboarding-icon">🎯</span>
                    <div>
                      <strong>포커스 모드</strong>
                      <p>ADHD 친화적! 가장 중요한 작업 1개만 표시</p>
                    </div>
                  </div>
                </div>
                <div class="modal-footer">
                  <button class="btn btn-primary" onclick="completeOnboarding(true)">
                    🚀 샘플 작업으로 시작하기
                  </button>
                  <button class="btn btn-secondary" onclick="completeOnboarding(false)">
                    빈 상태로 시작하기
                  </button>
                </div>
              </div>
            </div>
          ` : ''}

          <!-- 설정 모달 -->
          ${appState.showSettings ? `
            <div class="modal-overlay" onclick="closeSettings()">
              <div class="modal settings-modal" onclick="event.stopPropagation()">
                <div class="modal-header">
                  <h2>⚙️ 설정</h2>
                </div>
                <div class="modal-body">
                  <!-- 클라우드 동기화 섹션 -->
                  <div class="settings-section">
                    <div class="settings-section-title">☁️ 클라우드 동기화</div>
                    ${appState.user ? `
                      <div class="user-section">
                        <img class="user-avatar" src="${appState.user.photoURL || 'data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><rect fill=%22%23667eea%22 width=%22100%22 height=%22100%22 rx=%2250%22/><text x=%2250%22 y=%2265%22 font-size=%2250%22 text-anchor=%22middle%22 fill=%22white%22>👤</text></svg>'}" alt="프로필">
                        <div class="user-info">
                          <div class="user-name">${appState.user.displayName || '사용자'}</div>
                          <div class="user-email">${appState.user.email}</div>
                          <div id="sync-indicator" class="sync-status ${appState.syncStatus}">
                            <span class="sync-icon">${appState.syncStatus === 'syncing' ? '🔄' : appState.syncStatus === 'synced' ? '✅' : appState.syncStatus === 'error' ? '⚠️' : '☁️'}</span>
                            ${appState.syncStatus === 'syncing' ? '동기화 중...' : appState.syncStatus === 'synced' ? '동기화됨' : appState.syncStatus === 'error' ? '동기화 오류' : '대기 중'}
                          </div>
                        </div>
                        <button class="logout-btn" onclick="logout()">로그아웃</button>
                      </div>
                      <div style="display: flex; gap: 8px; margin-top: 8px;">
                        <button onclick="forceSync()" style="flex: 1; padding: 10px; background: var(--primary); color: white; border: none; border-radius: 8px; font-size: 13px; cursor: pointer; font-weight: 500;">
                          🔄 동기화 갱신
                        </button>
                      </div>
                      <div style="font-size: 12px; color: var(--text-secondary); text-align: center; margin-top: 8px;">
                        다른 기기에서 같은 계정으로 로그인하면 자동 동기화됩니다
                      </div>
                    ` : `
                      <div style="text-align: center; padding: 10px 0;">
                        <p style="font-size: 13px; color: var(--text-secondary); margin-bottom: 15px;">
                          Google 계정으로 로그인하면<br>여러 기기에서 동기화할 수 있어요
                        </p>
                        <button class="login-btn" onclick="loginWithGoogle()">
                          <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" alt="Google">
                          Google로 로그인
                        </button>
                      </div>
                    `}
                  </div>

                  <div class="settings-section">
                    <div class="settings-section-title">⏰ 시간 설정</div>

                    <div class="settings-row">
                      <div class="settings-label">
                        <span class="settings-label-icon">🌅</span>
                        <div class="settings-label-text">
                          <span class="settings-label-title">목표 기상 시간</span>
                          <span class="settings-label-desc">출근 준비 시작 시간</span>
                        </div>
                      </div>
                      <input
                        type="time"
                        class="settings-input"
                        value="${appState.settings.targetWakeTime || '07:00'}"
                        onchange="updateSetting('targetWakeTime', this.value)"
                      >
                    </div>

                    <div class="settings-row">
                      <div class="settings-label">
                        <span class="settings-label-icon">🔄</span>
                        <div class="settings-label-text">
                          <span class="settings-label-title">하루 시작 시각</span>
                          <span class="settings-label-desc">이 시각 이후 반복 태스크 리셋</span>
                        </div>
                      </div>
                      <select
                        class="settings-input"
                        value="${appState.settings.dayStartHour || 5}"
                        onchange="updateSetting('dayStartHour', parseInt(this.value))"
                      >
                        <option value="3" ${appState.settings.dayStartHour === 3 ? 'selected' : ''}>03:00</option>
                        <option value="4" ${appState.settings.dayStartHour === 4 ? 'selected' : ''}>04:00</option>
                        <option value="5" ${(appState.settings.dayStartHour || 5) === 5 ? 'selected' : ''}>05:00</option>
                        <option value="6" ${appState.settings.dayStartHour === 6 ? 'selected' : ''}>06:00</option>
                        <option value="7" ${appState.settings.dayStartHour === 7 ? 'selected' : ''}>07:00</option>
                      </select>
                    </div>

                    <div class="settings-row">
                      <div class="settings-label">
                        <span class="settings-label-icon">🏢</span>
                        <div class="settings-label-text">
                          <span class="settings-label-title">출근 시간</span>
                          <span class="settings-label-desc">회사 모드 시작</span>
                        </div>
                      </div>
                      <input
                        type="time"
                        class="settings-input"
                        value="${appState.settings.workStartTime || '11:00'}"
                        onchange="updateSetting('workStartTime', this.value)"
                      >
                    </div>

                    <div class="settings-row">
                      <div class="settings-label">
                        <span class="settings-label-icon">🚶</span>
                        <div class="settings-label-text">
                          <span class="settings-label-title">퇴근 시간</span>
                          <span class="settings-label-desc">회사 모드 종료</span>
                        </div>
                      </div>
                      <input
                        type="time"
                        class="settings-input"
                        value="${appState.settings.workEndTime || '20:00'}"
                        onchange="updateSetting('workEndTime', this.value)"
                      >
                    </div>

                    <div class="settings-row">
                      <div class="settings-label">
                        <span class="settings-label-icon">🌙</span>
                        <div class="settings-label-text">
                          <span class="settings-label-title">목표 취침 시간</span>
                          <span class="settings-label-desc">이 시간 전에 잠자리에</span>
                        </div>
                      </div>
                      <input
                        type="time"
                        class="settings-input"
                        value="${appState.settings.targetBedtime || '23:00'}"
                        onchange="updateSetting('targetBedtime', this.value)"
                      >
                    </div>

                    <!-- 타임라인 미리보기 -->
                    <div class="settings-time-preview">
                      <div class="settings-time-preview-title">📅 하루 일정 미리보기</div>
                      <div class="settings-time-preview-timeline">
                        <div class="timeline-item">
                          <span class="timeline-icon">🌅</span>
                          <span class="timeline-time">${appState.settings.targetWakeTime || '07:00'}</span>
                        </div>
                        <span class="timeline-arrow">→</span>
                        <div class="timeline-item">
                          <span class="timeline-icon">🏢</span>
                          <span class="timeline-time">${appState.settings.workStartTime || '11:00'}</span>
                        </div>
                        <span class="timeline-arrow">→</span>
                        <div class="timeline-item">
                          <span class="timeline-icon">🚶</span>
                          <span class="timeline-time">${appState.settings.workEndTime || '20:00'}</span>
                        </div>
                        <span class="timeline-arrow">→</span>
                        <div class="timeline-item">
                          <span class="timeline-icon">🌙</span>
                          <span class="timeline-time">${appState.settings.targetBedtime || '23:00'}</span>
                        </div>
                      </div>
                    </div>
                  </div>

                  <div class="settings-section">
                    <div class="settings-section-title">💊 복약/영양제 설정</div>

                    <div style="margin-bottom: 12px;">
                      ${(() => {
                        const medSlots = getMedicationSlots();
                        return medSlots.map((slot, idx) => `
                          <div class="settings-row" style="padding: 10px 0; border-bottom: 1px solid var(--border-color);">
                            <div style="display: flex; align-items: center; gap: 8px; flex: 1;">
                              <span style="font-size: 18px;">${slot.icon}</span>
                              <div style="flex: 1;">
                                <div style="font-size: 14px; font-weight: 500;">${escapeHtml(slot.label)}</div>
                                <div style="font-size: 11px; color: var(--text-muted);">${slot.required ? '필수' : '선택'}</div>
                              </div>
                            </div>
                            <div style="display: flex; gap: 4px;">
                              <button class="btn btn-secondary" style="font-size: 11px; padding: 4px 8px;"
                                      onclick="editMedicationSlot(${idx})" aria-label="${escapeHtml(slot.label)} 편집">✏️</button>
                              <button class="btn btn-secondary" style="font-size: 11px; padding: 4px 8px; color: var(--danger);"
                                      onclick="deleteMedicationSlot(${idx})" aria-label="${escapeHtml(slot.label)} 삭제">🗑️</button>
                            </div>
                          </div>
                        `).join('');
                      })()}
                    </div>

                    <button class="btn btn-secondary" style="width: 100%; font-size: 13px;"
                            onclick="addMedicationSlot()" aria-label="복약 슬롯 추가">
                      ➕ 복약 슬롯 추가
                    </button>
                  </div>

                  <div class="settings-section">
                    <div class="settings-section-title">🎯 목표 설정</div>

                    <div class="settings-row">
                      <div class="settings-label">
                        <span class="settings-label-icon">📅</span>
                        <div class="settings-label-text">
                          <span class="settings-label-title">일일 목표</span>
                          <span class="settings-label-desc">하루에 완료할 작업 수</span>
                        </div>
                      </div>
                      <input
                        type="number"
                        class="settings-input-number"
                        min="1"
                        max="20"
                        value="${appState.settings.dailyGoal}"
                        onchange="updateSetting('dailyGoal', parseInt(this.value) || 5)"
                      >
                    </div>

                    <div class="settings-row">
                      <div class="settings-label">
                        <span class="settings-label-icon">📆</span>
                        <div class="settings-label-text">
                          <span class="settings-label-title">주간 목표</span>
                          <span class="settings-label-desc">일주일에 완료할 작업 수</span>
                        </div>
                      </div>
                      <input
                        type="number"
                        class="settings-input-number"
                        min="1"
                        max="100"
                        value="${appState.settings.weeklyGoal}"
                        onchange="updateSetting('weeklyGoal', parseInt(this.value) || 25)"
                      >
                    </div>
                  </div>

                  <div class="settings-section">
                    <div class="settings-section-title">🔔 알림 설정</div>

                    <div class="settings-row">
                      <div class="settings-label">
                        <span class="settings-label-icon">🌙</span>
                        <div class="settings-label-text">
                          <span class="settings-label-title">취침 알림</span>
                          <span class="settings-label-desc">취침 시간 전 알림 받기</span>
                        </div>
                      </div>
                      <button
                        class="btn-small ${appState.settings.bedtimeReminder ? 'complete' : ''}"
                        onclick="updateSetting('bedtimeReminder', !appState.settings.bedtimeReminder); renderStatic();"
                        style="min-width: 60px;"
                      >
                        ${appState.settings.bedtimeReminder ? 'ON' : 'OFF'}
                      </button>
                    </div>

                    ${appState.settings.bedtimeReminder ? `
                      <div class="settings-row">
                        <div class="settings-label">
                          <span class="settings-label-icon">⏰</span>
                          <div class="settings-label-text">
                            <span class="settings-label-title">알림 시간</span>
                            <span class="settings-label-desc">취침 몇 분 전에 알림</span>
                          </div>
                        </div>
                        <select
                          class="settings-input"
                          style="width: 100px;"
                          onchange="updateSetting('bedtimeReminderMinutes', parseInt(this.value))"
                        >
                          <option value="15" ${appState.settings.bedtimeReminderMinutes === 15 ? 'selected' : ''}>15분 전</option>
                          <option value="30" ${appState.settings.bedtimeReminderMinutes === 30 ? 'selected' : ''}>30분 전</option>
                          <option value="60" ${appState.settings.bedtimeReminderMinutes === 60 ? 'selected' : ''}>1시간 전</option>
                        </select>
                      </div>
                    ` : ''}
                  </div>

                  <div class="settings-section">
                    <div class="settings-section-title">💾 데이터 백업</div>
                    <div class="settings-row" style="justify-content: center; gap: 12px;">
                      <button class="backup-btn export" onclick="exportData()" style="flex: 1;">
                        📤 내보내기
                      </button>
                      <button class="backup-btn import" onclick="importData()" style="flex: 1;">
                        📥 가져오기
                      </button>
                    </div>
                    <div class="settings-label-desc" style="text-align: center; margin-top: 8px; opacity: 0.6;">
                      주기적으로 백업하여 데이터를 안전하게 보관하세요
                    </div>
                    <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(255,255,255,0.1);">
                      <button class="backup-btn" onclick="restoreFromSyncBackup()" style="width: 100%; background: #f5576c22; border-color: #f5576c; color: #f5576c;" aria-label="동기화 백업에서 데이터 복원">
                        🔄 동기화 백업에서 복원
                      </button>
                      <div class="settings-label-desc" style="text-align: center; margin-top: 6px; opacity: 0.5; font-size: 11px;">
                        동기화 중 데이터가 유실된 경우 직전 상태로 복원
                      </div>
                    </div>
                  </div>
                </div>
                <div class="modal-footer" style="display: flex; gap: 10px; justify-content: center;">
                  <button class="btn btn-secondary" onclick="closeSettings(); startFeatureTour();">
                    📖 기능 가이드
                  </button>
                  <button class="btn btn-primary" onclick="closeSettings()">
                    ✓ 완료
                  </button>
                </div>
              </div>
            </div>
          ` : ''}
        </div>
      `;

      // 입력 이벤트 핸들러 등록
      setupInputHandlers();
    }

    /**
     * 입력 필드 이벤트 핸들러 등록
     */
    function setupInputHandlers() {
      const quickInput = document.getElementById('quick-add-input');
      if (quickInput) {
        quickInput.oninput = (e) => {
          appState.quickAddValue = e.target.value;
        };
      }

      if (appState.showDetailedAdd) {
        const inputs = {
          title: document.getElementById('detailed-title'),
          description: document.getElementById('detailed-description'),
          startDate: document.getElementById('detailed-startDate'),
          deadline: document.getElementById('detailed-deadline'),
          time: document.getElementById('detailed-time'),
          revenue: document.getElementById('detailed-revenue'),
          link: document.getElementById('detailed-link'),
          organizer: document.getElementById('detailed-organizer'),
          eventType: document.getElementById('detailed-eventType')
        };

        if (inputs.title) inputs.title.oninput = (e) => appState.detailedTask.title = e.target.value;
        if (inputs.description) inputs.description.oninput = (e) => appState.detailedTask.description = e.target.value;
        if (inputs.startDate) inputs.startDate.onchange = (e) => appState.detailedTask.startDate = e.target.value;
        if (inputs.deadline) inputs.deadline.onchange = (e) => appState.detailedTask.deadline = e.target.value;
        if (inputs.time) inputs.time.oninput = (e) => appState.detailedTask.estimatedTime = parseInt(e.target.value) || 0;
        if (inputs.revenue) inputs.revenue.oninput = (e) => appState.detailedTask.expectedRevenue = e.target.value;
        if (inputs.link) inputs.link.oninput = (e) => appState.detailedTask.link = e.target.value;
        if (inputs.organizer) inputs.organizer.onchange = (e) => appState.detailedTask.organizer = e.target.value;
        if (inputs.eventType) inputs.eventType.onchange = (e) => appState.detailedTask.eventType = e.target.value;

        // 새 태그 입력 핸들러
        const tagInput = document.getElementById('new-tag-input');
        if (tagInput) {
          tagInput.onkeypress = (e) => {
            if (e.key === 'Enter') {
              e.preventDefault();
              addNewTag(e.target.value);
              e.target.value = '';
            }
          };
        }

        // 서브태스크 입력 핸들러
        const subtaskInput = document.getElementById('new-subtask-input');
        if (subtaskInput) {
          subtaskInput.onkeypress = (e) => {
            if (e.key === 'Enter') {
              e.preventDefault();
              addSubtask(e.target.value);
              e.target.value = '';
            }
          };
        }
      }

      // 파일 임포트 핸들러
      const fileInput = document.getElementById('file-import');
      if (fileInput) {
        fileInput.onchange = handleFileImport;
      }
    }

    /**
     * 시간만 업데이트 (1초마다)
     */
    function updateTime() {
      const now = new Date();
      const hour = now.getHours();
      const bedtime = new Date(now);
      bedtime.setHours(24, 0, 0, 0);
      const minutesUntilBed = Math.floor((bedtime - now) / (1000 * 60));

      const timeEl = document.getElementById('time-value');
      if (timeEl) {
        timeEl.textContent = `${Math.floor(minutesUntilBed / 60)}시간 ${minutesUntilBed % 60}분`;
      }

      // 현재 시간 시계 업데이트
      const clockEl = document.getElementById('current-clock');
      if (clockEl) {
        clockEl.textContent = now.toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' });
      }

      // 모드 남은 시간 업데이트
      const modeTimeEl = document.getElementById('mode-time-remaining');
      if (modeTimeEl) {
        const mode = getCurrentMode();
        modeTimeEl.textContent = getModeTimeRemaining(mode, hour, now);
      }
    }

    // ============================================
    // 전역 함수 등록 (Nav 네임스페이스 + window 호환)
    // ============================================
    const _navFunctions = {
      // 탭/네비게이션
      switchTab, addNewEvent, toggleShuttle,
      // 작업 CRUD
      quickAdd, detailedAdd, showBrainDumpModal, processBrainDump, completeTask, uncompleteTask, editTask, cancelEdit, deleteTask,
      // 이벤트 일괄 선택
      toggleEventBulkSelect, toggleEventSelection, toggleEventSelectAll, bulkDeleteEvents, toggleEventGroup,
      toggleEventGroupSelect, restoreFromTrash, permanentDeleteFromTrash, emptyTrash,
      handleGo, toggleTaskList, toggleCompletedTasks, toggleDetailedAdd,
      updateDetailedTaskCategory, updateDetailedTaskRepeat,
      // 터치/스와이프
      handleTouchStart, handleTouchMove, handleTouchEnd,
      // 백업/데이터
      exportData, importData,
      // 유틸
      getRepeatLabel, setScheduleFilter, getTasksByDate, formatTime,
      setSearchQuery, clearSearch, setCategoryFilter,
      // 서브태스크
      toggleSubtaskComplete, toggleSubtaskExpand, toggleDetailedSubtask, addSubtask, removeSubtask,
      // 주간 리뷰
      showWeeklyReview, closeWeeklyReview,
      // 포커스/단축키
      toggleFocusTask, saveWeeklyPlan, dismissMondayReminder,
      setQuickFilter, postponeTask,
      showTimeInputModal, saveActualTime, closeTimeInputModal,
      // 히스토리/캘린더
      prevMonth, nextMonth, selectDate, toggleHistoryDate,
      // 통근 트래커
      setCommuteSubTab, openCommuteRouteModal, closeCommuteRouteModal,
      saveCommuteRoute, deleteCommuteRoute, selectCommuteRoute,
      tagCommuteRoute, dismissCommuteTag, setCommuteCondition,
      // 설정
      openSettings, closeSettings, updateSetting,
      // 리듬 통계
      toggleRhythmStats,
      // 템플릿
      saveAsTemplate, deleteTemplate, addFromTemplate, saveCurrentAsTemplate,
    };
    // 네임스페이스 객체
    window.Nav = _navFunctions;
    // HTML onclick 호환용 전역 등록
    Object.assign(window, _navFunctions);

    // UX 함수
    function dismissSwipeHint() {
      localStorage.setItem('navigator-hide-swipe-hint', 'true');
      renderStatic();
    }
    window.dismissSwipeHint = dismissSwipeHint;

    // 기능 투어
    const tourSteps = [
      { selector: '.quick-add-container', title: '⚡ 빠른 추가', desc: '여기에 작업명을 입력하고 Enter! #부업 처럼 카테고리도 지정 가능합니다.' },
      { selector: '.tab-nav', title: '📋 탭 네비게이션', desc: '오늘/본업/이벤트/일상 탭으로 전환. 더보기에서 통계/전체/히스토리도 볼 수 있습니다.' },
      { selector: '.header', title: '⚙️ 헤더 버튼', desc: '셔틀 상태, 테마 전환, 동기화 상태, 마감 알림, 설정을 빠르게 접근합니다.' },
      { selector: '.quick-filter-section, .quick-templates', title: '🎯 빠른 필터 & 템플릿', desc: '소요시간/마감 필터로 작업을 걸러보고, 글쓰기/상세 추가로 빠르게 작업을 만드세요.' },
    ];
    let tourIdx = -1;

    function startFeatureTour() {
      tourIdx = 0;
      showTourStep();
    }
    function showTourStep() {
      // 이전 정리
      document.querySelectorAll('.tour-overlay, .tour-tooltip').forEach(el => el.remove());
      document.querySelectorAll('.tour-highlight').forEach(el => el.classList.remove('tour-highlight'));
      if (tourIdx >= tourSteps.length) { tourIdx = -1; return; }

      const step = tourSteps[tourIdx];
      const target = document.querySelector(step.selector);

      // 오버레이
      const overlay = document.createElement('div');
      overlay.className = 'tour-overlay';
      overlay.onclick = () => endTour();
      document.body.appendChild(overlay);

      // 하이라이트
      if (target) {
        target.classList.add('tour-highlight');
        target.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }

      // 툴팁
      const tooltip = document.createElement('div');
      tooltip.className = 'tour-tooltip';
      tooltip.onclick = (e) => e.stopPropagation();
      tooltip.innerHTML = `
        <h4>${step.title}</h4>
        <p>${step.desc}</p>
        <div class="tour-actions">
          <span class="tour-step">${tourIdx + 1} / ${tourSteps.length}</span>
          <div style="display:flex;gap:8px;">
            <button class="btn btn-secondary btn-small" onclick="endTour()" style="min-height:36px;">건너뛰기</button>
            <button class="btn btn-primary btn-small" onclick="nextTourStep()" style="min-height:36px;">${tourIdx < tourSteps.length - 1 ? '다음 →' : '완료 ✓'}</button>
          </div>
        </div>
      `;
      document.body.appendChild(tooltip);

      // 위치 조정
      if (target) {
        const rect = target.getBoundingClientRect();
        const tooltipRect = tooltip.getBoundingClientRect();
        let top = rect.bottom + 12;
        let left = Math.max(16, rect.left);
        if (top + tooltipRect.height > window.innerHeight) top = rect.top - tooltipRect.height - 12;
        if (left + tooltipRect.width > window.innerWidth) left = window.innerWidth - tooltipRect.width - 16;
        tooltip.style.top = top + 'px';
        tooltip.style.left = left + 'px';
      } else {
        tooltip.style.top = '50%';
        tooltip.style.left = '50%';
        tooltip.style.transform = 'translate(-50%, -50%)';
      }
    }
    function nextTourStep() { tourIdx++; showTourStep(); }
    function endTour() {
      document.querySelectorAll('.tour-overlay, .tour-tooltip').forEach(el => el.remove());
      document.querySelectorAll('.tour-highlight').forEach(el => el.classList.remove('tour-highlight'));
      tourIdx = -1;
    }
    window.startFeatureTour = startFeatureTour;
    window.nextTourStep = nextTourStep;
    window.endTour = endTour;

    // ============================================
    // 본업 프로젝트 관리
    // ============================================

    // 모달 상태
    let workModalState = {
      type: null, // 'project', 'subcategory', 'task', 'log'
      projectId: null,
      stageIdx: null,
      subcategoryIdx: null,
      taskIdx: null
    };

    // 상태 목록
    const WORK_STATUS = {
      'not-started': { label: '미시작', color: '#a0a0a0' },
      'in-progress': { label: '진행중', color: '#667eea' },
      'completed': { label: '완료', color: '#48bb78' },
      'blocked': { label: '보류', color: '#f5576c' }
    };

    /**
     * 프로젝트 목록 렌더링
     */
    function renderWorkProjects() {
      // 프로젝트 완료 여부 판단 헬퍼
      const isProjectCompleted = (p) => {
        if (p.stages.length === 0) return false;
        return p.stages.every(s => s.completed);
      };

      const activeProjects = appState.workProjects.filter(p => !p.archived);
      const archivedProjects = appState.workProjects.filter(p => p.archived);

      // 최근 활동순 정렬 헬퍼
      const sortByRecent = (projects) => {
        return [...projects].sort((a, b) => {
          const aDate = new Date(a.updatedAt || a.createdAt || 0);
          const bDate = new Date(b.updatedAt || b.createdAt || 0);
          return bDate - aDate; // 최신순
        });
      };

      // 보류 프로젝트 분리
      const onHoldProjects = sortByRecent(activeProjects.filter(p => p.onHold));

      // 활성 프로젝트를 3가지로 분류 (최근 활동순 정렬, 보류 제외)
      const inProgressProjects = sortByRecent(activeProjects.filter(p => !p.onHold && p.deadline && !isProjectCompleted(p)));
      const completedProjects = sortByRecent(activeProjects.filter(p => !p.onHold && isProjectCompleted(p)));
      const noDeadlineProjects = sortByRecent(activeProjects.filter(p => !p.onHold && !p.deadline && !isProjectCompleted(p)));

      if (appState.workProjects.length === 0) {
        return `
          <div class="work-projects-container">
            <div class="work-projects-header">
              <div class="work-projects-title">💼 본업 프로젝트</div>
            </div>
            <div class="work-empty">
              <div class="work-empty-icon">📋</div>
              <div class="work-empty-title">프로젝트가 없습니다</div>
              <div class="work-empty-desc">새 프로젝트를 추가하여 업무를 체계적으로 관리하세요</div>
              <button class="work-project-add-btn" onclick="showWorkModal('project')">+ 첫 프로젝트 만들기</button>
            </div>
          </div>
        `;
      }

      const activeProject = appState.workProjects.find(p => p.id === appState.activeWorkProject);

      // 본업 일반 작업 (프로젝트 미연결)
      const workGeneralTasks = appState.tasks.filter(t => t.category === '본업' && !t.workProjectId && !t.completed);

      return `
        <div class="work-projects-container">
          <!-- 헤더 -->
          <div class="work-projects-header">
            <div class="work-projects-title">💼 본업</div>
            <div style="display: flex; gap: 8px;">
              <button class="work-project-add-btn" onclick="showWorkModal('project')">+ 새 프로젝트</button>
              <button class="work-project-action-btn" onclick="showWorkModal('template-select')">📋 템플릿</button>
              <button class="work-project-action-btn" onclick="showWorkModal('template-import')">📥 가져오기</button>
            </div>
          </div>

          <!-- 본업 빠른 추가 (프로젝트 없이) -->
          <div class="work-quick-add">
            <input
              type="text"
              class="work-quick-input"
              placeholder="프로젝트 없이 본업 작업 추가 (Enter)"
              id="work-quick-input"
              onkeypress="if(event.key==='Enter') quickAddWorkTask()"
            >
            <button class="work-quick-btn" onclick="quickAddWorkTask()">+</button>
          </div>

          ${workGeneralTasks.length > 0 ? `
            <div class="work-general-tasks">
              <div class="work-general-title">📋 일반 작업 (${workGeneralTasks.length})</div>
              <div class="work-general-list">
                ${workGeneralTasks.slice(0, 5).map(task => `
                  <div class="work-general-item-wrapper">
                    <div class="work-general-item">
                      <button class="task-check-btn" onclick="completeTask('${task.id}')" aria-label="작업 완료">○</button>
                      <span class="work-general-item-title" onclick="editTask('${task.id}')">${escapeHtml(task.title)}</span>
                      ${task.subtasks && task.subtasks.length > 0 ? `
                        <span class="subtask-badge" onclick="event.stopPropagation(); toggleWorkGeneralSubtask('${task.id}')">
                          📋${task.subtasks.filter(s => s.completed).length}/${task.subtasks.length}
                        </span>
                      ` : ''}
                      <button class="work-general-delete-btn" onclick="deleteTask('${task.id}')" title="삭제" aria-label="작업 삭제">×</button>
                    </div>
                    ${task.subtasks && task.subtasks.length > 0 && appState.expandedWorkGeneralSubtasks && appState.expandedWorkGeneralSubtasks[task.id] ? `
                      <div class="work-general-subtasks">
                        ${task.subtasks.map((st, idx) => `
                          <div class="work-general-subtask ${st.completed ? 'completed' : ''}" onclick="toggleSubtaskComplete('${task.id}', ${idx})">
                            <span class="subtask-check">${st.completed ? '✓' : '○'}</span>
                            <span>${st.text}</span>
                          </div>
                        `).join('')}
                      </div>
                    ` : ''}
                  </div>
                `).join('')}
                ${workGeneralTasks.length > 5 ? `<div class="work-general-more">+ ${workGeneralTasks.length - 5}개 더</div>` : ''}
              </div>
            </div>
          ` : ''}

          <!-- 뷰 전환 -->
          <div class="work-view-tabs">
            <button class="work-view-tab ${appState.workView === 'dashboard' ? 'active' : ''}" onclick="setWorkView('dashboard')">📊 대시보드</button>
            <button class="work-view-tab ${appState.workView === 'detail' ? 'active' : ''}" onclick="setWorkView('detail')">📝 상세보기</button>
            ${archivedProjects.length > 0 ? `
              <button class="work-view-tab" style="margin-left: auto;" onclick="toggleArchivedProjects()">
                📦 아카이브 (${archivedProjects.length})
              </button>
            ` : ''}
          </div>

          ${appState.workView === 'dashboard' ? `
            <!-- 대시보드 뷰 -->
            ${inProgressProjects.length > 0 ? `
              <div class="work-section">
                <div class="work-section-title">🚀 진행중 (${inProgressProjects.length})</div>
                <div class="work-dashboard">
                  ${inProgressProjects.map(p => renderWorkDashboardCard(p)).join('')}
                </div>
              </div>
            ` : ''}
            ${noDeadlineProjects.length > 0 ? `
              <div class="work-section collapsible" style="margin-top: 20px;">
                <div class="work-section-title clickable" style="color: var(--text-muted);" onclick="toggleWorkSection('noDeadline')">
                  <span class="work-section-toggle">${appState.workSectionExpanded?.noDeadline ? '▼' : '▶'}</span>
                  📋 마감없음 (${noDeadlineProjects.length})
                </div>
                ${appState.workSectionExpanded?.noDeadline ? `
                  <div class="work-dashboard">
                    ${noDeadlineProjects.map(p => renderWorkDashboardCard(p)).join('')}
                  </div>
                ` : ''}
              </div>
            ` : ''}
            ${onHoldProjects.length > 0 ? `
              <div class="work-section collapsible" style="margin-top: 20px;">
                <div class="work-section-title clickable" style="color: #f5576c;" onclick="toggleWorkSection('onHold')">
                  <span class="work-section-toggle">${appState.workSectionExpanded?.onHold ? '▼' : '▶'}</span>
                  ⏸ 보류 (${onHoldProjects.length})
                </div>
                ${appState.workSectionExpanded?.onHold ? `
                  <div class="work-dashboard">
                    ${onHoldProjects.map(p => renderWorkDashboardCard(p)).join('')}
                  </div>
                ` : ''}
              </div>
            ` : ''}
            ${completedProjects.length > 0 ? `
              <div class="work-section collapsible" style="margin-top: 20px;">
                <div class="work-section-title clickable" style="color: var(--success);" onclick="toggleWorkSection('completed')">
                  <span class="work-section-toggle">${appState.workSectionExpanded?.completed ? '▼' : '▶'}</span>
                  ✅ 완료 (${completedProjects.length})
                </div>
                ${appState.workSectionExpanded?.completed ? `
                  <div class="work-dashboard">
                    ${completedProjects.map(p => renderWorkDashboardCard(p)).join('')}
                  </div>
                ` : ''}
              </div>
            ` : ''}
            ${appState.showArchivedProjects && archivedProjects.length > 0 ? `
              <div class="work-section" style="margin-top: 20px;">
                <div class="work-section-title">📦 아카이브 (${archivedProjects.length})</div>
                <div class="work-dashboard">
                  ${archivedProjects.map(p => renderWorkDashboardCard(p)).join('')}
                </div>
              </div>
            ` : ''}
          ` : `
            <!-- 상세 뷰 -->
            <div class="work-project-selector">
              <label class="work-project-selector-label">프로젝트 선택</label>
              <select class="work-project-select" onchange="selectWorkProject(this.value)">
                <option value="" ${!appState.activeWorkProject ? 'selected' : ''}>-- 프로젝트 선택 --</option>
                ${inProgressProjects.length > 0 ? `
                  <optgroup label="🚀 진행중">
                    ${inProgressProjects.map(p => `
                      <option value="${p.id}" ${p.id === appState.activeWorkProject ? 'selected' : ''}>${escapeHtml(p.name)}</option>
                    `).join('')}
                  </optgroup>
                ` : ''}
                ${noDeadlineProjects.length > 0 ? `
                  <optgroup label="📋 마감없음">
                    ${noDeadlineProjects.map(p => `
                      <option value="${p.id}" ${p.id === appState.activeWorkProject ? 'selected' : ''}>${escapeHtml(p.name)}</option>
                    `).join('')}
                  </optgroup>
                ` : ''}
                ${onHoldProjects.length > 0 ? `
                  <optgroup label="⏸ 보류">
                    ${onHoldProjects.map(p => `
                      <option value="${p.id}" ${p.id === appState.activeWorkProject ? 'selected' : ''}>${escapeHtml(p.name)}</option>
                    `).join('')}
                  </optgroup>
                ` : ''}
                ${completedProjects.length > 0 ? `
                  <optgroup label="✅ 완료">
                    ${completedProjects.map(p => `
                      <option value="${p.id}" ${p.id === appState.activeWorkProject ? 'selected' : ''}>${escapeHtml(p.name)}</option>
                    `).join('')}
                  </optgroup>
                ` : ''}
                ${archivedProjects.length > 0 ? `
                  <optgroup label="📦 아카이브">
                    ${archivedProjects.map(p => `
                      <option value="${p.id}" ${p.id === appState.activeWorkProject ? 'selected' : ''}>${escapeHtml(p.name)}</option>
                    `).join('')}
                  </optgroup>
                ` : ''}
              </select>
            </div>
            ${activeProject ? renderWorkProjectDetail(activeProject) : `
              <div style="text-align: center; padding: 40px; color: var(--text-muted);">
                프로젝트를 선택하세요
              </div>
            `}
          `}
        </div>
      `;
    }

    /**
     * 뷰 전환
     */
    function setWorkView(view) {
      appState.workView = view;
      renderStatic();
    }
    window.setWorkView = setWorkView;

    /**
     * 아카이브 토글
     */
    function toggleArchivedProjects() {
      appState.showArchivedProjects = !appState.showArchivedProjects;
      renderStatic();
    }
    window.toggleArchivedProjects = toggleArchivedProjects;

    // 라이프 리듬 트래커 + 복약 트래커: js/rhythm.js로 분리됨

    // 로컬 타임존 기준 날짜 문자열 (YYYY-MM-DD) - UTC 변환 방지
    function getLocalDateStr(d) {
      const dt = d || new Date();
      return dt.getFullYear() + '-' + String(dt.getMonth() + 1).padStart(2, '0') + '-' + String(dt.getDate()).padStart(2, '0');
    }

    // 로컬 시간 기준 datetime-local 문자열 (YYYY-MM-DDTHH:mm)
    function getLocalDateTimeStr(d) {
      const dt = d || new Date();
      return getLocalDateStr(dt) + 'T' + String(dt.getHours()).padStart(2, '0') + ':' + String(dt.getMinutes()).padStart(2, '0');
    }

    // getTimeDiffMessage ~ loadLifeRhythm: js/rhythm.js로 분리됨


    function toggleWorkSection(section) {
      if (!appState.workSectionExpanded) {
        appState.workSectionExpanded = {};
      }
      appState.workSectionExpanded[section] = !appState.workSectionExpanded[section];
      renderStatic();
    }
    window.toggleWorkSection = toggleWorkSection;

    /**
     * 대시보드 카드 렌더링
     */
    function renderWorkDashboardCard(project) {
      const completedStages = project.stages.filter(s => s.completed).length;
      const totalStages = project.stages.length;
      const totalTasks = project.stages.reduce((sum, s) =>
        sum + (s.subcategories || []).reduce((subSum, sub) => subSum + sub.tasks.length, 0), 0);
      const completedTasks = project.stages.reduce((sum, s) =>
        sum + (s.subcategories || []).reduce((subSum, sub) => subSum + sub.tasks.filter(t => t.status === 'completed').length, 0), 0);

      // 마감일 계산
      let deadlineText = '';
      let deadlineClass = 'none';
      if (project.deadline) {
        const daysLeft = Math.ceil((new Date(project.deadline) - new Date()) / (1000 * 60 * 60 * 24));
        if (daysLeft < 0) {
          deadlineText = `D+${Math.abs(daysLeft)}`;
          deadlineClass = 'overdue';
        } else if (daysLeft === 0) {
          deadlineText = 'D-Day';
          deadlineClass = 'overdue';
        } else if (daysLeft <= 3) {
          deadlineText = `D-${daysLeft}`;
          deadlineClass = 'soon';
        } else {
          deadlineText = `D-${daysLeft}`;
        }
      }

      return `
        <div class="work-dashboard-card ${project.id === appState.activeWorkProject ? 'active' : ''} ${project.archived ? 'archived' : ''}"
             onclick="selectWorkProject('${project.id}'); setWorkView('detail');">
          <div class="work-dashboard-header">
            <div class="work-dashboard-name">
              ${escapeHtml(project.name)}
              ${project.archived ? '<span class="work-archived-badge">아카이브</span>' : ''}
              ${project.onHold ? '<span class="work-onhold-badge">보류</span>' : ''}
            </div>
            ${project.deadline ? `
              <span class="work-deadline ${deadlineClass}">${deadlineText}</span>
            ` : ''}
          </div>
          ${(project.startDate || project.deadline) ? `
            <div class="work-dashboard-schedule">
              📅 ${project.startDate ? `${new Date(project.startDate).getMonth() + 1}/${new Date(project.startDate).getDate()}` : ''}
              ${project.startDate && project.deadline ? '~' : ''}
              ${project.deadline ? `${new Date(project.deadline).getMonth() + 1}/${new Date(project.deadline).getDate()}` : ''}
            </div>
          ` : ''}
          <div class="work-dashboard-stages">
            ${project.stages.map((s, idx) => `
              <div class="work-dashboard-stage-dot ${s.completed ? 'completed' : (idx === project.currentStage ? 'current' : '')}"></div>
            `).join('')}
          </div>
          <div class="work-dashboard-meta">
            <span>📋 ${completedTasks}/${totalTasks} 항목</span>
            <span>✓ ${completedStages}/${totalStages} 단계</span>
            ${project.participantGoal ? `<span>👥 ${project.participantCount || 0}/${project.participantGoal}</span>` : ''}
          </div>
        </div>
      `;
    }

    /**
     * 프로젝트 선택
     */
    function selectWorkProject(projectId) {
      appState.activeWorkProject = projectId;
      renderStatic();
    }
    window.selectWorkProject = selectWorkProject;

    /**
     * 프로젝트 상세 렌더링
     */
    function renderWorkProjectDetail(project) {
      const completedStages = project.stages.filter(s => s.completed).length;
      const totalTasks = project.stages.reduce((sum, s) =>
        sum + (s.subcategories || []).reduce((subSum, sub) => subSum + sub.tasks.length, 0), 0);
      const completedTasks = project.stages.reduce((sum, s) =>
        sum + (s.subcategories || []).reduce((subSum, sub) => subSum + sub.tasks.filter(t => t.status === 'completed').length, 0), 0);
      const progressPercent = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;

      // 프로젝트 일정 계산
      let scheduleHtml = '';
      const formatDate = (dateStr) => {
        if (!dateStr) return '';
        const d = new Date(dateStr);
        return `${d.getMonth() + 1}/${d.getDate()}`;
      };

      if (project.startDate || project.deadline) {
        let dDayHtml = '';
        if (project.deadline) {
          const daysLeft = Math.ceil((new Date(project.deadline) - new Date()) / (1000 * 60 * 60 * 24));
          let deadlineClass = daysLeft < 0 ? 'overdue' : daysLeft <= 3 ? 'soon' : '';
          let deadlineText = daysLeft < 0 ? `D+${Math.abs(daysLeft)}` : daysLeft === 0 ? 'D-Day' : `D-${daysLeft}`;
          dDayHtml = `<span class="work-deadline ${deadlineClass}">${deadlineText}</span>`;
        }

        const dateRange = project.startDate && project.deadline
          ? `${formatDate(project.startDate)} ~ ${formatDate(project.deadline)}`
          : project.startDate ? `${formatDate(project.startDate)} ~` : `~ ${formatDate(project.deadline)}`;

        scheduleHtml = `
          <div class="work-schedule" onclick="showWorkModal('deadline', '${project.id}')" style="cursor: pointer; display: flex; align-items: center; gap: 8px;">
            <span class="work-date-range">📅 ${dateRange}</span>
            ${dDayHtml}
          </div>
        `;
      } else {
        scheduleHtml = `<span class="work-deadline none" onclick="showWorkModal('deadline', '${project.id}')">+ 일정 설정</span>`;
      }

      return `
        <div class="work-project-detail">
          <!-- 프로젝트 헤더 -->
          <div class="work-projects-header">
            <!-- 1줄: 프로젝트명 + 일정 + D-day -->
            <div class="work-project-info-row">
              <div class="work-projects-title">${escapeHtml(project.name)}</div>
              ${scheduleHtml}
            </div>
            <!-- 진행률 바 -->
            <div class="work-project-progress">
              <div class="work-project-progress-bar">
                <div class="work-project-progress-fill" style="width: ${progressPercent}%"></div>
              </div>
              <span class="work-project-progress-text">${completedTasks}/${totalTasks} 항목 · ${completedStages}/${project.stages.length} 단계</span>
            </div>
            <!-- 2줄: 액션 버튼 -->
            <div style="display: flex; gap: 8px; flex-wrap: wrap;">
              <button class="work-project-action-btn" onclick="copyProjectToSlack('${project.id}')" aria-label="슬랙에 복사">💬 슬랙복사</button>
              <button class="work-project-action-btn" onclick="duplicateWorkProject('${project.id}')" aria-label="프로젝트 복제">📋 복제</button>
              <button class="work-project-action-btn" onclick="holdWorkProject('${project.id}')" aria-label="${project.onHold ? '프로젝트 재개' : '프로젝트 보류'}">${project.onHold ? '▶ 재개' : '⏸ 보류'}</button>
              <button class="work-project-action-btn" onclick="archiveWorkProject('${project.id}')" aria-label="${project.archived ? '프로젝트 복원' : '프로젝트 보관'}">${project.archived ? '📤 복원' : '📦 보관'}</button>
              <button class="work-project-action-btn" onclick="saveAsTemplate('${project.id}')" aria-label="템플릿으로 저장">💾 템플릿</button>
              <button class="work-project-action-btn delete" onclick="deleteWorkProject('${project.id}')" aria-label="프로젝트 삭제">🗑️ 삭제</button>
            </div>
          </div>

          <!-- 참여자 트래커 -->
          ${project.participantGoal ? `
            <div class="work-participant-tracker">
              <span class="work-participant-label">👥 참여자 현황</span>
              <div class="work-participant-bar">
                <div class="work-participant-fill" style="width: ${Math.min(100, ((project.participantCount || 0) / project.participantGoal) * 100)}%"></div>
              </div>
              <span class="work-participant-count">${project.participantCount || 0}</span>
              <span class="work-participant-goal">/ ${project.participantGoal}명</span>
              <button class="work-task-action" onclick="updateParticipantCount('${project.id}')">수정</button>
            </div>
          ` : `
            <div style="margin: 12px 0;">
              <button class="work-stage-add-task" onclick="showWorkModal('participant', '${project.id}')">+ 참여자 목표 설정</button>
            </div>
          `}

          <!-- 단계별 내용 -->
          <div class="work-stages">
            ${project.stages.map((stage, stageIdx) => {
              const stageName = getStageName(project, stageIdx);
              const stageClass = stage.completed ? 'completed' : '';
              const subcategories = stage.subcategories || [];

              return `
                <div class="work-stage ${stageClass}">
                  <div class="work-stage-header">
                    <div class="work-stage-title">
                      <div class="work-stage-checkbox ${stage.completed ? 'checked' : ''}"
                           onclick="toggleStageComplete('${project.id}', ${stageIdx})">
                        ${stage.completed ? '✓' : ''}
                      </div>
                      <span class="work-stage-number">${stageIdx + 1}</span>
                      <span class="work-stage-name" onclick="promptRenameStage('${project.id}', ${stageIdx}, '${stageName.replace(/'/g, "\\'")}')" style="cursor: pointer;" title="클릭하여 이름 변경">${stageName}</span>
                      ${(stage.startDate || stage.deadline) ? (() => {
                        const fmtDate = (d) => d ? (new Date(d).getMonth() + 1) + '/' + new Date(d).getDate() : '';
                        let html = '<span class="work-stage-date" style="margin-left: 8px; font-size: 12px; color: var(--text-muted);">';
                        if (stage.startDate && stage.deadline) {
                          html += fmtDate(stage.startDate) + '~' + fmtDate(stage.deadline);
                        } else if (stage.startDate) {
                          html += fmtDate(stage.startDate) + '~';
                        } else {
                          html += '~' + fmtDate(stage.deadline);
                        }
                        html += '</span>';
                        if (stage.deadline) {
                          const daysLeft = Math.ceil((new Date(stage.deadline) - new Date()) / (1000 * 60 * 60 * 24));
                          const cls = daysLeft < 0 ? 'overdue' : daysLeft <= 3 ? 'soon' : '';
                          const txt = daysLeft < 0 ? 'D+' + Math.abs(daysLeft) : daysLeft === 0 ? 'D-Day' : 'D-' + daysLeft;
                          html += '<span class="work-deadline ' + cls + '" style="margin-left: 6px;">' + txt + '</span>';
                        }
                        return html;
                      })() : ''}
                    </div>
                    <div style="display: flex; gap: 6px;">
                      <button class="work-stage-add-task" onclick="promptRenameStage('${project.id}', ${stageIdx}, '${stageName.replace(/'/g, "\\'")}')" title="단계 이름 변경" aria-label="단계 이름 변경">✏️</button>
                      <button class="work-stage-add-task" onclick="showWorkModal('stage-deadline', '${project.id}', ${stageIdx})" title="단계 일정 설정" aria-label="단계 일정 설정">📅</button>
                      <button class="work-stage-add-task" onclick="deleteProjectStage('${project.id}', ${stageIdx})" title="단계 삭제" aria-label="단계 삭제" style="color: var(--danger);">🗑️</button>
                      <button class="work-stage-add-task" onclick="showWorkModal('subcategory', '${project.id}', ${stageIdx})">+ 중분류</button>
                    </div>
                  </div>

                  ${subcategories.length > 0 ? `
                    ${subcategories.map((subcat, subcatIdx) => `
                      <div class="work-subcategory">
                        <div class="work-subcategory-header">
                          <div class="work-subcategory-title">
                            <div class="work-subcategory-checkbox ${subcat.tasks.length > 0 && subcat.tasks.every(t => t.status === 'completed') ? 'checked' : ''}"
                                 onclick="toggleSubcategoryComplete('${project.id}', ${stageIdx}, ${subcatIdx})">
                              ${subcat.tasks.length > 0 && subcat.tasks.every(t => t.status === 'completed') ? '✓' : ''}
                            </div>
                            <span class="work-subcategory-name" onclick="promptRenameSubcategory('${project.id}', ${stageIdx}, ${subcatIdx}, '${subcat.name.replace(/'/g, "\\'")}')" title="클릭하여 이름 변경">${escapeHtml(subcat.name)}</span>
                            <span class="work-subcategory-toggle">(${subcat.tasks.filter(t => t.status === 'completed').length}/${subcat.tasks.length})</span>
                            ${(subcat.startDate || subcat.endDate) ? (() => {
                              const fmtDate = (d) => d ? (new Date(d).getMonth() + 1) + '/' + new Date(d).getDate() : '';
                              let html = '<span class="work-subcat-date" style="margin-left: 8px; font-size: 11px; color: var(--text-muted);">';
                              if (subcat.startDate && subcat.endDate) {
                                html += fmtDate(subcat.startDate) + '~' + fmtDate(subcat.endDate);
                              } else if (subcat.startDate) {
                                html += fmtDate(subcat.startDate) + '~';
                              } else {
                                html += '~' + fmtDate(subcat.endDate);
                              }
                              html += '</span>';
                              return html;
                            })() : ''}
                          </div>
                          <div class="work-subcategory-actions">
                            <button class="work-task-action" onclick="promptRenameSubcategory('${project.id}', ${stageIdx}, ${subcatIdx}, '${subcat.name.replace(/'/g, "\\'")}')" title="중분류 이름 변경">✏️</button>
                            <button class="work-task-action" onclick="showWorkModal('subcat-deadline', '${project.id}', ${stageIdx}, ${subcatIdx})" title="중분류 일정" aria-label="중분류 일정 설정">📅</button>
                            <button class="work-task-action" onclick="deleteSubcategory('${project.id}', ${stageIdx}, ${subcatIdx})" title="중분류 삭제" style="color: var(--danger);">🗑️</button>
                            <button class="work-task-action" onclick="showWorkModal('task', '${project.id}', ${stageIdx}, ${subcatIdx})">+ 항목</button>
                          </div>
                        </div>
                        ${subcat.tasks.length > 0 ? `
                          <div class="work-task-list">
                            ${subcat.tasks.map((task, taskIdx) => renderWorkTask(project.id, stageIdx, subcatIdx, task, taskIdx)).join('')}
                          </div>
                        ` : '<div style="color: var(--text-muted); font-size: 12px; padding: 8px;">항목 없음</div>'}
                      </div>
                    `).join('')}
                  ` : '<div style="color: var(--text-muted); font-size: 13px; padding: 10px;">중분류를 추가하세요</div>'}
                </div>
              `;
            }).join('')}

            <!-- 새 단계 추가 버튼 -->
            <div class="work-stage-add-new" style="margin-top: 12px; padding: 12px; border: 2px dashed var(--border); border-radius: var(--radius-md); text-align: center;">
              <button class="work-stage-add-task" onclick="promptAddStage('${project.id}')" style="width: 100%; padding: 10px;">
                + 새 단계 추가
              </button>
            </div>
          </div>

          <div style="display: flex; gap: 10px; margin-top: 16px;">
            <button class="work-copy-btn" onclick="copyWorkProjectToClipboard('${project.id}')">
              📋 노션/슬랙용 복사
            </button>
          </div>
        </div>
      `;
    }

    /**
     * 단계 완료 토글
     */
    function toggleStageComplete(projectId, stageIdx) {
      const project = appState.workProjects.find(p => p.id === projectId);
      if (!project) return;

      project.stages[stageIdx].completed = !project.stages[stageIdx].completed;

      // 완료된 단계 이후의 첫 미완료 단계를 현재 단계로 설정
      const firstIncomplete = project.stages.findIndex(s => !s.completed);
      project.currentStage = firstIncomplete >= 0 ? firstIncomplete : project.stages.length - 1;

      project.updatedAt = new Date().toISOString();
      saveWorkProjects();
      renderStatic();
      showToast(project.stages[stageIdx].completed ? '단계 완료!' : '단계 완료 취소', 'success');
    }
    window.toggleStageComplete = toggleStageComplete;

    /**
     * 프로젝트 복제
     */
    function duplicateWorkProject(projectId) {
      const project = appState.workProjects.find(p => p.id === projectId);
      if (!project) return;

      const newProject = JSON.parse(JSON.stringify(project));
      newProject.id = generateId();
      newProject.name = project.name + ' (복사본)';
      newProject.createdAt = new Date().toISOString();
      newProject.updatedAt = new Date().toISOString();
      newProject.archived = false;

      // 모든 단계와 항목 초기화
      newProject.stages.forEach(stage => {
        stage.completed = false;
        (stage.subcategories || []).forEach(sub => {
          sub.tasks.forEach(task => {
            task.status = 'not-started';
            task.logs = [];
          });
        });
      });
      newProject.currentStage = 0;
      newProject.participantCount = 0;

      appState.workProjects.push(newProject);
      appState.activeWorkProject = newProject.id;
      saveWorkProjects();
      renderStatic();
      showToast('프로젝트 복제됨', 'success');
    }
    window.duplicateWorkProject = duplicateWorkProject;

    /**
     * 프로젝트 슬랙 형식으로 클립보드 복사
     * - 슬랙에 붙여넣기 용도의 체크리스트 텍스트 생성
     */
    function copyProjectToSlack(projectId) {
      const project = appState.workProjects.find(p => p.id === projectId);
      if (!project) return;

      const statusLabel = {
        'not-started': '',
        'in-progress': '[진행중]',
        'completed': '[완료]',
        'blocked': '[보류]'
      };

      // 마감일 포맷 헬퍼
      const fmtDeadline = (task) => {
        if (!task.deadline) return '';
        const d = new Date(task.deadline);
        return ' ~' + (d.getMonth() + 1) + '/' + d.getDate();
      };

      let lines = [];
      lines.push('[ ' + project.name + ' 진행 리스트 ]');
      lines.push('');

      project.stages.forEach((stage, stageIdx) => {
        const stageName = getStageName(project, stageIdx);
        const subcats = stage.subcategories || [];
        if (subcats.length === 0) return;

        // 단계별 완료율 계산
        const total = subcats.reduce((s, sub) => s + sub.tasks.length, 0);
        const done = subcats.reduce((s, sub) => s + sub.tasks.filter(t => t.status === 'completed').length, 0);
        const stageStatus = total > 0 && done === total ? ' ✅' : '';

        lines.push('■ ' + stageName + stageStatus);

        subcats.forEach(sub => {
          // 중분류명이 "일반"이면 생략하고 작업만 나열
          const isGeneral = sub.name === '일반';

          if (!isGeneral) {
            // 중분류에 작업이 있으면 중분류명을 상위 항목으로 표시
            const subDone = sub.tasks.filter(t => t.status === 'completed').length;
            const subStatus = sub.tasks.length > 0 && subDone === sub.tasks.length ? ' [완료]' : '';
            lines.push(sub.name + ':' + subStatus);

            sub.tasks.forEach(task => {
              const status = statusLabel[task.status] || '';
              const deadline = fmtDeadline(task);
              const lastLog = task.logs && task.logs.length > 0 ? task.logs[task.logs.length - 1] : null;
              let line = '  ' + task.title;
              if (status) line += ' ' + status;
              if (deadline) line += deadline;
              if (lastLog && lastLog.content !== '✓ 완료') line += ' - ' + lastLog.content;
              lines.push(line);
            });
          } else {
            // "일반" 중분류: 작업을 최상위로 나열
            sub.tasks.forEach(task => {
              const status = statusLabel[task.status] || '';
              const deadline = fmtDeadline(task);
              const lastLog = task.logs && task.logs.length > 0 ? task.logs[task.logs.length - 1] : null;
              let line = task.title;
              if (status) line += ': ' + status;
              if (deadline) line += deadline;
              if (lastLog && lastLog.content !== '✓ 완료') line += ' - ' + lastLog.content;
              lines.push(line);
            });
          }
        });

        lines.push(''); // 단계 사이 빈 줄
      });

      const text = lines.join('\n').trim();
      navigator.clipboard.writeText(text).then(() => {
        showToast('슬랙용 진행 리스트 복사됨', 'success');
      }).catch(() => {
        // 클립보드 API 실패 시 fallback
        const textarea = document.createElement('textarea');
        textarea.value = text;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand('copy');
        document.body.removeChild(textarea);
        showToast('슬랙용 진행 리스트 복사됨', 'success');
      });
    }
    window.copyProjectToSlack = copyProjectToSlack;

    /**
     * 프로젝트 아카이브
     */
    function archiveWorkProject(projectId) {
      const project = appState.workProjects.find(p => p.id === projectId);
      if (!project) return;

      project.archived = !project.archived;
      project.updatedAt = new Date().toISOString();

      if (project.archived && appState.activeWorkProject === projectId) {
        const active = appState.workProjects.find(p => !p.archived);
        appState.activeWorkProject = active ? active.id : null;
      }

      saveWorkProjects();
      renderStatic();
      showToast(project.archived ? '아카이브됨' : '아카이브 해제됨', 'success');
    }
    window.archiveWorkProject = archiveWorkProject;

    /**
     * 프로젝트 보류 토글
     */
    function holdWorkProject(projectId) {
      const project = appState.workProjects.find(p => p.id === projectId);
      if (!project) return;

      project.onHold = !project.onHold;
      project.updatedAt = new Date().toISOString();

      saveWorkProjects();
      renderStatic();
      showToast(project.onHold ? '보류 처리됨' : '보류 해제됨', 'success');
    }
    window.holdWorkProject = holdWorkProject;

    /**
     * 템플릿으로 저장
     */
    function saveAsTemplate(projectId) {
      const project = appState.workProjects.find(p => p.id === projectId);
      if (!project) return;

      const templateName = prompt('템플릿 이름을 입력하세요:', project.name + ' 템플릿');
      if (!templateName) return;

      const template = {
        id: generateId(),
        name: templateName,
        stageNames: project.stages.map(s => s.name || ''),
        stages: project.stages.map(stage => ({
          subcategories: (stage.subcategories || []).map(sub => ({
            name: sub.name,
            tasks: sub.tasks.map(t => ({ title: t.title }))
          }))
        })),
        participantGoal: project.participantGoal,
        createdAt: new Date().toISOString()
      };

      appState.workTemplates.push(template);
      if (!appState.user) {
        localStorage.setItem('navigator-work-templates', JSON.stringify(appState.workTemplates));
      }
      if (appState.user) { syncToFirebase(); }
      showToast('템플릿 저장됨', 'success');
    }
    window.saveAsTemplate = saveAsTemplate;

    /**
     * 참여자 수 업데이트
     */
    function updateParticipantCount(projectId) {
      const project = appState.workProjects.find(p => p.id === projectId);
      if (!project) return;

      const count = prompt('현재 참여자 수:', project.participantCount || 0);
      if (count === null) return;

      project.participantCount = parseInt(count) || 0;
      project.updatedAt = new Date().toISOString();
      saveWorkProjects();
      renderStatic();
    }
    window.updateParticipantCount = updateParticipantCount;

    /**
     * 작업 항목 렌더링
     */
    function renderWorkTask(projectId, stageIdx, subcatIdx, task, taskIdx) {
      const statusInfo = WORK_STATUS[task.status] || WORK_STATUS['not-started'];

      // 작업 마감일 표시
      let deadlineHtml = '';
      if (task.deadline) {
        const d = new Date(task.deadline);
        const daysLeft = Math.ceil((d - new Date()) / (1000 * 60 * 60 * 24));
        const deadlineClass = daysLeft < 0 ? 'overdue' : daysLeft <= 2 ? 'soon' : '';
        const dateStr = (d.getMonth() + 1) + '/' + d.getDate();
        deadlineHtml = `<span class="work-task-deadline ${deadlineClass}" onclick="event.stopPropagation(); promptTaskDeadline('${projectId}', ${stageIdx}, ${subcatIdx}, ${taskIdx})" title="클릭하여 마감일 변경">~${dateStr}</span>`;
      }

      return `
        <div class="work-task-item">
          <div class="work-task-header">
            <div class="work-task-checkbox ${task.status === 'completed' ? 'checked' : ''}"
                 onclick="toggleWorkTaskComplete('${projectId}', ${stageIdx}, ${subcatIdx}, ${taskIdx})"
                 title="완료 체크">
              ${task.status === 'completed' ? '✓' : ''}
            </div>
            <span class="work-status-badge ${task.status}" onclick="cycleWorkTaskStatus('${projectId}', ${stageIdx}, ${subcatIdx}, ${taskIdx})"
                  title="클릭하여 상태 변경">
              ${statusInfo.label}
            </span>
            <span class="work-task-title ${task.status === 'completed' ? 'completed' : ''}"
                  onclick="promptRenameWorkTask('${projectId}', ${stageIdx}, ${subcatIdx}, ${taskIdx}, '${task.title.replace(/'/g, "\\'")}')"
                  title="클릭하여 이름 변경">${escapeHtml(task.title)}</span>
            ${deadlineHtml}
            <div class="work-task-actions">
              <button class="work-task-action" onclick="promptRenameWorkTask('${projectId}', ${stageIdx}, ${subcatIdx}, ${taskIdx}, '${task.title.replace(/'/g, "\\'")}')">✏️</button>
              <button class="work-task-action" onclick="promptTaskDeadline('${projectId}', ${stageIdx}, ${subcatIdx}, ${taskIdx})" title="마감일 설정" aria-label="마감일 설정">📅</button>
              <button class="work-task-action" onclick="showWorkModal('log', '${projectId}', ${stageIdx}, ${subcatIdx}, ${taskIdx})" aria-label="기록 추가">+ 기록</button>
              <button class="work-task-action" onclick="deleteWorkTask('${projectId}', ${stageIdx}, ${subcatIdx}, ${taskIdx})" title="항목 삭제" aria-label="항목 삭제" style="color: var(--danger);">🗑️</button>
            </div>
          </div>
          ${task.logs && task.logs.length > 0 ? `
            <div class="work-task-logs">
              ${(() => {
                // 완료 로그 압축: "✓ 완료" 로그는 하나로 요약
                const completionLogs = task.logs.filter(l => l.content === '✓ 완료');
                const otherLogs = task.logs.filter(l => l.content !== '✓ 완료');
                let html = '';
                if (completionLogs.length > 0) {
                  const lastDate = completionLogs[completionLogs.length - 1].date;
                  if (completionLogs.length === 1) {
                    html += '<div class="work-task-log"><span class="work-task-log-date" style="color: #48bb78;">✓ 완료 (' + lastDate + ')</span></div>';
                  } else {
                    html += '<div class="work-task-log"><span class="work-task-log-date" style="color: #48bb78;">✓ ' + completionLogs.length + '회 완료 (최근: ' + lastDate + ')</span></div>';
                  }
                }
                otherLogs.forEach(log => {
                  const actualIdx = task.logs.indexOf(log);
                  html += '<div class="work-task-log"><span class="work-task-log-date">' + log.date + '</span><span class="work-task-log-content">' + log.content + '</span><div class="work-task-log-actions"><button class="work-task-log-action" onclick="deleteWorkLog(' + projectId + ', ' + stageIdx + ', ' + subcatIdx + ', ' + taskIdx + ', ' + actualIdx + ')" aria-label="기록 삭제">×</button></div></div>';
                });
                return html;
              })()}
            </div>
          ` : ''}
        </div>
      `;
    }

    /**
     * 모달 표시
     */
    function showWorkModal(type, projectId = null, stageIdx = null, subcatIdx = null, taskIdx = null) {
      workModalState = { type, projectId, stageIdx, subcategoryIdx: subcatIdx, taskIdx };

      const modal = document.getElementById('work-input-modal');
      const title = document.getElementById('work-modal-title');
      const body = document.getElementById('work-modal-body');

      let titleText = '';
      let bodyHtml = '';

      const project = projectId ? appState.workProjects.find(p => p.id === projectId) : null;

      switch(type) {
        case 'project':
          titleText = '📁 새 프로젝트';
          bodyHtml = `
            <div class="work-modal-field">
              <label class="work-modal-label">프로젝트 이름</label>
              <input type="text" class="work-modal-input" id="work-input-name" placeholder="예: UT 10월차" autofocus>
            </div>
            <div class="work-modal-field">
              <label class="work-modal-label">마감일 (선택)</label>
              <input type="date" class="work-modal-input" id="work-input-deadline">
            </div>
          `;
          break;
        case 'subcategory':
          titleText = '📂 중분류 추가';
          bodyHtml = `
            <div class="work-modal-field">
              <label class="work-modal-label">중분류 이름</label>
              <input type="text" class="work-modal-input" id="work-input-name" placeholder="예: 사전 준비" autofocus>
            </div>
          `;
          break;
        case 'task':
          titleText = '📝 항목 추가';
          bodyHtml = `
            <div class="work-modal-field">
              <label class="work-modal-label">항목 이름</label>
              <input type="text" class="work-modal-input" id="work-input-name" placeholder="예: 작업명 입력" autofocus>
            </div>
            <div class="work-modal-field">
              <label class="work-modal-label">진행 상태</label>
              <div class="work-status-group">
                <button type="button" class="work-status-option selected" data-status="not-started">미시작</button>
                <button type="button" class="work-status-option" data-status="in-progress">진행중</button>
                <button type="button" class="work-status-option" data-status="completed">완료</button>
                <button type="button" class="work-status-option" data-status="blocked">보류</button>
              </div>
            </div>
          `;
          break;
        case 'log':
          titleText = '📋 진행 기록 추가';
          bodyHtml = `
            <div class="work-modal-field">
              <label class="work-modal-label">진행 내용</label>
              <textarea class="work-modal-textarea" id="work-input-content" placeholder="오늘 진행한 내용을 입력하세요..." autofocus></textarea>
            </div>
          `;
          break;
        case 'deadline':
          titleText = '📅 프로젝트 일정';
          bodyHtml = `
            <div class="work-modal-field">
              <label class="work-modal-label">시작일</label>
              <input type="date" class="work-modal-input" id="work-input-startdate" value="${project?.startDate || ''}">
            </div>
            <div class="work-modal-field">
              <label class="work-modal-label">마감일</label>
              <input type="date" class="work-modal-input" id="work-input-deadline" value="${project?.deadline || ''}">
            </div>
            ${project?.startDate && project?.deadline ? `
              <div style="color: var(--text-muted); font-size: 12px; margin-top: 8px;">
                📆 총 ${Math.ceil((new Date(project.deadline) - new Date(project.startDate)) / (1000 * 60 * 60 * 24))}일 소요 예정
              </div>
            ` : ''}
          `;
          break;
        case 'stage-deadline':
          titleText = '📅 단계 일정';
          const stageData = project?.stages[stageIdx] || {};
          const stageNameForModal = getStageName(project, stageIdx);
          bodyHtml = `
            <div class="work-modal-field">
              <label class="work-modal-label">${stageNameForModal} 시작일</label>
              <input type="date" class="work-modal-input" id="work-input-startdate" value="${stageData.startDate || ''}">
            </div>
            <div class="work-modal-field">
              <label class="work-modal-label">${stageNameForModal} 마감일</label>
              <input type="date" class="work-modal-input" id="work-input-deadline" value="${stageData.deadline || ''}">
            </div>
          `;
          break;
        case 'subcat-deadline':
          titleText = '📅 중분류 일정';
          const subcatData = project?.stages[stageIdx]?.subcategories[subcatIdx] || {};
          bodyHtml = `
            <div class="work-modal-field">
              <label class="work-modal-label">${escapeHtml(subcatData.name) || '중분류'} 시작일</label>
              <input type="date" class="work-modal-input" id="work-input-startdate" value="${subcatData.startDate || ''}">
            </div>
            <div class="work-modal-field">
              <label class="work-modal-label">${escapeHtml(subcatData.name) || '중분류'} 종료일</label>
              <input type="date" class="work-modal-input" id="work-input-deadline" value="${subcatData.endDate || ''}">
            </div>
          `;
          break;
        case 'participant':
          titleText = '👥 참여자 목표 설정';
          bodyHtml = `
            <div class="work-modal-field">
              <label class="work-modal-label">목표 참여자 수</label>
              <input type="number" class="work-modal-input" id="work-input-goal" placeholder="예: 10" min="1" value="${project?.participantGoal || ''}">
            </div>
            <div class="work-modal-field">
              <label class="work-modal-label">현재 참여자 수</label>
              <input type="number" class="work-modal-input" id="work-input-count" placeholder="예: 0" min="0" value="${project?.participantCount || 0}">
            </div>
          `;
          break;
        case 'template-select': {
          titleText = '📋 템플릿 선택';
          const allTemplates = appState.workTemplates;
          const totalTaskCount = (t) => t.stages.reduce((sum, s) => sum + (s.subcategories || []).reduce((ss, sub) => ss + sub.tasks.length, 0), 0);
          if (allTemplates.length === 0) {
            bodyHtml = `
              <div class="work-modal-field" style="text-align: center; padding: 20px; color: var(--text-muted);">
                <div style="font-size: 14px; margin-bottom: 12px;">저장된 템플릿이 없습니다</div>
                <div style="font-size: 12px;">📥 가져오기 버튼으로 JSON 템플릿을 추가하거나,<br>프로젝트 상세에서 "템플릿으로 저장"을 이용하세요.</div>
              </div>
            `;
          } else {
            bodyHtml = `
              <div class="work-modal-field">
                <div style="display: flex; flex-direction: column; gap: 8px;">
                  ${allTemplates.map(t => `
                    <div style="display: flex; align-items: stretch; gap: 4px;">
                      <button type="button" class="work-status-option template-option" data-template-id="${t.id}" style="text-align: left; padding: 12px; flex: 1;">
                        <div style="font-weight: 500;">${escapeHtml(t.name)}</div>
                        <div style="font-size: 11px; color: var(--text-muted); margin-top: 4px;">
                          ${(t.stageNames || t.stages.map((_, i) => appState.workProjectStages[i])).filter(Boolean).join(' → ')}
                        </div>
                        <div style="font-size: 11px; color: var(--text-muted);">
                          ${totalTaskCount(t)}개 항목
                        </div>
                      </button>
                      <button type="button" class="work-project-action-btn" onclick="exportTemplate('${t.id}')" title="JSON 내보내기" style="padding: 8px; font-size: 14px;">📤</button>
                    </div>
                  `).join('')}
                </div>
              </div>
            `;
          }
          break;
        }
        case 'template-import': {
          titleText = '📥 템플릿 가져오기';
          bodyHtml = `
            <div class="work-modal-field">
              <label class="work-modal-label">JSON 템플릿 붙여넣기</label>
              <textarea class="work-modal-input" id="work-input-template-json" rows="10"
                placeholder='{"name": "템플릿 이름", "stageNames": ["단계1", ...], "stages": [{"subcategories": [{"name": "분류", "tasks": [{"title": "작업"}]}]}]}'
                style="font-family: monospace; font-size: 12px; resize: vertical; min-height: 150px;"></textarea>
              <div style="font-size: 11px; color: var(--text-muted); margin-top: 8px;">
                프로젝트에서 📤 내보내기한 JSON을 붙여넣으세요.<br>
                가져온 템플릿은 모든 기기에서 자동 동기화됩니다.
              </div>
            </div>
          `;
          break;
        }
      }

      title.textContent = titleText;
      body.innerHTML = bodyHtml;
      modal.classList.add('show');

      // 상태 선택 버튼 이벤트
      if (type === 'task') {
        body.querySelectorAll('.work-status-option').forEach(btn => {
          btn.onclick = () => {
            body.querySelectorAll('.work-status-option').forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
          };
        });
      }

      // 템플릿 선택 이벤트
      if (type === 'template-select') {
        body.querySelectorAll('.template-option').forEach(btn => {
          btn.onclick = () => {
            body.querySelectorAll('.template-option').forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
          };
        });
      }

      // 첫 입력 필드에 포커스
      setTimeout(() => {
        const input = body.querySelector('input, textarea');
        if (input) input.focus();
      }, 100);
    }
    window.showWorkModal = showWorkModal;

    /**
     * 모달 닫기
     */
    function closeWorkModal() {
      document.getElementById('work-input-modal').classList.remove('show');
      workModalState = { type: null, projectId: null, stageIdx: null, subcategoryIdx: null, taskIdx: null };
    }
    window.closeWorkModal = closeWorkModal;

    /**
     * 모달 확인
     */
    function confirmWorkModal() {
      const { type, projectId, stageIdx, subcategoryIdx, taskIdx } = workModalState;

      switch(type) {
        case 'project': {
          const name = document.getElementById('work-input-name').value.trim();
          if (!name) { showToast('이름을 입력하세요', 'error'); return; }
          const deadline = document.getElementById('work-input-deadline')?.value || null;
          addWorkProject(name, deadline);
          break;
        }
        case 'subcategory': {
          const name = document.getElementById('work-input-name').value.trim();
          if (!name) { showToast('이름을 입력하세요', 'error'); return; }
          addSubcategory(projectId, stageIdx, name);
          break;
        }
        case 'task': {
          const name = document.getElementById('work-input-name').value.trim();
          if (!name) { showToast('이름을 입력하세요', 'error'); return; }
          const status = document.querySelector('.work-status-option.selected')?.dataset.status || 'not-started';
          addWorkTask(projectId, stageIdx, subcategoryIdx, name, status);
          break;
        }
        case 'log': {
          const content = document.getElementById('work-input-content').value.trim();
          if (!content) { showToast('내용을 입력하세요', 'error'); return; }
          addWorkLog(projectId, stageIdx, subcategoryIdx, taskIdx, content);
          break;
        }
        case 'deadline': {
          const startDate = document.getElementById('work-input-startdate').value || null;
          const deadline = document.getElementById('work-input-deadline').value || null;
          const project = appState.workProjects.find(p => p.id === projectId);
          if (project) {
            project.startDate = startDate;
            project.deadline = deadline;
            project.updatedAt = new Date().toISOString();
            saveWorkProjects();
            renderStatic();
            showToast('일정 설정됨', 'success');
          }
          break;
        }
        case 'stage-deadline': {
          const startDate = document.getElementById('work-input-startdate').value || null;
          const deadline = document.getElementById('work-input-deadline').value || null;
          const project = appState.workProjects.find(p => p.id === projectId);
          if (project) {
            project.stages[stageIdx].startDate = startDate;
            project.stages[stageIdx].deadline = deadline;
            project.updatedAt = new Date().toISOString();
            saveWorkProjects();
            renderStatic();
            showToast('단계 일정 설정됨', 'success');
          }
          break;
        }
        case 'subcat-deadline': {
          const startDate = document.getElementById('work-input-startdate').value || null;
          const endDate = document.getElementById('work-input-deadline').value || null;
          const project = appState.workProjects.find(p => p.id === projectId);
          if (project && project.stages[stageIdx]?.subcategories[subcategoryIdx]) {
            project.stages[stageIdx].subcategories[subcategoryIdx].startDate = startDate;
            project.stages[stageIdx].subcategories[subcategoryIdx].endDate = endDate;
            project.updatedAt = new Date().toISOString();
            saveWorkProjects();
            renderStatic();
            showToast('중분류 일정 설정됨', 'success');
          }
          break;
        }
        case 'participant': {
          const goal = parseInt(document.getElementById('work-input-goal').value) || null;
          const count = parseInt(document.getElementById('work-input-count').value) || 0;
          const project = appState.workProjects.find(p => p.id === projectId);
          if (project) {
            project.participantGoal = goal;
            project.participantCount = count;
            project.updatedAt = new Date().toISOString();
            saveWorkProjects();
            renderStatic();
            showToast('참여자 목표 설정됨', 'success');
          }
          break;
        }
        case 'template-select': {
          const selected = document.querySelector('.template-option.selected');
          if (selected) {
            const templateId = selected.dataset.templateId;
            applyTemplate(templateId);
          }
          break;
        }
        case 'template-import': {
          const jsonText = document.getElementById('work-input-template-json').value.trim();
          if (!jsonText) { showToast('JSON을 입력하세요', 'error'); return; }

          try {
            const parsed = JSON.parse(jsonText);

            // 검증: 필수 필드
            if (!parsed.name || typeof parsed.name !== 'string') {
              showToast('name 필드가 필요합니다', 'error'); return;
            }
            if (!Array.isArray(parsed.stages) || parsed.stages.length === 0) {
              showToast('stages 배열이 필요합니다', 'error'); return;
            }

            // 검증: stages 구조
            for (let i = 0; i < parsed.stages.length; i++) {
              const stage = parsed.stages[i];
              if (!stage.subcategories || !Array.isArray(stage.subcategories)) {
                showToast(`stages[${i}]에 subcategories 배열이 필요합니다`, 'error'); return;
              }
              for (const sub of stage.subcategories) {
                if (!sub.name || !Array.isArray(sub.tasks)) {
                  showToast('subcategories에 name과 tasks가 필요합니다', 'error'); return;
                }
                for (const task of sub.tasks) {
                  if (!task.title) {
                    showToast('tasks에 title이 필요합니다', 'error'); return;
                  }
                }
              }
            }

            // 템플릿 생성
            const template = {
              id: generateId(),
              name: parsed.name,
              stageNames: parsed.stageNames || null,
              stages: parsed.stages.map(stage => ({
                subcategories: stage.subcategories.map(sub => ({
                  name: sub.name,
                  tasks: sub.tasks.map(t => ({ title: t.title }))
                }))
              })),
              participantGoal: parsed.participantGoal || null,
              createdAt: new Date().toISOString()
            };

            appState.workTemplates.push(template);
            if (!appState.user) {
              localStorage.setItem('navigator-work-templates', JSON.stringify(appState.workTemplates));
            }
            syncToFirebase();
            showToast(`"${escapeHtml(template.name)}" 템플릿 가져오기 완료`, 'success');
            renderStatic();
          } catch (e) {
            showToast('JSON 파싱 오류: ' + e.message, 'error'); return;
          }
          break;
        }
      }

      closeWorkModal();
    }
    window.confirmWorkModal = confirmWorkModal;

    /**
     * 템플릿 적용
     */
    function applyTemplate(templateId) {
      const template = appState.workTemplates.find(t => t.id === templateId);
      if (!template) return;

      const projectName = prompt('프로젝트 이름을 입력하세요:', template.name.replace(' 템플릿', ''));
      if (!projectName) return;

      // 템플릿에 stageNames가 있으면 그것 사용, 없으면 전역 기본값 사용
      const stageSource = template.stageNames || appState.workProjectStages;
      const stageCount = Math.max(stageSource.length, template.stages.length);

      const newProject = {
        id: generateId(),
        name: projectName,
        currentStage: 0,
        stages: Array.from({ length: stageCount }, (_, idx) => ({
          name: stageSource[idx] || ('단계 ' + (idx + 1)),
          completed: false,
          startDate: null,
          endDate: null,
          subcategories: template.stages[idx]?.subcategories?.map(sub => ({
            id: generateId(),
            name: sub.name,
            startDate: null,
            endDate: null,
            tasks: sub.tasks.map(t => ({
              id: generateId(),
              title: t.title,
              status: 'not-started',
              logs: []
            }))
          })) || []
        })),
        participantGoal: template.participantGoal,
        participantCount: 0,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };

      appState.workProjects.push(newProject);
      appState.activeWorkProject = newProject.id;
      saveWorkProjects();
      renderStatic();
      showToast(`"${projectName}" 생성됨`, 'success');
    }

    /**
     * 템플릿 JSON 내보내기 (클립보드 복사)
     */
    function exportTemplate(templateId) {
      const template = appState.workTemplates.find(t => t.id === templateId);
      if (!template) return;

      // 내보내기용 JSON (id, createdAt 등 내부 필드 제외)
      const exportData = {
        name: template.name,
        stageNames: template.stageNames || null,
        stages: template.stages.map(stage => ({
          subcategories: (stage.subcategories || []).map(sub => ({
            name: sub.name,
            tasks: sub.tasks.map(t => ({ title: t.title }))
          }))
        })),
        participantGoal: template.participantGoal || null
      };

      const json = JSON.stringify(exportData, null, 2);
      navigator.clipboard.writeText(json).then(() => {
        showToast(`"${escapeHtml(template.name)}" 템플릿 JSON 복사됨`, 'success');
      }).catch(() => {
        // 클립보드 실패 시 프롬프트로 표시
        prompt('아래 JSON을 복사하세요:', json);
      });
    }
    window.exportTemplate = exportTemplate;

    /**
     * 프로젝트 추가
     */
    function addWorkProject(name, deadline = null) {
      // 기본 단계 (프로젝트별로 커스터마이징 가능)
      const defaultStages = appState.workProjectStages.map(stageName => ({
        name: stageName,
        completed: false,
        subcategories: [],
        startDate: null,
        endDate: null
      }));

      const newProject = {
        id: generateId(),
        name: name,
        currentStage: 0,
        deadline: deadline,
        stages: defaultStages,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };

      appState.workProjects.push(newProject);
      appState.activeWorkProject = newProject.id;
      appState.workView = 'detail'; // 새 프로젝트 생성 시 상세보기로
      saveWorkProjects();
      renderStatic();
      showToast(`프로젝트 "${name}" 생성됨`, 'success');
    }

    /**
     * 프로젝트 단계 추가
     */
    function addProjectStage(projectId, stageName) {
      const project = appState.workProjects.find(p => p.id === projectId);
      if (!project || !stageName.trim()) return;

      project.stages.push({
        name: stageName.trim(),
        completed: false,
        subcategories: [],
        startDate: null,
        endDate: null
      });
      project.updatedAt = new Date().toISOString();
      saveWorkProjects();
      renderStatic();
      showToast(`"${stageName}" 단계 추가됨`, 'success');
    }
    window.addProjectStage = addProjectStage;

    /**
     * 프로젝트 단계 이름 수정
     */
    function renameProjectStage(projectId, stageIdx, newName) {
      const project = appState.workProjects.find(p => p.id === projectId);
      if (!project || !project.stages[stageIdx] || !newName.trim()) return;

      project.stages[stageIdx].name = newName.trim();
      project.updatedAt = new Date().toISOString();
      saveWorkProjects();
      renderStatic();
    }
    window.renameProjectStage = renameProjectStage;

    /**
     * 프로젝트 단계 삭제
     */
    function deleteProjectStage(projectId, stageIdx) {
      const project = appState.workProjects.find(p => p.id === projectId);
      if (!project || !project.stages[stageIdx]) return;

      const stageName = project.stages[stageIdx].name;
      if (!confirm(`"${escapeHtml(stageName)}" 단계를 삭제하시겠습니까?\n하위 중분류/작업도 모두 삭제됩니다.`)) return;

      project.stages.splice(stageIdx, 1);
      if (project.currentStage >= project.stages.length) {
        project.currentStage = Math.max(0, project.stages.length - 1);
      }
      project.updatedAt = new Date().toISOString();
      saveWorkProjects();
      renderStatic();
      showToast(`"${stageName}" 단계 삭제됨`, 'success');
    }
    window.deleteProjectStage = deleteProjectStage;

    /**
     * 단계 이름 가져오기 (기존 프로젝트 호환)
     */
    function getStageName(project, stageIdx) {
      const stage = project.stages[stageIdx];
      if (!stage) return '';
      // 새 구조: name 필드가 있음
      if (stage.name) return stage.name;
      // 기존 구조: 전역 배열에서 가져옴
      return appState.workProjectStages[stageIdx] || `단계 ${stageIdx + 1}`;
    }
    window.getStageName = getStageName;

    /**
     * 새 단계 추가 프롬프트
     */
    function promptAddStage(projectId) {
      const name = prompt('새 단계 이름을 입력하세요:');
      if (name && name.trim()) {
        addProjectStage(projectId, name.trim());
      }
    }
    window.promptAddStage = promptAddStage;

    /**
     * 단계 이름 변경 프롬프트
     */
    function promptRenameStage(projectId, stageIdx, currentName) {
      const newName = prompt('단계 이름을 변경하세요:', currentName);
      if (newName && newName.trim() && newName.trim() !== currentName) {
        renameProjectStage(projectId, stageIdx, newName.trim());
      }
    }
    window.promptRenameStage = promptRenameStage;

    /**
     * 중분류 이름 변경 프롬프트
     */
    function promptRenameSubcategory(projectId, stageIdx, subcatIdx, currentName) {
      const newName = prompt('중분류 이름을 변경하세요:', currentName);
      if (newName && newName.trim() && newName.trim() !== currentName) {
        renameSubcategory(projectId, stageIdx, subcatIdx, newName.trim());
      }
    }
    window.promptRenameSubcategory = promptRenameSubcategory;

    /**
     * 중분류 이름 변경
     */
    function renameSubcategory(projectId, stageIdx, subcatIdx, newName) {
      const project = appState.workProjects.find(p => p.id === projectId);
      if (!project) return;

      const subcat = project.stages[stageIdx]?.subcategories?.[subcatIdx];
      if (subcat) {
        subcat.name = newName;
        project.updatedAt = new Date().toISOString();
        saveWorkProjects();
        renderStatic();
        showToast('중분류 이름이 변경되었습니다', 'success');
      }
    }
    window.renameSubcategory = renameSubcategory;

    /**
     * 소분류(항목) 이름 변경 프롬프트
     */
    function promptRenameWorkTask(projectId, stageIdx, subcatIdx, taskIdx, currentName) {
      const newName = prompt('항목 이름을 변경하세요:', currentName);
      if (newName && newName.trim() && newName.trim() !== currentName) {
        renameWorkTask(projectId, stageIdx, subcatIdx, taskIdx, newName.trim());
      }
    }
    window.promptRenameWorkTask = promptRenameWorkTask;

    /**
     * 소분류(항목) 이름 변경
     */
    function renameWorkTask(projectId, stageIdx, subcatIdx, taskIdx, newName) {
      const project = appState.workProjects.find(p => p.id === projectId);
      if (!project) return;

      const task = project.stages[stageIdx]?.subcategories?.[subcatIdx]?.tasks?.[taskIdx];
      if (task) {
        task.title = newName;
        project.updatedAt = new Date().toISOString();
        saveWorkProjects();
        renderStatic();
        showToast('항목 이름이 변경되었습니다', 'success');
      }
    }
    window.renameWorkTask = renameWorkTask;

    /**
     * 소분류(항목) 마감일 설정
     * - prompt 대신 date input 사용 (모바일 날짜 선택기 활용)
     */
    function promptTaskDeadline(projectId, stageIdx, subcatIdx, taskIdx) {
      const project = appState.workProjects.find(p => p.id === projectId);
      if (!project) return;
      const task = project.stages[stageIdx]?.subcategories?.[subcatIdx]?.tasks?.[taskIdx];
      if (!task) return;

      // date input을 동적으로 생성하여 날짜 선택기 호출
      const input = document.createElement('input');
      input.type = 'date';
      input.value = task.deadline || '';
      input.style.position = 'fixed';
      input.style.opacity = '0';
      input.style.top = '50%';
      input.style.left = '50%';
      document.body.appendChild(input);

      input.addEventListener('change', function() {
        task.deadline = this.value || null;
        project.updatedAt = new Date().toISOString();
        saveWorkProjects();
        renderStatic();
        if (this.value) {
          const d = new Date(this.value);
          showToast('마감일 설정: ' + (d.getMonth() + 1) + '/' + d.getDate(), 'success');
        } else {
          showToast('마감일 삭제됨', 'success');
        }
        document.body.removeChild(input);
      });

      input.addEventListener('blur', function() {
        // 변경 없이 닫힌 경우 정리
        if (document.body.contains(input)) {
          document.body.removeChild(input);
        }
      });

      input.focus();
      input.showPicker?.();
    }
    window.promptTaskDeadline = promptTaskDeadline;

    /**
     * 중분류 추가
     */
    function addSubcategory(projectId, stageIdx, name) {
      const project = appState.workProjects.find(p => p.id === projectId);
      if (!project) return;

      if (!project.stages[stageIdx].subcategories) {
        project.stages[stageIdx].subcategories = [];
      }

      project.stages[stageIdx].subcategories.push({
        id: generateId(),
        name: name,
        tasks: []
      });

      project.updatedAt = new Date().toISOString();
      saveWorkProjects();
      renderStatic();
      showToast(`"${name}" 추가됨`, 'success');
    }

    /**
     * 중분류 삭제
     */
    function deleteSubcategory(projectId, stageIdx, subcatIdx) {
      if (!confirm('이 중분류와 하위 항목을 모두 삭제하시겠습니까?')) return;

      const project = appState.workProjects.find(p => p.id === projectId);
      if (!project) return;

      project.stages[stageIdx].subcategories.splice(subcatIdx, 1);
      project.updatedAt = new Date().toISOString();
      saveWorkProjects();
      renderStatic();
      showToast('삭제됨', 'success');
    }
    window.deleteSubcategory = deleteSubcategory;

    /**
     * 프로젝트 단계 이동
     */
    function moveWorkProjectStage(projectId, direction) {
      const project = appState.workProjects.find(p => p.id === projectId);
      if (!project) return;

      const newStage = project.currentStage + direction;
      if (newStage >= 0 && newStage < appState.workProjectStages.length) {
        project.currentStage = newStage;
        project.updatedAt = new Date().toISOString();
        saveWorkProjects();
        renderStatic();
        showToast(`${appState.workProjectStages[newStage]} 단계로 이동`, 'success');
      }
    }
    window.moveWorkProjectStage = moveWorkProjectStage;

    /**
     * 프로젝트 삭제
     */
    function deleteWorkProject(projectId) {
      if (!confirm('이 프로젝트를 삭제하시겠습니까?')) return;

      // Soft-Delete: 삭제 기록 남기기 (동기화 시 부활 방지)
      appState.deletedIds.workProjects[projectId] = new Date().toISOString();
      appState.workProjects = appState.workProjects.filter(p => p.id !== projectId);
      if (appState.activeWorkProject === projectId) {
        appState.activeWorkProject = appState.workProjects.length > 0 ? appState.workProjects[0].id : null;
      }
      saveWorkProjects();
      renderStatic();
      showToast('프로젝트 삭제됨', 'success');
    }
    window.deleteWorkProject = deleteWorkProject;

    /**
     * 작업 항목 추가
     */
    function addWorkTask(projectId, stageIdx, subcatIdx, title, status) {
      const project = appState.workProjects.find(p => p.id === projectId);
      if (!project) return;

      project.stages[stageIdx].subcategories[subcatIdx].tasks.push({
        id: generateId(),
        title: title,
        status: status,
        logs: []
      });

      project.updatedAt = new Date().toISOString();
      saveWorkProjects();
      renderStatic();
      showToast('항목 추가됨', 'success');
    }

    /**
     * 작업 상태 순환
     */
    function cycleWorkTaskStatus(projectId, stageIdx, subcatIdx, taskIdx) {
      const project = appState.workProjects.find(p => p.id === projectId);
      if (!project) return;

      const task = project.stages[stageIdx].subcategories[subcatIdx].tasks[taskIdx];
      const statuses = ['not-started', 'in-progress', 'completed', 'blocked'];
      const currentIdx = statuses.indexOf(task.status);
      task.status = statuses[(currentIdx + 1) % statuses.length];

      // 완료로 변경 시 자동 로그
      if (task.status === 'completed') {
        const today = new Date().toLocaleDateString('ko-KR', { month: '2-digit', day: '2-digit' });
        task.logs.push({ date: today, content: '✓ 완료' });
      }

      project.updatedAt = new Date().toISOString();
      saveWorkProjects();
      renderStatic();
    }
    window.cycleWorkTaskStatus = cycleWorkTaskStatus;

    /**
     * 소분류 완료 체크박스 토글 (완료↔미시작)
     */
    function toggleWorkTaskComplete(projectId, stageIdx, subcatIdx, taskIdx) {
      const project = appState.workProjects.find(p => p.id === projectId);
      if (!project) return;

      const task = project.stages[stageIdx].subcategories[subcatIdx].tasks[taskIdx];
      const wasCompleted = task.status === 'completed';
      task.status = wasCompleted ? 'not-started' : 'completed';

      // 완료로 변경 시 자동 로그
      if (!wasCompleted) {
        const today = new Date().toLocaleDateString('ko-KR', { month: '2-digit', day: '2-digit' });
        task.logs.push({ date: today, content: '✓ 완료' });
      }

      project.updatedAt = new Date().toISOString();
      saveWorkProjects();
      renderStatic();
      showToast(wasCompleted ? '미시작으로 변경' : '완료!', 'success');
    }
    window.toggleWorkTaskComplete = toggleWorkTaskComplete;

    /**
     * 중분류 완료 체크박스 토글 (하위 전체 완료↔미시작)
     */
    function toggleSubcategoryComplete(projectId, stageIdx, subcatIdx) {
      const project = appState.workProjects.find(p => p.id === projectId);
      if (!project) return;

      const subcat = project.stages[stageIdx].subcategories[subcatIdx];
      if (!subcat || subcat.tasks.length === 0) {
        showToast('항목이 없습니다', 'warning');
        return;
      }

      // 모두 완료이면 → 전부 미시작, 아니면 → 전부 완료
      const allCompleted = subcat.tasks.every(t => t.status === 'completed');
      const today = new Date().toLocaleDateString('ko-KR', { month: '2-digit', day: '2-digit' });

      subcat.tasks.forEach(task => {
        if (allCompleted) {
          task.status = 'not-started';
        } else {
          if (task.status !== 'completed') {
            task.status = 'completed';
            task.logs.push({ date: today, content: '✓ 완료' });
          }
        }
      });

      project.updatedAt = new Date().toISOString();
      saveWorkProjects();
      renderStatic();
      showToast(allCompleted ? '중분류 전체 미시작으로 변경' : '중분류 전체 완료!', 'success');
    }
    window.toggleSubcategoryComplete = toggleSubcategoryComplete;

    /**
     * 작업 삭제
     */
    function deleteWorkTask(projectId, stageIdx, subcatIdx, taskIdx) {
      if (!confirm('이 항목을 삭제하시겠습니까?')) return;

      const project = appState.workProjects.find(p => p.id === projectId);
      if (!project) return;

      project.stages[stageIdx].subcategories[subcatIdx].tasks.splice(taskIdx, 1);
      project.updatedAt = new Date().toISOString();
      saveWorkProjects();
      renderStatic();
    }
    window.deleteWorkTask = deleteWorkTask;

    /**
     * 진행 로그 추가
     */
    function addWorkLog(projectId, stageIdx, subcatIdx, taskIdx, content) {
      const project = appState.workProjects.find(p => p.id === projectId);
      if (!project) return;

      const task = project.stages[stageIdx].subcategories[subcatIdx].tasks[taskIdx];
      const today = new Date().toLocaleDateString('ko-KR', { month: '2-digit', day: '2-digit' });

      task.logs.push({
        date: today,
        content: content
      });

      project.updatedAt = new Date().toISOString();
      saveWorkProjects();
      renderStatic();
      showToast('기록 추가됨', 'success');
    }

    /**
     * 로그 삭제
     */
    function deleteWorkLog(projectId, stageIdx, subcatIdx, taskIdx, logIdx) {
      if (!confirm('이 기록을 삭제하시겠습니까?')) return;
      const project = appState.workProjects.find(p => p.id === projectId);
      if (!project) return;

      project.stages[stageIdx].subcategories[subcatIdx].tasks[taskIdx].logs.splice(logIdx, 1);
      project.updatedAt = new Date().toISOString();
      saveWorkProjects();
      renderStatic();
    }
    window.deleteWorkLog = deleteWorkLog;

    /**
     * 노션/슬랙용 복사
     */
    function copyWorkProjectToClipboard(projectId) {
      const project = appState.workProjects.find(p => p.id === projectId);
      if (!project) return;

      let text = `📋 ${project.name}\n`;
      text += `현재 단계: ${appState.workProjectStages[project.currentStage]}\n`;
      text += `─────────────────\n\n`;

      project.stages.forEach((stage, idx) => {
        const hasContent = stage.subcategories && stage.subcategories.some(s => s.tasks.length > 0);
        if (!hasContent) return;

        const stageName = appState.workProjectStages[idx];
        const isCurrent = idx === project.currentStage;
        text += `${isCurrent ? '▶ ' : ''}${idx + 1}. ${stageName}\n`;

        stage.subcategories.forEach(subcat => {
          if (subcat.tasks.length === 0) return;
          text += `\n  📁 ${subcat.name}\n`;

          subcat.tasks.forEach(task => {
            const statusIcon = task.status === 'completed' ? '✓' : task.status === 'in-progress' ? '→' : task.status === 'blocked' ? '⏸' : '○';
            text += `    ${statusIcon} ${task.title}\n`;
            task.logs.forEach(log => {
              text += `       └ ${log.date}: ${log.content}\n`;
            });
          });
        });
        text += '\n';
      });

      navigator.clipboard.writeText(text).then(() => {
        showToast('클립보드에 복사됨!', 'success');
      }).catch(err => {
        console.error('복사 실패:', err);
        showToast('복사 실패', 'error');
      });
    }
    window.copyWorkProjectToClipboard = copyWorkProjectToClipboard;

    /**
     * 프로젝트 저장
     */
    function saveWorkProjects() {
      if (!appState.user) {
        localStorage.setItem('navigator-work-projects', JSON.stringify(appState.workProjects));
      }
      // Firebase 동기화 (로그인된 경우)
      if (appState.user) {
        syncToFirebase();
      }
    }

    /**
     * 프로젝트 불러오기
     */
    function loadWorkProjects() {
      const saved = localStorage.getItem('navigator-work-projects');
      if (saved) {
        try {
          appState.workProjects = JSON.parse(saved);

          // 기존 프로젝트 마이그레이션: 단계에 name 필드 추가
          let needsSave = false;
          appState.workProjects.forEach(project => {
            if (project.stages) {
              project.stages.forEach((stage, idx) => {
                if (!stage.name) {
                  // 기존 프로젝트: 전역 배열에서 이름 가져오기
                  stage.name = appState.workProjectStages[idx] || `단계 ${idx + 1}`;
                  needsSave = true;
                }
              });
            }
          });
          if (needsSave) {
            saveWorkProjects();
            console.log('프로젝트 단계 마이그레이션 완료');
          }

          // 첫 프로젝트 자동 선택
          if (appState.workProjects.length > 0 && !appState.activeWorkProject) {
            appState.activeWorkProject = appState.workProjects[0].id;
          }
        } catch (e) {
          console.error('프로젝트 로드 실패:', e);
          appState.workProjects = [];
        }
      }
    }

    // ============================================
    // PWA 및 알림 기능
    // ============================================

    let deferredPrompt = null; // PWA 설치 프롬프트 저장

    /**
     * Service Worker 등록
     */
    async function registerServiceWorker() {
      if ('serviceWorker' in navigator) {
        try {
          const registration = await navigator.serviceWorker.register('./sw.js');
          console.log('Service Worker 등록 성공:', registration.scope);
          // SW 업데이트 감지 시 알림
          registration.addEventListener('updatefound', () => {
            const newWorker = registration.installing;
            if (newWorker) {
              newWorker.addEventListener('statechange', () => {
                if (newWorker.state === 'activated' && navigator.serviceWorker.controller) {
                  showToast('앱이 업데이트되었습니다. 새로고침하면 반영됩니다.', 'success');
                }
              });
            }
          });
        } catch (error) {
          console.error('Service Worker 등록 실패:', error);
        }
      }
    }

    /**
     * 알림 권한 요청
     */
    async function requestNotificationPermission() {
      if (!('Notification' in window)) {
        showToast('이 브라우저는 알림을 지원하지 않습니다', 'error');
        return;
      }

      // 버튼 로딩 상태 표시
      const btn = document.querySelector('.notification-btn:not(:disabled)');
      if (btn) {
        btn.textContent = '...';
        btn.disabled = true;
      }

      try {
        const permission = await Notification.requestPermission();
        appState.notificationPermission = permission;

        if (permission === 'granted') {
          showToast('알림이 활성화되었습니다!', 'success');
          // 테스트 알림
          setTimeout(() => {
            showNotification('Navigator 알림 활성화', '마감 임박 시 알림을 받을 수 있습니다');
          }, 500);
        } else if (permission === 'denied') {
          showToast('알림이 차단되었습니다. 브라우저 설정에서 허용해주세요', 'error');
        } else {
          showToast('알림 권한 요청이 취소되었습니다', 'warning');
        }
      } catch (error) {
        console.error('알림 권한 요청 실패:', error);
        showToast('알림 권한 요청 중 오류가 발생했습니다', 'error');
      } finally {
        // 항상 UI 갱신
        renderStatic();
      }
    }

    /**
     * 알림 표시
     */
    function showNotification(title, body) {
      if (Notification.permission === 'granted') {
        const options = {
          body: body,
          icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect fill="%23667eea" width="100" height="100" rx="20"/><text x="50" y="68" font-size="50" text-anchor="middle" fill="white">⚡</text></svg>',
          badge: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect fill="%23f5576c" width="100" height="100" rx="50"/></svg>',
          vibrate: [100, 50, 100],
          tag: 'navigator-reminder',
          renotify: true
        };

        new Notification(title, options);
      }
    }

    /**
     * 마감 임박 작업 확인 및 알림 (5분마다 실행)
     */
    function checkDeadlinesAndNotify() {
      if (Notification.permission !== 'granted') return;

      const now = new Date();
      const notifiedKey = 'navigator-notified-tasks';
      let notifiedTasks = [];

      try {
        notifiedTasks = JSON.parse(localStorage.getItem(notifiedKey) || '[]');
      } catch (e) {
        notifiedTasks = [];
      }

      // 작업 마감 알림
      appState.tasks.forEach(task => {
        if (task.completed || !task.deadline) return;

        const deadline = new Date(task.deadline);
        const hoursLeft = (deadline - now) / (1000 * 60 * 60);
        const daysLeft = hoursLeft / 24;
        const taskNotifyKey = `${task.id}`;

        // D-1 알림 (마감 하루 전, 오전에 한 번)
        if (daysLeft > 0.5 && daysLeft <= 1.5 && !notifiedTasks.includes(taskNotifyKey + '-d1')) {
          const currentHour = now.getHours();
          if (currentHour >= 8 && currentHour < 12) {  // 오전 8시~12시 사이
            showNotification(
              '📅 내일이 마감일!',
              `"${task.title}" - D-1`
            );
            notifiedTasks.push(taskNotifyKey + '-d1');
          }
        }

        // D-Day 알림 (마감 당일, 오전에 한 번)
        if (daysLeft > 0 && daysLeft <= 0.5 && !notifiedTasks.includes(taskNotifyKey + '-dday')) {
          const currentHour = now.getHours();
          if (currentHour >= 8 && currentHour < 12) {  // 오전 8시~12시 사이
            showNotification(
              '🔥 오늘이 마감일!',
              `"${task.title}" - D-Day`
            );
            notifiedTasks.push(taskNotifyKey + '-dday');
          }
        }

        // 3시간 전 알림 (한 번만)
        if (hoursLeft > 0 && hoursLeft <= 3 && !notifiedTasks.includes(taskNotifyKey + '-3h')) {
          showNotification(
            '🚨 마감 3시간 전!',
            `"${task.title}" 마감이 임박했습니다`
          );
          notifiedTasks.push(taskNotifyKey + '-3h');
        }

        // 1시간 전 알림 (한 번만)
        if (hoursLeft > 0 && hoursLeft <= 1 && !notifiedTasks.includes(taskNotifyKey + '-1h')) {
          showNotification(
            '⚠️ 마감 1시간 전!',
            `"${task.title}" 지금 바로 시작하세요`
          );
          notifiedTasks.push(taskNotifyKey + '-1h');
        }
      });

      // 취침 알림 체크
      if (appState.settings.bedtimeReminder) {
        checkBedtimeReminder(now, notifiedTasks);
      }

      // 24시간 이상 된 알림 기록은 삭제
      const recentNotified = notifiedTasks.slice(-100);
      localStorage.setItem(notifiedKey, JSON.stringify(recentNotified));
    }

    /**
     * 취침 알림 체크
     */
    function checkBedtimeReminder(now, notifiedTasks) {
      const bedtimeStr = appState.settings.targetBedtime;
      const [bedHour, bedMinute] = bedtimeStr.split(':').map(Number);
      const reminderMinutes = appState.settings.bedtimeReminderMinutes || 30;

      // 오늘 취침 시간
      const bedtime = new Date(now);
      bedtime.setHours(bedHour, bedMinute, 0, 0);

      // 만약 현재 시간이 취침 시간 이후면, 이미 지난 것이므로 무시
      if (now > bedtime) return;

      const minutesUntilBed = (bedtime - now) / (1000 * 60);
      const todayKey = `bedtime-${now.toDateString()}`;

      // 설정된 시간 전 알림 (한 번만)
      if (minutesUntilBed > 0 && minutesUntilBed <= reminderMinutes && !notifiedTasks.includes(todayKey)) {
        const incompleteTasks = appState.tasks.filter(t => !t.completed).length;
        let message = '';

        if (incompleteTasks > 0) {
          message = `아직 ${incompleteTasks}개 작업이 남았어요. 마무리하고 잠자리에 들어요!`;
        } else {
          message = '오늘 목표를 다 달성했어요! 푹 쉬세요 😴';
        }

        showNotification(
          `🌙 취침 ${reminderMinutes}분 전!`,
          message
        );
        notifiedTasks.push(todayKey);
      }
    }

    /**
     * PWA 설치 프롬프트 처리
     */
    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
      // 설치 배너 표시
      const banner = document.getElementById('install-banner');
      if (banner) banner.classList.add('show');
    });

    /**
     * PWA 설치
     */
    async function installPWA() {
      if (!deferredPrompt) return;

      deferredPrompt.prompt();
      const { outcome } = await deferredPrompt.userChoice;

      if (outcome === 'accepted') {
        showToast('앱이 설치되었습니다!', 'success');
      }

      deferredPrompt = null;
      const banner = document.getElementById('install-banner');
      if (banner) banner.classList.remove('show');
    }

    /**
     * 설치 배너 닫기
     */
    function closeInstallBanner() {
      const banner = document.getElementById('install-banner');
      if (banner) banner.classList.remove('show');
      deferredPrompt = null;
    }

    window.requestNotificationPermission = requestNotificationPermission;
    window.installPWA = installPWA;
    window.closeInstallBanner = closeInstallBanner;

    // ============================================
    // 키보드 단축키
    // ============================================

    let showShortcutsHelp = false;

    /**
     * 단축키 도움말 토글
     */
    function toggleShortcutsHelp() {
      showShortcutsHelp = !showShortcutsHelp;
      const helpEl = document.getElementById('shortcuts-help');
      if (helpEl) {
        helpEl.classList.toggle('show', showShortcutsHelp);
      }
    }

    /**
     * 모달 포커스 트랩 - Tab 키가 모달 내부에서만 순환
     */
    function trapFocusInModal(modal, e) {
      const focusable = modal.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
      if (focusable.length === 0) return;
      const first = focusable[0];
      const last = focusable[focusable.length - 1];
      if (e.shiftKey) {
        if (document.activeElement === first) { e.preventDefault(); last.focus(); }
      } else {
        if (document.activeElement === last) { e.preventDefault(); first.focus(); }
      }
    }

    /**
     * 키보드 이벤트 핸들러
     */
    document.addEventListener('keydown', (e) => {
      // Tab 키: 모달 포커스 트랩
      if (e.key === 'Tab') {
        const activeModal = document.querySelector('.modal-overlay') || document.querySelector('.work-modal.show');
        if (activeModal) { trapFocusInModal(activeModal, e); return; }
      }

      // Escape 키: 모달/드롭다운 닫기 (어디서든 동작)
      if (e.key === 'Escape') {
        if (appState.showSettings) { closeSettings(); render(); return; }
        if (appState.showOnboarding) { appState.showOnboarding = false; render(); return; }
        if (appState.showDetailedAdd) { appState.showDetailedAdd = false; appState.editingTaskId = null; render(); return; }
        // 알림 드롭다운 닫기
        const notifDropdown = document.getElementById('notification-dropdown');
        if (notifDropdown && notifDropdown.classList.contains('show')) { notifDropdown.classList.remove('show'); return; }
        // 입력 필드에서 blur
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') { e.target.blur(); }
        return;
      }

      // 입력 필드에서는 단축키 비활성화
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
        return;
      }

      // Ctrl/Cmd + 키 조합
      if (e.ctrlKey || e.metaKey) {
        switch (e.key.toLowerCase()) {
          case 'n': // 새 작업 추가
            e.preventDefault();
            const quickInput = document.getElementById('quick-add-input');
            if (quickInput) {
              quickInput.focus();
            }
            break;
          case 'f': // 검색
            e.preventDefault();
            const searchInput = document.getElementById('search-input');
            if (searchInput) {
              searchInput.focus();
            }
            break;
          case 'd': // Next Action 완료
            e.preventDefault();
            const filteredTasks = getFilteredTasks();
            if (filteredTasks.length > 0) {
              completeTask(filteredTasks[0].id);
            }
            break;
          case '/': // 단축키 도움말
            e.preventDefault();
            toggleShortcutsHelp();
            break;
        }
        return;
      }

      // 단일 키
      switch (e.key.toLowerCase()) {
        case 'n': // 새 작업 추가 (Ctrl 없이도 동작)
          const quickInputN = document.getElementById('quick-add-input');
          if (quickInputN) {
            e.preventDefault();
            quickInputN.focus();
          }
          break;
        case '1':
          switchTab('action');
          break;
        case '2':
          switchTab('work');
          break;
        case '3':
          switchTab('events');
          break;
        case '4':
          switchTab('dashboard');
          break;
        case '5':
          switchTab('all');
          break;
        case '6':
          switchTab('history');
          break;
        case '7':
          switchTab('commute');
          break;
        case 's':
          toggleShuttle();
          break;
        case '?':
          toggleShortcutsHelp();
          break;
        case 'escape':
          if (showShortcutsHelp) {
            toggleShortcutsHelp();
          }
          if (appState.showDetailedAdd) {
            cancelEdit();
          }
          break;
      }
    });

    window.toggleShortcutsHelp = toggleShortcutsHelp;

    /**
     * 더보기 메뉴 토글
     */
    function toggleMoreMenu(e) {
      if (e) e.stopPropagation();
      appState.moreMenuOpen = !appState.moreMenuOpen;
      const menu = document.getElementById('more-menu');
      if (menu) {
        menu.classList.toggle('show', appState.moreMenuOpen);
      }
    }

    // 외부 클릭 시 더보기 메뉴 닫기
    document.addEventListener('click', (e) => {
      const dropdown = document.querySelector('.tab-more-dropdown');
      const menu = document.getElementById('more-menu');
      if (appState.moreMenuOpen && dropdown && !dropdown.contains(e.target)) {
        appState.moreMenuOpen = false;
        if (menu) menu.classList.remove('show');
      }
    });

    window.toggleMoreMenu = toggleMoreMenu;

    // 마감 알림 드롭다운 토글
    function toggleNotificationDropdown(e) {
      if (e) e.stopPropagation();
      const dropdown = document.getElementById('notification-dropdown');
      if (dropdown) {
        dropdown.classList.toggle('show');
      }
    }
    window.toggleNotificationDropdown = toggleNotificationDropdown;

    // 외부 클릭 시 알림 드롭다운 닫기
    document.addEventListener('click', (e) => {
      const wrapper = document.querySelector('.notification-dropdown-wrapper');
      const dropdown = document.getElementById('notification-dropdown');
      if (dropdown && dropdown.classList.contains('show') && wrapper && !wrapper.contains(e.target)) {
        dropdown.classList.remove('show');
      }
    });

    // ============================================
    // 포모도로 타이머
    // ============================================

    let pomodoroInterval = null;

    /**
     * 포모도로 시작
     */
    function startPomodoro(taskId = null) {
      const pomo = appState.pomodoro;

      if (taskId) {
        pomo.currentTaskId = taskId;
      } else {
        // Next Action 사용
        const filtered = getFilteredTasks();
        if (filtered.length > 0) {
          pomo.currentTaskId = filtered[0].id;
        }
      }

      pomo.isRunning = true;
      pomo.isBreak = false;
      pomo.timeLeft = pomo.workDuration;

      if (pomodoroInterval) clearInterval(pomodoroInterval);
      pomodoroInterval = setInterval(pomodoroTick, 1000);

      renderStatic();
      showToast('포모도로 시작! 25분 집중하세요', 'success');

      if (navigator.vibrate) {
        navigator.vibrate(100);
      }
    }

    /**
     * 포모도로 일시정지
     */
    function pausePomodoro() {
      appState.pomodoro.isRunning = false;
      if (pomodoroInterval) {
        clearInterval(pomodoroInterval);
        pomodoroInterval = null;
      }
      renderStatic();
    }

    /**
     * 포모도로 재개
     */
    function resumePomodoro() {
      appState.pomodoro.isRunning = true;
      pomodoroInterval = setInterval(pomodoroTick, 1000);
      renderStatic();
    }

    /**
     * 포모도로 중지
     */
    function stopPomodoro() {
      const pomo = appState.pomodoro;
      pomo.isRunning = false;
      pomo.isBreak = false;
      pomo.timeLeft = pomo.workDuration;
      pomo.currentTaskId = null;

      if (pomodoroInterval) {
        clearInterval(pomodoroInterval);
        pomodoroInterval = null;
      }

      renderStatic();
      showToast('포모도로 중지됨', 'error');
    }

    /**
     * 휴식 건너뛰기
     */
    function skipBreak() {
      const pomo = appState.pomodoro;
      pomo.isBreak = false;
      pomo.timeLeft = pomo.workDuration;
      renderStatic();
      showToast('휴식 건너뜀! 다시 집중하세요', 'success');
    }

    /**
     * 포모도로 틱 (1초마다 실행)
     */
    function pomodoroTick() {
      const pomo = appState.pomodoro;

      if (pomo.timeLeft > 0) {
        pomo.timeLeft--;
        updatePomodoroDisplay();
      } else {
        // 시간 종료
        if (pomo.isBreak) {
          // 휴식 종료 → 작업 시작
          pomo.isBreak = false;
          pomo.timeLeft = pomo.workDuration;
          showNotification('휴식 끝!', '다시 집중할 시간입니다');
          showToast('휴식 끝! 다시 집중하세요', 'success');
        } else {
          // 작업 종료 → 휴식 시작
          pomo.completedPomodoros++;
          pomo.isBreak = true;
          pomo.timeLeft = pomo.breakDuration;

          // 연결된 태스크에 25분 집중 시간 자동 기록
          if (pomo.currentTaskId) {
            const linkedTask = appState.tasks.find(t => t.id === pomo.currentTaskId);
            if (linkedTask) {
              const prevTime = parseInt(linkedTask.actualTime) || 0;
              linkedTask.actualTime = prevTime + 25;
              saveState();
              showNotification('포모도로 완료!', `${escapeHtml(linkedTask.title)}에 25분 기록`);
              showToast(`포모도로 완료! ${escapeHtml(linkedTask.title)}에 25분 기록 (${pomo.completedPomodoros}회)`, 'success');
            } else {
              // 태스크가 삭제된 경우
              pomo.currentTaskId = null;
              showNotification('포모도로 완료!', '5분 휴식하세요');
              showToast(`포모도로 완료! (${pomo.completedPomodoros}회) 5분 휴식`, 'success');
            }
          } else {
            showNotification('포모도로 완료!', '5분 휴식하세요');
            showToast(`포모도로 완료! (${pomo.completedPomodoros}회) 5분 휴식`, 'success');
          }
        }

        if (navigator.vibrate) {
          navigator.vibrate([200, 100, 200, 100, 200]);
        }

        renderStatic();
      }
    }

    /**
     * 포모도로 시간 표시 업데이트 (전체 렌더링 없이)
     */
    function updatePomodoroDisplay() {
      const timeEl = document.getElementById('pomodoro-time');
      if (timeEl) {
        timeEl.textContent = formatPomodoroTime(appState.pomodoro.timeLeft);
      }
    }

    /**
     * 포모도로 시간 포맷팅
     */
    function formatPomodoroTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    window.startPomodoro = startPomodoro;
    window.pausePomodoro = pausePomodoro;
    window.resumePomodoro = resumePomodoro;
    window.stopPomodoro = stopPomodoro;
    window.skipBreak = skipBreak;
    window.formatPomodoroTime = formatPomodoroTime;

  </script>
  <!-- 외부 모듈 (메인 스크립트 함수 정의 후, 초기화 전 로드) -->
  <script src="js/commute.js"></script>
  <script src="js/rhythm.js"></script>
  <script>
    // ============================================
    // 앱 초기화 (모든 모듈 로드 완료 후)
    // ============================================
    loadState();

    // 알림 권한 상태 확인
    if ('Notification' in window) {
      appState.notificationPermission = Notification.permission;
    }

    // 오프라인 상태 표시
    function updateOnlineStatus() {
      let indicator = document.getElementById('offline-indicator');

      if (!navigator.onLine) {
        if (!indicator) {
          indicator = document.createElement('div');
          indicator.id = 'offline-indicator';
          indicator.className = 'offline-indicator';
          indicator.innerHTML = '📴 오프라인 모드 - 변경사항은 기기에 저장됩니다';
          document.body.prepend(indicator);
        }
        indicator.classList.remove('hidden');
      } else {
        if (indicator) {
          indicator.classList.add('hidden');
          setTimeout(() => indicator.remove(), 300);
        }
      }
    }

    window.addEventListener('online', () => {
      updateOnlineStatus();
      // 온라인 복귀 시 즉시 동기화 (오프라인 중 쌓인 변경사항 반영)
      if (appState.user) {
        showToast('온라인 복귀 - 동기화 중...', 'success');
        syncToFirebase(true);
      }
    });
    window.addEventListener('offline', () => {
      updateOnlineStatus();
      showToast('오프라인 모드 - 변경사항은 기기에 저장됩니다', 'warning');
    });
    updateOnlineStatus();

    // 페이지 종료 시 localStorage만 동기 저장 (async Firebase는 브라우저가 기다리지 않음)
    window.addEventListener('beforeunload', () => {
      _doSaveStateLocalOnly();
    });

    renderStatic();
    registerServiceWorker();

    // 기존 interval 정리 후 재등록 (중복 방지)
    if (window._navIntervals) window._navIntervals.forEach(id => clearInterval(id));
    window._navIntervals = [
      setInterval(updateTime, 1000),
      setInterval(checkDeadlinesAndNotify, 5 * 60 * 1000), // 5분마다 마감 체크
      // 반복 태스크 일일 초기화: 자정 넘김 감지 (1분마다 날짜 변경 체크)
      setInterval(() => {
        let changed = false;
        if (checkDailyReset()) {
          recomputeTodayStats();
          saveState(); // 모바일에서 beforeunload 미발생 시 데이터 유실 방지
          changed = true;
        }
        if (checkRhythmDayChange()) {
          changed = true;
        }
        if (changed) {
          renderStatic();
          showToast('🔄 새로운 하루! 반복 태스크가 초기화되었습니다', 'info');
        }
      }, 60000)
    ];
    checkDeadlinesAndNotify(); // 초기 실행

    // 탭 전환/숨김 시 대기 중인 Firebase 동기화 즉시 실행 + 탭 복귀 시 일일 초기화
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        // 탭 전환/앱 최소화: 대기 중인 Firebase 동기화 즉시 플러시
        if (appState.user && syncDebounceTimer) {
          clearTimeout(syncDebounceTimer);
          syncDebounceTimer = null;
          _doSyncToFirebase();
        }
      } else {
        // 탭 복귀: 반복 태스크 일일 초기화 체크
        let changed = false;
        if (checkDailyReset()) {
          recomputeTodayStats();
          saveState(); // 모바일에서 beforeunload 미발생 시 데이터 유실 방지
          changed = true;
        }
        if (checkRhythmDayChange()) {
          changed = true;
        }
        if (changed) {
          renderStatic();
          showToast('🔄 새로운 하루! 반복 태스크가 초기화되었습니다', 'info');
        }
      }
    });

    // 주간 리뷰 체크 (일요일 저녁)
    setTimeout(() => checkWeeklyReview(), 3000);

    // ============================================
    // telegram-event-bot 연동: URL 파라미터 import
    // ============================================
    function checkUrlImport() {
      const urlParams = new URLSearchParams(window.location.search);
      const importData = urlParams.get('import');
      const autoImport = urlParams.get('autoImport') === 'true';

      if (importData) {
        try {
          // Unicode 안전한 Base64 디코딩
          const decoded = decodeURIComponent(escape(atob(importData)));
          const taskData = JSON.parse(decoded);

          if (autoImport) {
            // 자동 추가 — 확인 모달 없이 바로 Task 생성
            importTaskDirectly(taskData);
          } else {
            showImportConfirmModal(taskData);
          }

          // URL에서 파라미터 제거 (히스토리 정리)
          window.history.replaceState({}, document.title, window.location.pathname);
        } catch (error) {
          console.error('Import 파싱 오류:', error);
          showToast('잘못된 import 데이터입니다', 'error');
        }
      }
    }

    // autoImport용 — 확인 없이 바로 Task 추가
    function importTaskDirectly(taskData) {
      try {
        const newTask = {
          id: generateId(),
          title: taskData.title || '이벤트 참여',
          category: taskData.category || '부업',
          estimatedTime: taskData.estimatedTime || 10,
          expectedRevenue: taskData.expectedRevenue || null,
          deadline: taskData.deadline || null,
          description: taskData.description || null,
          link: taskData.link || null,
          completed: false,
          pinned: false,
          source: taskData.source || null,
          createdAt: new Date().toISOString()
        };

        appState.tasks.unshift(newTask);
        saveState();
        renderStatic();
        showToast('✅ Task가 자동으로 추가되었습니다!', 'success');

        if (appState.user) {
          syncToFirebase();
        }
      } catch (error) {
        console.error('자동 Task 추가 오류:', error);
        showToast('Task 추가 실패', 'error');
      }
    }

    function showImportConfirmModal(taskData) {
      const modal = document.createElement('div');
      modal.className = 'modal-overlay';
      modal.id = 'import-confirm-modal';
      modal.innerHTML = `
        <div class="modal" style="max-width: 500px;">
          <div class="modal-header">
            <h2 style="display: flex; align-items: center; gap: 10px;">
              <span>📥</span> 이벤트에서 Task 추가
            </h2>
            <button class="modal-close" onclick="closeImportModal()">&times;</button>
          </div>
          <div class="modal-body" style="padding: 20px;">
            <div style="background: var(--bg-secondary); border-radius: 12px; padding: 15px; margin-bottom: 15px;">
              <div style="font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 5px;">제목</div>
              <div style="font-size: 1.1rem; font-weight: bold;">${escapeHtml(taskData.title || '제목 없음')}</div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
              <div style="background: var(--bg-secondary); border-radius: 8px; padding: 10px;">
                <div style="font-size: 0.75rem; color: var(--text-secondary);">카테고리</div>
                <div>${escapeHtml(taskData.category || '부업')}</div>
              </div>
              <div style="background: var(--bg-secondary); border-radius: 8px; padding: 10px;">
                <div style="font-size: 0.75rem; color: var(--text-secondary);">마감일</div>
                <div>${taskData.deadline || '없음'}</div>
              </div>
              <div style="background: var(--bg-secondary); border-radius: 8px; padding: 10px;">
                <div style="font-size: 0.75rem; color: var(--text-secondary);">예상 시간</div>
                <div>${taskData.estimatedTime || 10}분</div>
              </div>
              <div style="background: var(--bg-secondary); border-radius: 8px; padding: 10px;">
                <div style="font-size: 0.75rem; color: var(--text-secondary);">보상</div>
                <div style="color: var(--accent-green);">${taskData.expectedRevenue || '-'}</div>
              </div>
            </div>

            ${taskData.description ? `
              <div style="background: var(--bg-secondary); border-radius: 8px; padding: 10px; margin-bottom: 15px;">
                <div style="font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 5px;">설명</div>
                <div style="font-size: 0.9rem; max-height: 100px; overflow-y: auto;">${escapeHtml(taskData.description)}</div>
              </div>
            ` : ''}

            ${taskData.link ? `
              <div style="margin-bottom: 15px;">
                <a href="${escapeHtml(taskData.link)}" target="_blank" style="color: var(--accent-blue); font-size: 0.9rem;">
                  🔗 ${escapeHtml(taskData.link.substring(0, 50))}...
                </a>
              </div>
            ` : ''}

            <div style="background: rgba(74, 158, 255, 0.1); border-radius: 8px; padding: 10px; font-size: 0.85rem; color: var(--text-secondary);">
              📢 출처: ${escapeHtml(taskData.source?.channel || 'telegram-event-bot')}
            </div>
          </div>
          <div class="modal-footer" style="display: flex; gap: 10px; justify-content: flex-end; padding: 15px 20px; border-top: 1px solid var(--border-color);">
            <button class="btn btn-secondary" onclick="closeImportModal()">취소</button>
            <button class="btn btn-primary" onclick="confirmImportTask()">✅ Task 추가</button>
          </div>
        </div>
      `;

      // 데이터 저장
      modal.dataset.taskData = JSON.stringify(taskData);
      document.body.appendChild(modal);

      // 애니메이션
      requestAnimationFrame(() => modal.classList.add('active'));
    }

    function closeImportModal() {
      const modal = document.getElementById('import-confirm-modal');
      if (modal) {
        modal.classList.remove('active');
        setTimeout(() => modal.remove(), 300);
      }
    }

    async function confirmImportTask() {
      const modal = document.getElementById('import-confirm-modal');
      if (!modal) return;

      try {
        const taskData = JSON.parse(modal.dataset.taskData);

        // 새 Task 생성
        const newTask = {
          id: generateId(),
          title: taskData.title || '이벤트 참여',
          category: taskData.category || '부업',
          estimatedTime: taskData.estimatedTime || 10,
          expectedRevenue: taskData.expectedRevenue || null,
          deadline: taskData.deadline || null,
          description: taskData.description || null,
          link: taskData.link || null,
          completed: false,
          pinned: false,
          // telegram-event-bot 연동 정보
          source: taskData.source || null,
          createdAt: new Date().toISOString()
        };

        appState.tasks.unshift(newTask);
        saveState();
        renderStatic();

        closeImportModal();
        showToast('✅ Task가 추가되었습니다!', 'success');

        // Firebase 동기화
        if (appState.user) {
          syncToFirebase();
        }
      } catch (error) {
        console.error('Task 추가 오류:', error);
        showToast('Task 추가 실패', 'error');
      }
    }

    // Task 완료 시 연결된 이벤트 상태 업데이트 (Supabase + Firestore 역동기화)
    async function updateLinkedEventStatus(task, participated) {
      if (!task.source || task.source.type !== 'telegram-event') return;

      const eventId = task.source.eventId;
      if (!eventId) return;

      // 1. Supabase REST API로 participated 상태 직접 업데이트 (역동기화)
      try {
        const response = await fetch(
          `${TG_SUPABASE_URL}/rest/v1/telegram_messages?id=eq.${eventId}`,
          {
            method: 'PATCH',
            headers: {
              'Content-Type': 'application/json',
              'apikey': TG_SUPABASE_KEY,
              'Authorization': `Bearer ${TG_SUPABASE_KEY}`,
              'Prefer': 'return=minimal'
            },
            body: JSON.stringify({ participated: participated })
          }
        );

        if (response.ok) {
          console.log(`이벤트 ${eventId} Supabase 참여 상태 역동기화: ${participated}`);
        } else {
          console.error(`Supabase 역동기화 실패: ${response.status}`);
        }
      } catch (error) {
        console.error('Supabase 역동기화 실패:', error);
      }

      // 2. Firestore도 업데이트 (로그인 시에만)
      if (!appState.user) return;

      try {
        const userDoc = window.firebaseDoc(window.firebaseDb, 'users', appState.user.uid);
        const docSnap = await window.firebaseGetDoc(userDoc);

        if (docSnap.exists()) {
          const data = docSnap.data();
          const events = data.events || [];

          const eventIndex = events.findIndex(e => e.id === eventId);
          if (eventIndex !== -1) {
            events[eventIndex].participated = participated;

            await window.firebaseSetDoc(userDoc, {
              ...data,
              events: events
            });
          }
        }
      } catch (error) {
        console.error('Firestore 업데이트 실패:', error);
      }
    }

    // ============================================
    // 텔레그램 이벤트 목록 조회 + 선택 추가
    // Supabase REST API로 telegram_messages 직접 조회
    // ============================================
    const TG_SUPABASE_URL = 'https://hgygyilcrkygnvaquvko.supabase.co';
    const TG_SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhneWd5aWxjcmt5Z252YXF1dmtvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjkzMzE5NDIsImV4cCI6MjA4NDkwNzk0Mn0.iEVFwhZmfpjZqaaZyVVBiwK8GWNWfydXAtN-OaNsjFk';

    // 날짜 포맷: YYYY-MM-DD → "2월 15일" (D-day 포함)
    function formatTgDeadline(dateStr) {
      if (!dateStr) return '';
      const d = new Date(dateStr + 'T00:00:00');
      if (isNaN(d.getTime())) return dateStr;
      const month = d.getMonth() + 1;
      const day = d.getDate();
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const diff = Math.ceil((d - today) / (1000 * 60 * 60 * 24));
      let dday = '';
      if (diff < 0) dday = ' <span style="color:#f5576c">D+' + Math.abs(diff) + '</span>';
      else if (diff === 0) dday = ' <span style="color:#f5576c">D-Day</span>';
      else if (diff <= 3) dday = ' <span style="color:#ff9500">D-' + diff + '</span>';
      else dday = ' D-' + diff;
      return month + '월 ' + day + '일' + dday;
    }

    async function showTelegramEvents() {
      showToast('🤖 텔레그램 이벤트 불러오는 중...', 'info');

      try {
        // 봇 export 기준과 동일: 미참여 + (starred OR deadline 있음) + 미아카이브
        const query = [
          'select=id,content,original_channel,deadline,urls,analysis,starred,participated,date',
          'archived_date=is.null',
          'participated=eq.false',
          'or=(starred.eq.true,deadline.not.is.null)',
          'order=deadline.asc.nullslast,date.desc',
          'limit=50'
        ].join('&');

        const response = await fetch(
          `${TG_SUPABASE_URL}/rest/v1/telegram_messages?${query}`,
          {
            headers: {
              'apikey': TG_SUPABASE_KEY,
              'Authorization': `Bearer ${TG_SUPABASE_KEY}`
            }
          }
        );

        if (!response.ok) {
          throw new Error(`Supabase 응답 오류: ${response.status}`);
        }

        const messages = await response.json();

        // 이미 추가된 eventId 목록
        const importedEventIds = new Set(
          appState.tasks
            .filter(t => t.source && t.source.type === 'telegram-event' && t.source.eventId)
            .map(t => String(t.source.eventId))
        );

        // Navigator 형식으로 변환
        const allEvents = messages.map(msg => {
          const analysis = msg.analysis || {};
          const firstLine = (msg.content || '').split('\n')[0].trim();
          return {
            id: msg.id,
            title: analysis.title || (firstLine.length > 50 ? firstLine.substring(0, 50) : firstLine) || '제목 없음',
            description: analysis.summary || (msg.content || '').substring(0, 200),
            content: (msg.content || '').substring(0, 500),
            category: '부업',
            deadline: msg.deadline,
            link: (msg.urls || [])[0] || null,
            urls: msg.urls || [],
            estimatedTime: analysis.time_minutes || (analysis.time_required ? parseInt(analysis.time_required) || 10 : 10),
            expectedRevenue: analysis.reward_usd ? `$${analysis.reward_usd}` : (analysis.reward || null),
            channel: msg.original_channel,
            project: analysis.project || null,
            organizer: analysis.organizer || null,
            type: analysis.type || null,
            difficulty: analysis.difficulty || null,
            actionItems: analysis.action_items || [],
            starred: msg.starred,
            date: msg.date,
            _imported: importedEventIds.has(String(msg.id))
          };
        });

        const pendingEvents = allEvents.filter(e => !e._imported);
        showTelegramEventsModal(pendingEvents, messages.length);
      } catch (error) {
        console.error('텔레그램 이벤트 조회 실패:', error);
        showToast('이벤트 목록을 불러올 수 없습니다', 'error');
      }
    }

    function showTelegramEventsModal(pendingEvents, totalCount = 0) {
      // 기존 모달 제거
      const existing = document.getElementById('telegram-events-modal');
      if (existing) existing.remove();

      const importedCount = totalCount - pendingEvents.length;

      const modal = document.createElement('div');
      modal.className = 'modal-overlay';
      modal.id = 'telegram-events-modal';

      let listHtml = '';
      if (pendingEvents.length === 0) {
        if (totalCount === 0) {
          // 텔레그램 봇에서 이벤트를 아직 안 보낸 경우
          listHtml = `
            <div class="tg-event-empty">
              <div class="tg-event-empty-icon">🤖</div>
              <div style="font-size: 15px; margin-bottom: 8px;">텔레그램 연동 이벤트가 없습니다</div>
              <div style="font-size: 13px; color: var(--text-muted);">
                텔레그램 봇에서 이벤트를 보내면<br>여기에 자동으로 표시됩니다
              </div>
            </div>`;
        } else {
          // 전부 이미 추가된 경우
          listHtml = `
            <div class="tg-event-empty">
              <div class="tg-event-empty-icon">✅</div>
              <div style="font-size: 15px; margin-bottom: 8px;">모든 이벤트가 추가되었습니다</div>
              <div style="font-size: 13px; color: var(--text-muted);">
                총 ${totalCount}개 이벤트 중 ${importedCount}개 추가 완료
              </div>
            </div>`;
        }
      } else {
        listHtml = `
          <label class="tg-select-all" onclick="toggleAllTelegramEvents(this)">
            <input type="checkbox"> 전체 선택 (${pendingEvents.length}개)
          </label>
          <div class="tg-events-list">
            ${pendingEvents.map((event, i) => {
              const deadlineHtml = event.deadline ? formatTgDeadline(event.deadline) : '';
              const revenue = event.expectedRevenue ? escapeHtml(String(event.expectedRevenue)) : '';
              const channel = event.channel || '';
              const hasDetail = event.description || event.content || (event.actionItems && event.actionItems.length > 0) || (event.urls && event.urls.length > 0);
              return `
                <div class="tg-event-item" data-event-index="${i}">
                  <div class="tg-event-row">
                    <label class="tg-event-check" onclick="event.stopPropagation()">
                      <input type="checkbox" value="${i}">
                    </label>
                    <div class="tg-event-info" onclick="toggleTgEventDetail(this.closest('.tg-event-item'))" style="cursor:pointer">
                      <div class="tg-event-title">${event.starred ? '⭐ ' : ''}${escapeHtml(event.title || '제목 없음')}</div>
                      <div class="tg-event-meta">
                        ${deadlineHtml ? '<span>📅 ' + deadlineHtml + '</span>' : ''}
                        ${revenue ? '<span>💰 ' + revenue + '</span>' : ''}
                        ${channel ? '<span>📢 ' + escapeHtml(channel) + '</span>' : ''}
                        ${event.estimatedTime ? '<span>⏱ ' + event.estimatedTime + '분</span>' : ''}
                        ${event.type ? '<span>🏷 ' + escapeHtml(event.type) + '</span>' : ''}
                        ${event.difficulty ? '<span>' + (event.difficulty === 'easy' ? '🟢' : event.difficulty === 'hard' ? '🔴' : '🟡') + ' ' + escapeHtml(event.difficulty) + '</span>' : ''}
                      </div>
                    </div>
                    ${hasDetail ? '<button class="tg-event-expand" onclick="toggleTgEventDetail(this.closest(\'.tg-event-item\'))" title="상세 보기">▼</button>' : ''}
                  </div>
                  <div class="tg-event-detail" style="display:none">
                    ${event.description ? '<div style="font-size:13px;color:var(--text-secondary);margin-bottom:8px;white-space:pre-line">' + escapeHtml(event.description) + '</div>' : ''}
                    ${event.actionItems && event.actionItems.length > 0 ? '<div style="margin-bottom:8px"><div style="font-size:11px;color:var(--text-muted);margin-bottom:4px">할 일:</div>' + event.actionItems.map(a => '<div style="font-size:12px;padding:2px 0">• ' + escapeHtml(a) + '</div>').join('') + '</div>' : ''}
                    ${event.urls && event.urls.length > 0 ? '<div style="margin-bottom:4px">' + event.urls.map(u => '<a href="' + escapeHtml(u) + '" target="_blank" rel="noopener" style="font-size:12px;color:var(--accent-blue);display:block;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">🔗 ' + escapeHtml(u.substring(0, 60)) + '</a>').join('') + '</div>' : ''}
                    ${event.project ? '<span style="font-size:11px;color:var(--text-muted)">프로젝트: ' + escapeHtml(event.project) + '</span>' : ''}
                    ${event.organizer ? '<span style="font-size:11px;color:var(--text-muted);margin-left:8px">주최: ' + escapeHtml(event.organizer) + '</span>' : ''}
                  </div>
                </div>`;
            }).join('')}
          </div>`;
      }

      modal.innerHTML = `
        <div class="modal" style="max-width: 520px;">
          <div class="modal-header">
            <h2 style="display: flex; align-items: center; gap: 10px;">
              <span>🤖</span> 텔레그램 이벤트
            </h2>
            <button class="modal-close" onclick="closeTelegramEventsModal()">&times;</button>
          </div>
          <div class="modal-body" style="padding: 16px;">
            ${totalCount > 0 ? `
              <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 12px;">
                전체 ${totalCount}개 · 추가됨 ${importedCount}개 · 미추가 ${pendingEvents.length}개
              </div>
            ` : ''}
            ${listHtml}
          </div>
          ${pendingEvents.length > 0 ? `
            <div class="modal-footer" style="display: flex; gap: 10px; justify-content: space-between; padding: 15px 20px; border-top: 1px solid var(--border-color);">
              <button class="btn" style="color:#f5576c;background:rgba(245,87,108,0.1);border:1px solid rgba(245,87,108,0.3)" onclick="archiveSelectedTelegramEvents()">🗑 선택 삭제</button>
              <div style="display:flex;gap:10px">
                <button class="btn btn-secondary" onclick="closeTelegramEventsModal()">닫기</button>
                <button class="btn btn-primary" onclick="importSelectedTelegramEvents()">✅ 선택 추가</button>
              </div>
            </div>
          ` : `
            <div class="modal-footer" style="display: flex; gap: 10px; justify-content: flex-end; padding: 15px 20px; border-top: 1px solid var(--border-color);">
              <button class="btn btn-secondary" onclick="closeTelegramEventsModal()">닫기</button>
            </div>
          `}
        </div>
      `;

      // 이벤트 데이터 저장
      modal.dataset.events = JSON.stringify(pendingEvents);
      document.body.appendChild(modal);
      requestAnimationFrame(() => modal.classList.add('active'));
    }

    async function archiveSelectedTelegramEvents() {
      const modal = document.getElementById('telegram-events-modal');
      if (!modal) return;

      const events = JSON.parse(modal.dataset.events || '[]');
      const checkboxes = modal.querySelectorAll('.tg-events-list input[type="checkbox"]:checked');

      if (checkboxes.length === 0) {
        showToast('삭제할 이벤트를 선택해주세요', 'warning');
        return;
      }

      if (!confirm(`선택한 ${checkboxes.length}개 이벤트를 삭제(아카이브)할까요?`)) return;

      const now = new Date().toISOString();
      let archivedCount = 0;
      let failCount = 0;

      for (const cb of checkboxes) {
        const index = parseInt(cb.value);
        const event = events[index];
        if (!event) continue;

        try {
          // Supabase PATCH로 archived_date 설정 (소프트 삭제)
          const res = await fetch(
            `${TG_SUPABASE_URL}/rest/v1/telegram_messages?id=eq.${event.id}`,
            {
              method: 'PATCH',
              headers: {
                'apikey': TG_SUPABASE_KEY,
                'Authorization': `Bearer ${TG_SUPABASE_KEY}`,
                'Content-Type': 'application/json',
                'Prefer': 'return=minimal'
              },
              body: JSON.stringify({ archived_date: now })
            }
          );
          if (res.ok) archivedCount++;
          else failCount++;
        } catch (e) {
          failCount++;
        }
      }

      if (archivedCount > 0) {
        showToast(`🗑 ${archivedCount}개 삭제 완료${failCount > 0 ? ' (' + failCount + '개 실패)' : ''}`, 'success');
        // 모달 닫고 새로고침
        closeTelegramEventsModal();
        setTimeout(() => showTelegramEvents(), 300);
      } else {
        showToast('삭제에 실패했습니다. 권한을 확인해주세요.', 'error');
      }
    }

    function closeTelegramEventsModal() {
      const modal = document.getElementById('telegram-events-modal');
      if (modal) {
        modal.classList.remove('active');
        setTimeout(() => modal.remove(), 300);
      }
    }

    function toggleTgEventDetail(item) {
      const detail = item.querySelector('.tg-event-detail');
      const expand = item.querySelector('.tg-event-expand');
      if (!detail) return;
      const isOpen = detail.style.display !== 'none';
      detail.style.display = isOpen ? 'none' : 'block';
      if (expand) expand.textContent = isOpen ? '▼' : '▲';
    }

    function toggleAllTelegramEvents(label) {
      const checkbox = label.querySelector('input[type="checkbox"]');
      const modal = document.getElementById('telegram-events-modal');
      if (!modal) return;
      // label onclick은 체크박스 토글 전에 실행됨 → 반전된 값 사용
      const newState = !checkbox.checked;
      const checkboxes = modal.querySelectorAll('.tg-events-list input[type="checkbox"]');
      checkboxes.forEach(cb => { cb.checked = newState; });
    }

    async function importSelectedTelegramEvents() {
      const modal = document.getElementById('telegram-events-modal');
      if (!modal) return;

      const events = JSON.parse(modal.dataset.events || '[]');
      const checkboxes = modal.querySelectorAll('.tg-events-list input[type="checkbox"]:checked');

      if (checkboxes.length === 0) {
        showToast('추가할 이벤트를 선택해주세요', 'warning');
        return;
      }

      let addedCount = 0;
      checkboxes.forEach(cb => {
        const index = parseInt(cb.value);
        const event = events[index];
        if (!event) return;

        const newTask = {
          id: generateId(),
          title: event.title || '이벤트 참여',
          category: event.category || '부업',
          estimatedTime: event.estimatedTime || 10,
          expectedRevenue: event.expectedRevenue || null,
          deadline: event.deadline || null,
          description: event.description || null,
          link: event.link || null,
          completed: false,
          pinned: false,
          // telegram-event-bot exportToNavigator 형식과 동일
          source: {
            type: 'telegram-event',
            eventId: event.id,
            channel: event.channel || 'telegram',
            project: event.project || null,
            organizer: event.organizer || null
          },
          createdAt: new Date().toISOString()
        };

        appState.tasks.unshift(newTask);
        addedCount++;
      });

      if (addedCount > 0) {
        saveState();
        renderStatic();
        closeTelegramEventsModal();
        showToast(`✅ ${addedCount}개 이벤트가 추가되었습니다!`, 'success');

        if (appState.user) {
          syncToFirebase();
        }
      }
    }

    // 전역 함수 노출
    window.showTelegramEvents = showTelegramEvents;
    window.closeTelegramEventsModal = closeTelegramEventsModal;
    window.toggleAllTelegramEvents = toggleAllTelegramEvents;
    window.toggleTgEventDetail = toggleTgEventDetail;
    window.importSelectedTelegramEvents = importSelectedTelegramEvents;
    window.archiveSelectedTelegramEvents = archiveSelectedTelegramEvents;
    window.closeImportModal = closeImportModal;
    window.confirmImportTask = confirmImportTask;

    // URL import 체크 (Firebase 로드 후 실행)
    setTimeout(checkUrlImport, 500);

    // Firebase 인증 상태 리스너
    window.addEventListener('firebase-ready', () => {
      // URL import 파라미터 확인 (telegram-event-bot 연동)
      checkUrlImport();

      window.firebaseOnAuthStateChanged(window.firebaseAuth, async (user) => {
        if (user) {
          appState.user = {
            uid: user.uid,
            email: user.email,
            displayName: user.displayName,
            photoURL: user.photoURL
          };

          // 클라우드 데이터 로드 및 실시간 동기화 시작
          await loadFromFirebase();
          startRealtimeSync();

          renderStatic();
        } else {
          appState.user = null;
          appState.syncStatus = 'offline';
          renderStatic();
        }
      });
    });
  </script>
</body>
</html>
